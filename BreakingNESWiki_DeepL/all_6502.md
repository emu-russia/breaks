# 6502

This section is simply a compilation of all subsections to make it easier to use in neural networks for their fine-tuning.

# 6502 Contents

- [Overview](Readme.md)
- [Pinout](pads.md)
- [Clock](clock.md)

## Top Part

- [Instruction Register](ir.md)
- [Extended Cycle Counter](extra_counter.md)
- [Decoder](decoder.md)
- [Pre-decode](predecode.md)
- [Interrupt Processing](interrupts.md)
- [Random Logic](random_logic.md)
	- [Registers Control](regs_control.md)
	- [ALU Control](alu_control.md)
	- [Program Counter Control](pc_control.md)
	- [Bus Control](bus_control.md)
	- [Dispatcher](dispatch.md)
	- [Flags Control](flags_control.md)
	- [Flags](flags.md)
	- [Branch Logic](branch_logic.md)
- [Control Commands](context_control.md)

## Bottom Part

- [Address Bus](address_bus.md)
- [Data Bus](data_bus.md)
- [Registers](regs.md)
- [ALU](alu.md)
- [Program Counter](pc.md)
- [Bus Multiplexer](busmux.md)

# 6502 Overview

The 6502 processor was developed by [MOS](../MOS.md). It was based on the architecture of the Motorola 6800 processor:

|6502|6800|
|---|---|
|<img src="/BreakingNESWiki/imgstore/6502/6502_die_shot.jpg" width="200px">|<img src="/BreakingNESWiki/imgstore/6502/6800.jpg" width="220px">|

In both cases the top part is occupied by the decoder and random logic, and the whole bottom part of the processor is occupied by the context and the ALU.

## Architecture

The processor is divided into two parts: the upper part and the lower part.

The upper part contains the control logic, which issues a number of control lines ("commands") to the lower part.
The lower part contains the context of the processor: internal buses and registers, with one exception - the flags register (P) is in the upper part in a "spread out" form.

Also in the lower part is the [ALU](alu.md).

The processor is clocked by the PHI0 clock pulse, both half-cycles are used.
During the first half-cycle (PHI1) the processor is in "Set Address and R/W Mode" mode.
During the second half-cycle (PHI2) the processor is in "Read/Write Data" mode, during this half-cycle external devices can put data on the data bus and get data from the processor.

6502 overview chart:

![6502_logisim_big](/BreakingNESWiki/imgstore/6502/6502_logisim_big.png)

## Registers

- PD: current operation code for precoding
- IR: instruction register (stores the current operation code)
- X, Y: index registers
- S: Stack pointer
- AI, BI: input values for ALU
- ADD: Intermediate result of an ALU operation
- AC: accumulator
- PCH/PCL: program counter in two halves
- PCHS/PCLS: program counter auxiliary registers (S stands for "Select")
- ABH/ABL: registers for output to the external address bus
- DL: data latch, stores the last read value of the external data bus
- DOR: data output register, holds the value which will be written to the data bus
- P: flag register, actually consists of a set of latches scattered around the circuit

The following registers are directly available to the programmer: A (Accumulator), X, Y, S, P, PC (Program Counter).

## External Buses

There are only two external buses: a 16-bit address bus (ADDR) and an 8-bit data bus (DATA). The address bus is one-way - only the processor can write to it. The data bus is bidirectional.

## Internal Buses

- ADH/ADL: address bus
- SB: Side bus, register exchange bus
- DB: Internal data bus

During the second half-step (PHI2) all internal buses are precharged and have a value of 0xFF. This is done because it is faster to "discharge" the transistor at the right moment than to "charge" it (the change of 1=>0 is faster than the change of 0=>1).

## Register-Bus Connections

![6502_context](/BreakingNESWiki/imgstore/6502/6502_context.jpg)

By connecting buses and registers in series, the processor executes a variety of instructions. The variety of connections provides a variety of processor instructions, and the division of instructions into clock cycles allows complex actions to be performed. In addition, the ALU is controlled (addition, logical operations, etc.).

## Software Model

### Addressing Modes

Addressing modes are described here because they should be kept in mind when analyzing circuits.

**Addressing** is a way to get the operand to (or load it from) the desired memory location. The developers of the 6502 were very generous and added as many as two X and Y index registers to the context.

"Indexed" means that an offset is added to the memory address in a certain way to get a new address. This is usually needed to access arrays. In this case the beginning of the array will be a fixed address and the value in the index register will be the array index (offset).

List of addressing modes:
- Immediate (immediate operand). In this case the operand is stored in the instruction itself (usually the second byte, after the operation code). Example `LDA #$1C`: A = 0x1C
- Absolute (absolute addressing). The instruction specifies the full 16-bit address from which to get the operand. For example `LDA $1234`: A = \[$1234\]
- Zero Page Absolute: Developers have made an optimized version of absolute addressing by adding the ability to address only page zero (pages are 256 bytes in size). Example `LDA $56`: In this case the processor itself makes the highest 8 bits of the address equal to 0x00, while the lowest 8 bits are taken from the instruction. The final address is 0x0056. A = \[0x0056\]. This is done to save instruction size (one byte is saved).
- Indexed: In this addressing mode an offset from the X or Y register is added to the constant address value. For example `LDA $1234, X`: A = \[$1234 + X\]
- Zero Page Indexed: Similar to Indexed but only the X register can be used. Example `LDA $33, X`: A = \[$0033 + X\]

And then the special magic begins:
- Pre-indexed Indirect: The value of the operand which is the address in page zero is added to the value of register X and the indirect address is obtained. The address the indirect address refers to is then used to get the value of the operand. Example `LDA ($34, X)`: A = \[\[$0034 + X\]\]. Important: When you add an address and a value in the X register, it "wraps" around 256 bytes. That is, it does not wrap to the higher half of the address. (0xFF + 0x02 will be 0x0001, not 0x0101). **Indirect** means "take address by address".
- Post-indexed Indirect: Different from the previous one in that the indirect address from page zero is selected first, and then the index register Y value is added to it. Example `LDA ($2A), Y`: A = \[\[$002A\] + Y\].

### Instruction Set

The 6502 has all the necessary instructions and also includes such rather handy instructions as bit rotation (ROL/ROR) and bit testing (BIT). Not all processors of the time contained such instructions.

The instruction type and address mode are fully contained in the operation code, to simplify decoding, but the bus width (8 bits) does not allow all instructions to be executed in a single clock cycle. Also, the decoder is somewhat unoptimized, so the minimum instruction execution time is 2 clock cycles, with the first clock cycle always taken by sampling the operation code (the first byte of the instruction).

Summary of instructions:

|Instruction|Description|
|---|---|
|ADC |Add Memory to Accumulator with Carry|
|AND |"AND" Memory with Accumulator|
|ASL |Shift Left One Bit (Memory or Accumulator)|
|BCC |Branch on Carry Clear|
|BCS |Branch on Carry Set|
|BEQ |Branch on Result Zero|
|BIT |Test Bits in Memory with Accumulator|
|BMI |Branch on Result Minus|
|BNE |Branch on Result not Zero|
|BPL |Branch on Result Plus|
|BRK |Force Break|
|BVC |Branch on Overflow Clear|
|BVS |Branch on Overflow Set|
|CLC |Clear Carry Flag|
|CLD |Clear Decimal Mode|
|CLI |Clear interrupt Disable Bit|
|CLV |Clear Overflow Flag|
|CMP |Compare Memory and Accumulator|
|CPX |Compare Memory and Index X|
|CPY |Compare Memory and Index Y|
|DEC |Decrement Memory by One|
|DEX |Decrement Index X by One|
|DEY |Decrement Index Y by One|
|EOR |"Exclusive-Or" Memory with Accumulator|
|INC |Increment Memory by One|
|INX |Increment Index X by One|
|INY |Increment Index Y by One|
|JMP |Jump to New Location|
|JSR |Jump to New Location Saving Return Address|
|LDA |Load Accumulator with Memory|
|LDX |Load Index X with Memory|
|LDY |Load Index Y with Memory|
|LSR |Shift Right One Bit (Memory or Accumulator)|
|NOP |No Operation|
|ORA |"OR" Memory with Accumulator|
|PHA |Push Accumulator on Stack|
|PHP |Push Processor Status on Stack|
|PLA |Pull Accumulator from Stack|
|PLP |Pull Processor Status from Stack|
|ROL |Rotate One Bit Left (Memory or Accumulator)|
|ROR |Rotate One Bit Right (Memory or Accumulator)|
|RTI |Return from Interrupt|
|RTS |Return from Subroutine|
|SBC |Subtract Memory from Accumulator with Borrow|
|SEC |Set Carry Flag|
|SED |Set Decimal Mode|
|SEI |Set Interrupt Disable Status|
|STA |Store Accumulator in Memory|
|STX |Store Index X in Memory|
|STY |Store Index Y in Memory|
|TAX |Transfer Accumulator to Index X|
|TAY |Transfer Accumulator to Index Y|
|TSX |Transfer Stack Pointer to Index X|
|TXA |Transfer Index X to Accumulator|
|TXS |Transfer Index X to Stack Pointer|
|TYA |Transfer Index Y to Accumulator|

The developers chose the encoding so that it would be easier to process by [decoder](decoder.md) and [random logic](random_logic.md).

Table of 6502 opcodes (for reference):

![6502_opcode_table](/BreakingNESWiki/imgstore/6502/6502_opcode_table.jpg)

You can find a description of the instructions in any Reference Manual for 6502.

### Interrupts

6502 interrupts:
- IRQ: hardware interrupt. Can be disabled with flag I (interrupt disable), if flag I=1 the interrupt is "disabled" and does not go to the CPU. 
- NMI: non-maskable interrupt. It has higher priority than IRQ, triggered on falling edge. 
- RES: hardware reset. After powering up the 6502 it is necessary to set the /RES pin to 0 for a few cycles so that the processor "comes to its senses".
- BRK: software interrupt. It is initiated by the `BRK` instruction.

## Note on Transistor Circuits

The transistor circuits of each component are chopped into component parts so that they don't take up too much space.

To keep you from getting lost, each section includes a special "locator" at the beginning that marks the approximate location of the component being studied on the large 6502 "family portrait" (https://github.com/emu-russia/breaks/blob/master/Docs/6502/6502.jpg)

Example locator:

![6502_locator_alu_control](/BreakingNESWiki/imgstore/6502/6502_locator_alu_control.jpg)

## Note on Logic Circuits

The logic circuits are mostly made in the Logisim program. The following element is used to denote DLatch:

|DLatch (transistor circuit)|DLatch (logic equivalent)|
|---|---|
|![dlatch_tran](/BreakingNESWiki/imgstore/dlatch_tran.jpg)|![dlatch_logic](/BreakingNESWiki/imgstore/dlatch_logic.jpg)|

For convenience, the logical variant of DLatch has two outputs (`out` and `/out`), since the current value of DLatch (out) is often used as an input of a NOR operation.

The optimized versions of the logic diagrams are compiled by @ttlworks and contain an additional source of information for analysis.

# Pinout

The study of any integrated circuit begins with the pinout.

![6502_pads_map](/BreakingNESWiki/imgstore/6502/6502_pads_map.jpg)

![6502_pinout](/BreakingNESWiki/imgstore/6502/6502_pinout.png)

|Name|Direction|Description|
|---|---|---|
|VCC| => 6502     |Power +5 V|
|VSS| 6502 =>     |Ground|
|/NMI| => 6502  |Non-maskable interrupt signal, active low|
|/IRQ| => 6502  |Maskable interrupt signal, active low|
|/RES| => 6502  |Reset signal, active low|
|PHI0| => 6502 |Reference clock signal|
|PHI1| 6502 =>  |First half-cycle, processor in `Set address+RW` mode|
|PHI2| 6502 => |Second half-cycle, processor in `Read/Write Data` mode|
|RDY| => 6502 |Processor Ready (1: ready)|
|SO| => 6502 |Forced setting of the overflow flag (V)|
|R/W| 6502 => |Data bus direction (R/W=1: processor reads data, R/W=0: processor writes)|
|SYNC| 6502 => |The processor is on cycle T1 (opcode fetch)|
|A0-A15| 6502 => |Address bus|
|D0-D7| 6502 <=> |Data bus (bidirectional)|
|N.C.| -- |Not connected|

## VDD/VSS

From the official datasheet we know that the operating range of VDD = +5.0 volts +/- 5%.

## Clock Generator

The clock signals are described in a separate section (see [clock generator](clock.md)).

## /NMI, /IRQ, /RES

![intpads_trans](/BreakingNESWiki/imgstore/6502/intpads_trans.jpg)

Each terminal circuitry contains a FF where the interrupt arrival event is stored. The FF value corresponds to the control signals `/NMIP`, `/IRQP` and `RESP` (the value from FF for the /RES terminal is output as active-high value).

The "P" in the name of the control signals stands for "Pad" (bonding pad).

:warning: Note that the `Q` output is used for NMI and IRQ FF, and the `#Q` output is used for RES FF. The FF circuitry features cyclically closed AOI-21 elements.

![int_ff](/BreakingNESWiki/imgstore/6502/int_ff.png)

## RDY

|![rdy_tran](/BreakingNESWiki/imgstore/6502/rdy_tran.jpg)|![rdy_nice](/BreakingNESWiki/imgstore/6502/rdy_nice.jpg)|
|---|---|

The RDY pin goes to the internal `RDY` signal and also through the DLATCH delay chain as the `/PRDY` ("Previous Ready") signal.
/PRDY goes to the [decoder](decoder.md) input `Branch T0`.

The RDY pin can be used to temporarily suspend the processor, e.g. while an external device performs a DMA.

## SYNC

|![sync_tran](/BreakingNESWiki/imgstore/6502/sync_tran.jpg)|![sync_nice](/BreakingNESWiki/imgstore/6502/sync_nice.jpg)|
|---|---|

The SYNC signal comes from the internal T1 signal (opcode fetch).

## SO

![so_tran](/BreakingNESWiki/imgstore/6502/so_tran.jpg)

The internal signal `SO` is fed to the [flag V](flags.md) input to process the control signal `1/V`.

## R/W

![rw_tran](/BreakingNESWiki/imgstore/6502/rw_tran.jpg)

The `WR` signal comes from [dispatcher](dispatch.md) and defines the operating mode of the processor (WR:1 - processor writes data, WR:0 - processor reads data).

## Address Bus

See [Address Bus](address_bus.md).

## Data Bus

See [Data Bus](data_bus.md).

## Optimized Schematics

![19_pads](/BreakingNESWiki/imgstore/6502/ttlworks/19_pads.png)

# Clock Generator

The 6502 includes two clock reference circuits: an external and an internal one.

The processor inputs one clock signal, `PHI0`, and outputs two clock signals, `PHI1` and `PHI2`.

This principle is based on the fact that each clock cycle of the processor consists of two "modes" (or "states"):
- PHI1=1: Set address and R/W mode
- PHI2=1: Read/write data

During write mode the `PHI1` signal is high. During this time, external devices can use the address set on the external address bus of the processor.

During read mode the signal `PHI2` is high. During this time external devices can write data to the processor's data bus so that the processor can use it for its own purposes.

The signals `PHI1` and `PHI2` are called half-cycles and are derived from the original clock signal `PHI0` as follows:
- When `PHI0` is low - the `PHI1` signal is high
- When `PHI0` is high - the `PHI2` signal is also high

|PHI0|PHI1|PHI2|
|---|---|---|
|0|1|0|
|1|0|1|

This approach to organizing cycle time scheduling is not uncommon among older processors and is commonly referred to as "Dual-rail CLK".

## Internal Clock

![clock_internal](/BreakingNESWiki/imgstore/6502/clock_internal.jpg)

The circuit is quite complicated, because it is not quite "digital". The numerous transistors that act as inverters slightly delay the PHI0 signal, so the PHI1 and PHI2 signals going inside the processor are a bit "laggy". Here is the logical representation of the circuit:

![clock_internal_logic](/BreakingNESWiki/imgstore/6502/clock_internal_logic.jpg)

Logical analysis:

![clock_internal_logic_zero](/BreakingNESWiki/imgstore/6502/clock_internal_logic_zero.jpg)

![clock_internal_logic_one](/BreakingNESWiki/imgstore/6502/clock_internal_logic_one.jpg)

The layout of the clock signals should be about the following:
- PHI1/PHI2 are slightly lagging relative to PHI0
- The lower level of PHI1/PHI2 is slightly longer than the upper level, so that both signals are guaranteed not to have a high level

![4672299](/BreakingNESWiki/imgstore/6502/waves/4672299.png)

The simulation in Altera Quartus shows "lag", but does not show the elongated lower level (it is hand-drawn in the picture above).

BigEd from the 6502.org forum suggested that he ran a simulation on the 6502 FPGA netlist and got the following sweeps:

![cclk-rising](/BreakingNESWiki/imgstore/6502/waves/cclk-rising.png)

![cclk-falling](/BreakingNESWiki/imgstore/6502/waves/cclk-falling.png)

The signal designations are as follows: clk0 = PHI0, cp1 = PHI1, cclk = PHI2 (according to the netlist with Visual6502)

The schematic on which his simulation was based corresponds to the one in Balasz's documentation:

![clock_balazs](/BreakingNESWiki/imgstore/6502/clock_balazs.png)

http://forum.6502.org/viewtopic.php?f=8&t=2208&start=195

It turns out that because of the asymmetrical inverter stage the rising edge is delayed, so the lower level is as if "delayed".

The official documentation gives the following diagram:

![clock_timing_datasheet](/BreakingNESWiki/imgstore/6502/clock_timing_datasheet.jpg)

Optimized schematics:

![8_clock_internal](/BreakingNESWiki/imgstore/6502/ttlworks/8_clock_internal.png)

## External Clock

![clock_external](/BreakingNESWiki/imgstore/6502/clock_external.jpg)

The PHI1/PHI2 reference signals are also output to the outside for consumers.

The logic circuit of the external wiring of the clock signals does not differ from the internal wiring circuit, except that the outputs of PHI1/PHI2 go to the same contacts through the "comb" of powerful transistors.

## Why PHI

In the official 6502 datasheet the half-cycles are called "phases", respectively the name of these signals is Φ1 and Φ2. For unification we use the designations PHI1 and PHI2.

# Instruction Register

![6502_locator_ir](/BreakingNESWiki/imgstore/6502/6502_locator_ir.jpg)

The Instruction Register (IR) stores the current operation code, for processing on [decoder](decoder.md). The operation code is loaded into the IR from [predecode logic](predecode.md).

## Transistor Circuit

![ir_tran](/BreakingNESWiki/imgstore/6502/ir_tran.jpg)

The outputs in the schematic are on the left because the decoder is topologically located on the left side.

- IR0 and IR1 are combined into one common line `IR01` to save lines
- IR0 is used only for the 128th decoder line (IMPL) (this operation with IR0 is part of the random logic)
- /IR5 goes additionally to flags and is used in set/clear flags instructions (SEI/CLI, SED/CLD, SEC/CLC)

## Logic

![ir_logic](/BreakingNESWiki/imgstore/6502/ir_logic.jpg)

- During PHI1 the IR value is overloaded from the [Predecode (PD)](predecode.md) latch, but only if the `FETCH` command is active
- During PHI2 the IR is "refreshed" (this is not shown in logic circuit)

It should be noted that an inverted operation code (PD) value is fed to the IR input and is also stored on the latch in an inverted form.

## Optimized Schematics

![18_ir_logic](/BreakingNESWiki/imgstore/6502/ttlworks/18_ir_logic.png)

# Extended Cycle Counter

![6502_locator_extended_counter](/BreakingNESWiki/imgstore/6502/6502_locator_extended_counter.jpg)

The 6502 has 3 cycle counters:
- The base counter, used for short instructions (Counts T0-T1 cycles)
- Extended counter (which we will talk about here) used for long instructions (Counts cycles T2-T5)
- Counter for very long instructions (Counts cycles RMW T6-T7)

One cycle (T) refers to two consecutive half-cycles (PHI1 + PHI2) of the processor.

## Transistor Circuit

![extended_cycle_counter_trans](/BreakingNESWiki/imgstore/6502/extended_cycle_counter_trans.jpg)

The whole circuit is a shift register, with a control signal `T1` as its input. While the shift register is running, the value of T1 is shifted and goes to the output of `/T2`, then to `/T3` and so on. The /T2-/T5 outputs are in inverse logic.

The shift register is used as a counter for easy transfer of the current cycle (/T2-/T5) to the decoder input.

The register is reset by the `TRES2` command and is done after the instruction has been processed.

The circuit includes multiplexers on the `/ready` signal. This is done so that when the processor is not ready (ready=0) - shift register remains in the current state.

## Logic

![extended_cycle_counter_logic](/BreakingNESWiki/imgstore/6502/extended_cycle_counter_logic.jpg)

## Optimized Schematics

![14_extended_cycle_counter_logic](/BreakingNESWiki/imgstore/6502/ttlworks/14_extended_cycle_counter_logic.png)

# Decoder

![6502_locator_decoder](/BreakingNESWiki/imgstore/6502/6502_locator_decoder.jpg)

The decoder is an ordinary demultiplexer, but a very large one. The formula for the demultiplexer is 21-to-130. Sometimes the 6502 instruction decoder is also called a PLA.

Topologically, the decoder is divided by ground lines into several groups, so we'll stick to the same division, for convenience.

## Decoder Inputs

The input signals are:
- /T0, /T1X: current cycle for short (2 clock) instructions. These signals are output from [dispatch logic](dispatch.md).
- /T2, /T3, /T4, /T5: current cycle for long instructions. Signals are output from [extended cycle counter](extra_counter.md).
- /IR0, /IR1, IR01: the lower bits of the operation code from [instruction register](ir.md). To reduce the number of lines 0 and 1 bits are combined into one control line `IR01`.
- IR2-IR7, /IR2-/IR7: direct and inverse values of the remaining bits. The direct and inverse forms are needed to check the bit for 0 and 1.

## Principle

Schematically, each output is a multi-input NOR element.

![decoder_nice1](/BreakingNESWiki/imgstore/6502/decoder_nice1.jpg)

![decoder_nice2](/BreakingNESWiki/imgstore/6502/decoder_nice2.jpg)

The @ttlworks version of the decoder:

![10_decoder](/BreakingNESWiki/imgstore/6502/ttlworks/10_decoder.png)

## Special Lines

Additional logical operations are applied to some decoder outputs, which although territorially are in the decoder area, are actually part of [random logic](random_logic.md). Most likely this logic got into the decoder simply because it was more convenient to split the connections that way.

List:
- Internal Push/Pull line: a special (129th) line that does not extend beyond the decoder. It is used to "cut off" Push/pull instructions when selecting instructions. It is used in three lines: 83, 90, and 128. Appears on the schematic in duplicate, for different parts of the decoder.
- /PRDY: this line goes to decoder line 73 (Branch T0)
- IR0: normally the common signal IR01 is used to check the two lowest bits of the operation code, but exclusively for the 128th line (IMPL), IR0 is used (IR0 is not included in the mask for the table below).

## PLA Contents

|Group|N|Mask value (Raw bits)|Decoded mask value|Cycle (T)|Comments|Where to use|
|---|---|---|---|---|---|---|
|A|||||||
|A01   |0 |000101100000100100000   |100XX100 |TX     |STY|Register control|
|A02   |1 |000000010110001000100   |XXX100X1 |T3     |OP ind, Y|Register control|
|A03   |2 |000000011010001001000   |XXX110X1 |T2     |OP abs, Y|Register control|
|A04   |3 |010100011001100100000   |1X001000 |T0     |DEY INY  |Register control|
|A05   |4 |010101011010100100000   |10011000 |T0     |TYA      |Register control|
|A06   |5 |010110000001100100000   |1100XX00 |T0     |CPY INY  |Register control|
|B|||||||
|B01   |6 |000000100010000001000   |XXX1X1XX |T2     |OP zpg, X/Y & OP abs, X/Y |Register control|
|B02   |7 |000001000000100010000   |10XXXX1X |TX     |LDX STX A<->X S<->X       |Register control|
|B03   |8 |000000010101001001000   |XXX000X1 |T2     |OP ind, X        |Register control|
|B04   |9 |010101011001100010000   |1000101X |T0     |TXA              |Register control|
|B05  |10 |010110011001100010000   |1100101X |T0     |DEX              |Register control|
|B06  |11 |011010000001100100000   |1110XX00 |T0     |CPX INX          |Register control|
|B07  |12 |000101000000100010000   |100XXX1X |TX     |STX TXA TXS|Register control|
|B08  |13 |010101011010100010000   |1001101X |T0     |TXS                |Register control|
|B09  |14 |011001000000100010000   |101XXX1X |T0     |LDX TAX TSX|Register control|
|B10  |15 |100110011001100010000   |1100101X |T1     |DEX|Register control|
|B11  |16 |101010011001100100000   |11101000 |T1     |INX|Register control|
|B12  |17 |011001011010100010000   |1011101X |T0     |TSX|Register control|
|B13  |18 |100100011001100100000   |1X001000 |T1     |DEY INY|Register control|
|B14  |19 |011001100000100100000   |101XX100 |T0     |LDY|Register control|
|B15  |20 |011001000001100100000   |1010XX00 |T0     |LDY TAY|Register control|
|C|||||||
|C01  |21 |011001010101010100000   |00100000 |T0     |JSR|Register control|
|C02  |22 |000101010101010100001   |00000000 |T5     |BRK|Register control; Auxiliary signal BRK5|
|C03  |23 |010100011001010100000   |0X001000 |T0     |Push|Register control|
|C04  |24 |001010010101010100010   |01100000 |T4     |RTS|Register control|
|C05  |25 |001000011001010100100   |0X101000 |T3     |Pull|Register control|
|C06  |26 |000110010101010100001   |01000000 |T5     |RTI|Register control; Auxiliary signal RTI/5|
|C07  |27 |001010000000010010000   |011XXX1X |TX     |ROR|To obtain an auxiliary /ROR signal for the ADD/SB7 circuit|
|C08  |28 |000000000000000001000   |XXXXXXXX |T2     |T2 ANY|Auxiliary signal T2 (processor is in cycle T2)|
|C09  |29 |010110000000011000000   |010XXXX1 |T0     |EOR|ALU Control|
|C10  |30 |000010101001010100000   |01X01100 |TX     |JMP (excluder for C11)|ALU Control|
|C11  |31 |000000101001000001000   |XXX011XX |T2     |ALU absolute|ALU Control|
|C12  |32 |010101000000011000000   |000XXXX1 |T0     |ORA|ALU Control|
|C13  |33 |000000000100000001000   |XXXX0XXX |T2     |The entire "left" half of the opcode table (values `X0-X7`)|ALU Control|
|C14  |34 |010000000000000000000   |XXXXXXXX |T0     |T0 ANY|ALU Control|
|C15  |35 |000000010001010101000   |0XX0X000 |T2     |BRK JSR RTI RTS Push/pull - stack operations on T2|Regs Control, ALU Control; Auxiliary signal STK2|
|C16  |36 |000000000001010100100   |0XX0XX00 |T3     |BRK JSR RTI RTS Push/pull + BIT JMP|ALU Control|
|D|||||||
|D01  |37 |000001010101010100010   |00X00000 |T4     |BRK JSR|ALU Control|
|D02  |38 |000110010101010100010   |01000000 |T4     |RTI|ALU Control|
|D03  |39 |000000010101001000100   |XXX000X1 |T3     |OP X, ind|ALU Control|
|D04  |40 |000000010110001000010   |XXX100X1 |T4     |OP ind, Y|ALU Control|
|D05  |41 |000000010110001001000   |XXX100X1 |T2     |OP ind, Y|ALU Control|
|D06  |42 |000000001010000000100   |XXX11XXX |T3     |RIGHT ODD|ALU Control|
|D07  |43 |001000011001010100000   |0X101000 |TX     |Pull|ALU Control|
|D08  |44 |001010000000100010000   |111XXX1X |TX     |INC NOP|ALU Control|
|D09  |45 |000000010101001000010   |XXX000X1 |T4     |OP X, ind|ALU Control; Bus Control (DL/DB)|
|D10  |46 |000000010110001000100   |XXX100X1 |T3     |OP ind, Y|Bus Control (DL/DB)|
|D11  |47 |000010010101010100000   |01X00000 |TX     |RTI RTS|Bus Control (DL/DB); Auxiliary signal RET|
|D12  |48 |001001010101010101000   |00100000 |T2     |JSR|Auxiliary signal JSR2|
|D13  |49 |010010000001100100000   |11X0XX00 |T0     |CPY CPX INY INX|ALU Control|
|D14  |50 |010110000000101000000   |110XXXX1 |T0     |CMP|ALU Control|
|D15  |51 |011010000000101000000   |111XXXX1 |T0     |SBC|ALU Control; Auxiliary signal SBC0|
|D16  |52 |011010000000001000000   |X11XXXX1 |T0     |ADC SBC|ALU Control|
|D17  |53 |001001000000010010000   |001XXX1X |TX     |ROL|ALU Control|
|E|||||||
|E01  |54 |000010101001010100100   |01X01100 |T3     |JMP ind|ALU Control|
|E02  |55 |000001000000010010000   |00XXXX1X |TX     |ASL ROL|Bus Control|
|E03  |56 |001001010101010100001   |00100000 |T5     |JSR|Auxiliary signal JSR/5|
|E04  |57 |000000010001010101000   |0XX0X000 |T2     |BRK JSR RTI RTS Push/pull|Bus Control|
|E05  |58 |010101011010100100000   |10011000 |T0     |TYA|Bus Control|
|E06  |59 |100000000000011000000   |0XXXXXX1 |T1     |UPPER ODD|Bus Control|
|E07  |60 |101010000000001000000   |X11XXXX1 |T1     |ADC SBC|Bus Control|
|E08  |61 |100000011001010010000   |0XX0101X |T1     |ASL ROL LSR ROR|Bus Control|
|E09  |62 |010101011001100010000   |1000101X |T0     |TXA|Bus Control|
|E10  |63 |011010011001010100000   |01101000 |T0     |PLA|Bus Control|
|E11  |64 |011001000000101000000   |101XXXX1 |T0     |LDA|Bus Control|
|E12  |65 |010000000000001000000   |XXXXXXX1 |T0     |ALL ODD|Bus Control|
|E13  |66 |011001011001100100000   |10101000 |T0     |TAY|Bus Control|
|E14  |67 |010000011001010010000   |0XX0101X |T0     |ASL ROL LSR ROR|Bus Control|
|E15  |68 |011001011001100010000   |1010101X |T0     |TAX|Bus Control|
|E16  |69 |011001100001010100000   |0010X100 |T0     |BIT0|ALU Control (AND)|
|E17  |70 |011001000000011000000   |001XXXX1 |T0     |AND0|ALU Control (AND)|
|E18  |71 |000000001010000000010   |XXX11XXX |T4     |OP abs,XY|Bus Control (ADL/ABL)|
|E19  |72 |000000010110001000001   |XXX100X1 |T5     |OP ind,Y|Bus Control (ADL/ABL)|
|F|||||||
|F01  |73 |010000010110000100000   |XXX10000 |T0 |<-  Branch. :warning: Additionally affected by the /PRDY line (from the RDY contact), immediately on the spot|Auxiliary signal BR0|
|F02  |74 |000110011001010101000   |01001000 |T2     |PHA|Bus Control (AC/DB)|
|F03  |75 |010010011001010010000   |01X0101X |T0     |LSR ROR|ALU Control (SR)|
|F04  |76 |000010000000010010000   |01XXXX1X |TX     |LSR ROR|ALU Control (SR)|
|F05  |77 |000101010101010101000   |00000000 |T2     |BRK|PC Control|
|F06  |78 |001001010101010100100   |00100000 |T3     |JSR|PC Control|
|F07  |79 |000101000000101000000   |100XXXX1 |TX     |STA|Auxiliary signal STA|
|F08  |80 |000000010110000101000   |XXX10000 |T2     |BR2 (Branch T2)|PC control circuit and PC increment circuit|
|F09  |81 |000000100100000001000   |XXXX01XX |T2     |zero page|Bus Control (DL/ADL)|
|F10  |82 |000000010100001001000   |XXXX00X1 |T2     |ALU indirect|Bus Control (DL/ADL)|
|F11  |83 |000000001000000001000   |XXXX1XXX |T2     |The entire "right" half of the opcode table (`X8-XF` values). The Push/Pull opcode exclusion operation is additionally applied to this line, right in place|Auxiliary signal ABS/2|
|F12  |84 |001010010101010100001   |01100000 |T5     |RTS|Auxiliary signal RTS/5|
|F13  |85 |000000000000000000010   |XXXXXXXX |T4     |T4 ANY|Bus Control (NOADL)|
|F14  |86 |000000000000000000100   |XXXXXXXX |T3     |T3 ANY|Bus Control (NOADL)|
|F15  |87 |010100010101010100000   |0X000000 |T0     |BRK RTI|Bus Control (NOADL)|
|F16  |88 |010010101001010100000   |01X01100 |T0     |JMP|Bus Control (IND)|
|F17  |89 |000000010101001000001   |XXX000X1 |T5     |OP X, ind|Bus Control (NOADL, IND)|
|F18  |90 |000000001000000000100   |XXXX1XXX |T3     |The entire "right" half of the opcode table (`X8-XF` values). The Push/Pull opcode exclusion operation is additionally applied to this line, right in place|Bus Control (IND)|
|G|||||||
|G01  |91 |000000010110001000010   |XXX100X1 |T4     |OP ind, Y|Cycle Counter Reset, Bus Control (IND)|
|G02  |92 |000000001010000000100   |XXX11XXX |T3     |RIGHT ODD|Cycle Counter Reset|
|G03  |93 |000000010110000100100   |XXX10000 |T3     |BR3 (Branch T3)|PC control circuit and PC increment circuit|
|G04  |94 |000100010101010100000   |0X000000 |TX     |BRK RTI|PC Control (JB)|
|G05  |95 |001001010101010100000   |00100000 |TX     |JSR|PC Control (JB)|
|G06  |96 |000010101001010100000   |01X01100 |TX     |JMP|PC Control (JB), ENDX (Long instruction completion)|
|P/P |129 |000000011001010100000   |0XX01000 |TX |<-  Push/pull opcodes, used as an exclusive for F11 & F18 (in situ)|First pp instance|
|G07  |97 |000101000000100000000   |100XXXXX |TX     |STORE|For RW Control and to obtain an auxiliary STOR signal|
|G08  |98 |000101010101010100010   |00000000 |T4     |BRK|RW Control, !POUT (flags control)|
|G09  |99 |000101011001010101000   |00001000 |T2     |PHP|!POUT (flags control)|
|G10 |100 |000100011001010101000   |0X001000 |T2     |Push|RW Control, ENDX (Long instruction completion)|
|G11 |101 |000010101001010100010   |01X01100 |T4     |JMP ind|ENDX, Bus Control; Auxiliary signal JMP/4|
|G12 |102 |000010010101010100001   |01X00000 |T5     |RTI RTS|ENDX (Long instruction completion)|
|G13 |103 |001001010101010100001   |00100000 |T5     |JSR|ENDX (Long instruction completion)|
|H|||||||
|H01 |104 |000110101001010101000   |01001100 |T2     |JMP abs|ENDX (Long instruction completion)|
|H02 |105 |001000011001010100100   |0X101000 |T3     |Pull|ENDX (Long instruction completion)|
|H03 |106 |000010000000000010000   |X1XXXX1X |TX     |LSR ROR DEC INC DEX NOP (4x4 bottom right)|Cycle Counter 5-6|
|H04 |107 |000001000000010010000   |00XXXX1X |TX     |ASL ROL|Cycle Counter 5-6, flags control|
|H05 |108 |010010011010010100000   |01X11000 |T0     |CLI SEI|flags control|
|H06 |109 |101001100001010100000   |0010X100 |T1     |BIT|flags control|
|H07 |110 |010001011010010100000   |00X11000 |T0     |CLC SEC|flags control|
|H08 |111 |000000100110000000100   |XXX101XX |T3     |Memory zero page X/Y|MemOP|
|H09 |112 |101010000000001000000   |X11XXXX1 |T1     |ADC SBC|flags control|
|H10 |113 |011001100001010100000   |0010X100 |T0     |BIT|flags control|
|H11 |114 |011001011001010100000   |00101000 |T0     |PLP|flags control|
|H12 |115 |000110010101010100010   |01000000 |T4     |RTI|flags control|
|H13 |116 |100110000000101000000   |110XXXX1 |T1     |CMP|flags control|
|H14 |117 |100010101001100100000   |11X01100 |T1     |CPY CPX abs|flags control|
|H15 |118 |100001011001010010000   |00X0101X |T1     |ASL ROL|flags control|
|H16 |119 |100010000101100100000   |11X00X00 |T1     |CPY CPX zpg/immed|flags control|
|K|||||||
|P/P |129 |000000011001010100000   |0XX01000 |TX     |<-  Push/pull opcodes, used as an exclusive for K09 (in situ)|Second pp instance|
|K01 |120 |010010011010100100000   |11X11000 |T0     |CLD SED|flags control|
|K02 |121 |000001000000000000000   |X0XXXXXX |TX     |/IR6|Branch Logic|
|K03 |122 |000000101001000000100   |XXX011XX |T3     |Memory absolute|MemOP|
|K04 |123 |000000100101000001000   |XXX001XX |T2     |Memory zero page|MemOP|
|K05 |124 |000000010100001000001   |XXXX00X1 |T5     |Memory indirect|MemOP|
|K06 |125 |000000001010000000010   |XXX11XXX |T4     |Memory absolute X/Y|MemOP|
|K07 |126 |000000000000010000000   |0XXXXXXX |TX     |/IR7|Branch Logic|
|K08 |127 |001001011010100100000   |10111000 |TX     |CLV|flags control|
|K09 |128 |000000011000000000000   |XXXX10X0 |TX     |IMPL. :warning: The Push/Pull opcode exclusion operation is additionally applied to this line, right on the spot. Also, the mask for this line does not take into account the `& ~IR0` operation|Bus Control (DL/DB)|

## What Raw bits mean

If you think of a decoder as a 21x130 ROM, where each bit represents a transistor, then the `Raw bits` value will represent one line of the decoder. This is why it is called the mask value.

For example, the picture shows the 5th line of the decoder. The bit order in the picture is bottom-up from the most significant bits to the least significant bits (msb -> lsb). 0 means no transistor, 1 means present.

![decoder_line](/BreakingNESWiki/imgstore/6502/decoder_line.jpg)

## Online Decoder

You can use an online decoder to highlight opcodes: https://github.com/emu-russia/breaks/blob/master/Docs/6502/decoder.htm

In the `Raw bits` field you can insert the mask value from the table above and when you press the `Make IR Mask` button you will get the decoded mask value (e.g. `11X00X00`). 
The decoded mask value can be inserted into the `IR` field and when the `Decode` button is pressed, the opcodes that correspond to the specified IR mask will be highlighted in the table.

## Branch T0 Skip

From pin [RDY](pads.md) a special line `/PRDY` comes through the delay line. If the processor was not ready when the _previous_ instruction finished, then if the next instruction is a conditional branch, its cycle 0 (T0) is skipped.

The meaning of this operation is not known yet.

## Why the decoder is so big and scary

Actually, there is nothing scary about it.

The decoder was compiled according to the requirements of random logic. Random logic is divided into several parts (domains) and each part corresponds to its own zone in the decoder, which was specially chosen so that the necessary opcodes were processed.

In other words - it is not random logic that adjusts to decoder, but vice versa. The impression that the decoder is "more important" is formed simply because it is above random logic.

# Predecode

![6502_locator_predecode](/BreakingNESWiki/imgstore/6502/6502_locator_predecode.jpg)

The circuit is designed to define the "class" of an instruction: 
- A short instruction which is executed in 2 clock cycles (`TWOCYCLE`)
- An instruction of type `IMPLIED` which has no operands (takes 1 byte in memory)

![predecode_tran](/BreakingNESWiki/imgstore/6502/predecode_tran.jpg)

The operation code received from the external data bus (D0...D7) is first stored on the transparent DLatch and then during PHI2 on the PREDECODE (PD) latch (in inverted form), after which the precoding logic immediately determines the instruction class (the circuit is combinatorial).

The output `/TWOCYCLE` is used by a short cycle counter. The output `/IMPLIED` is used by the PC increment logic.

The PD latch value is fed to the [instruction register](ir.md) input in inverted form.

Also the control line `0/IR` is fed to the Predecode logic input which "injects" the BRK operation into the instruction stream. This occurs during interrupt processing, to initialize the BRK sequence (all interrupts simply mimic the BRK instruction, with slight modifications).

The pre-decode circuit works closely with the [dispatcher](dispatch.md), all control signals go there.

## Logic

![predecode_logic](/BreakingNESWiki/imgstore/6502/predecode_logic.jpg)

The predecoding logic is self-descriptive:
- 2-cycle instructions are: Direct operand instructions OR all single-byte instructions EXCEPT push/pull instructions (specified by mask XXX010X1 + 1XX000X0 + XXXX10X0 - 0XX0XX0X)
- Single-byte instructions are set by mask XXXX10X0

TWOCYCLE instructions:

![predecode_twocycle](/BreakingNESWiki/imgstore/6502/predecode_twocycle.jpg)

IMPLIED instructions:

![predecode_implied](/BreakingNESWiki/imgstore/6502/predecode_implied.jpg)

## Optimized Schematics

![24_predecode_logic](/BreakingNESWiki/imgstore/6502/ttlworks/24_predecode_logic.png)

# Interrupt Processing

![6502_locator_intr](/BreakingNESWiki/imgstore/6502/6502_locator_intr.jpg)

Interrupt processing includes the following circuits:
- NMI edge detection
- Cycle counter 6-7 for interrupt handling
- Setting the low-order bits of the interrupt vector address (ADL0-3)
- Circuit for issuing internal signal `DORES`.
- B Flag

The common designation for the 6502 interrupt handling process is called "BRK-sequence".

Three signals `/NMIP`, `/IRQP` and `RESP` come to the input of the circuits from the corresponding input pads.

## NMI Processing

Transistor circuit (includes cycle counter 6-7 and NMI edge detector):

![intr_cycles_nmip_tran](/BreakingNESWiki/imgstore/6502/intr_cycles_nmip_tran.jpg)

## Interrupt vector address and Reset FF

Transistor circuit:

![intr_resp_address_tran](/BreakingNESWiki/imgstore/6502/intr_resp_address_tran.jpg)

The circuit for getting the control signal `DORES` ("Do Reset") (which is binned to all other internals) is combined here with the interrupt vector setting circuit to save space.

## B Flag

Transistor circuit:

![intr_b_flag_tran](/BreakingNESWiki/imgstore/6502/intr_b_flag_tran.jpg)

## Logic

Interrupt handling schematic:

![int_control_logisim](/BreakingNESWiki/imgstore/6502/int_control_logisim.jpg)

To handle interrupts an additional circuit is required to generate cycles 6 and 7 (because they do not come from the decoder) (control signals `BRK6E` and `BRK7`). And the control signal BRK6E ("Break Cycle 6 End") starts during PHI2 of cycle 6 and ends during PHI1 of cycle 7. This is done to determine the edge of the /NMI signal.

The detection of the /NMI edge is done by a classic edge detection circuit based on two RS triggers.

The /RES signal is additionally stored on RESET FLIP/FLOP, because it is required for other random logic circuits (particularly for special control of the R/W pin).

The arrival of any interrupt is reflected on flag B, the output of which (`B_OUT`) forces the processor to execute a BRK instruction (operation code 0x00). This way the developers have unified the handling of all interrupts.

The last small circuit forms the address (or vector) of the interrupts (control signals 0/ADL0, 0/ADL1 and 0/ADL2), which control the lowest 3 bits of the address bus.

Schematic for setting the address of the interrupt handler:

![int_address_logisim](/BreakingNESWiki/imgstore/6502/int_address_logisim.jpg)

## Optimized Schematics

![17_interrupt_logic](/BreakingNESWiki/imgstore/6502/ttlworks/17_interrupt_logic.png)

# Random Logic

![6502_locator_random](/BreakingNESWiki/imgstore/6502/6502_locator_random.jpg)

The name has nothing to do with random numbers, it simply reflects the essence of randomly scattered circuits here and there.

This logic is the thinking organ of the processor and completely determines its behavior when processing and executing instructions.

From the hardware point of view, the random logic is a "handmade" product of [MOS](.../MOS.md) engineers, which is a mess of transistors and wires. Therefore, it would be more correct to use the name "chaotic logic" instead of random logic.

There is no need to give a full-size transistor circuit here, because it will be easier to master it by component parts.

Below you can see all the function blocks of the random logic:
- [Register control](regs_control.md)
- [ALU control](alu_control.md)
- [Program counter (PC) control](pc_control.md)
- [Bus control](bus_control.md)
- [Execution logic (dispatch)](dispatch.md)
- [Flags control logic](flags_control.md)
- [Flags](flags.md)
- [Conditional branch logic](branch_logic.md)

Overview schematic:

![random_logic_logisim](/BreakingNESWiki/imgstore/6502/random_logic_logisim.jpg)

## Principle of Operation

In general, the operation of the logic is quite complex (did you think I would say simple again? :smiley:):
- The execution logic (dispatch) conducts the work of the entire processor. It determines when to terminate an instruction and also controls the PC increment and the cycle counter. Additionally it includes a processor readiness circuit (RDY) which is controlled by the RDY pin.
- After the execution logic has started executing the next instruction - the code of that instruction as well as the current cycle is fed to the decoder
- Depending on the results of decoding the control circuitry of registers, ALU, PC and buses give outward to the lower part special [control commands](context_control.md)
- Additionally, the behavior of the processor is affected by its flags as well as interrupt handling logic. And flags are also affected by executable instructions.

All this is closely coupled to control the lower part of the processor, where its context (registers), ALU and communication with the outside world via buses are located.

## Auxiliary Signals

This section contains a table of auxiliary signals exchanged between all parts of the random logic (for reference):

|Name|From|To|Description|
|---|---|---|---|
|ACRL1|Dispatch|Dispatch|One of the ACR Latch outputs|
|ACRL2|Dispatch|Bus Control|One of the ACR Latch outputs|
|AND|ALU Control|Bus Control|Used when forming an ALU `ANDS` command|
|BR2|Decoder|PC Control, PC Increment|Branch T2|
|BR3|Decoder|PC Control, PC Increment|Branch T3|
|BRFW|Branch Logic, ALU Control|PC Control|Branch forward (whenever taken)|
|BRK5|Decoder|Interrupts, Regs Control|Used to obtain the `STKOP` signal and also goes into the [interrupt handling](interrupts.md) circuit|
|BRK6E|Interrupts|ALU Control, Bus Control|BRK6 (cycle 6 of the interrupt sequence), during the half-step PHI2|
|/BRTAKEN|Branch Logic|PC Control|Branch taken|
|C_OUT|Flags|ALU Control|Flag C value|
|/C_OUT|Flags|ALU Control|Flag C value (inverted)|
|DL/PCH|PC Control|Bus Control|Intermediate signal|
|D_OUT|Flags|ALU Control|Flag D value|
|JSR2|Decoder|Regs Control, ALU Control, Bus Control|To obtain the `JSXY` signal and other bus control circuits|
|/JSR2|Bus Control|Regs Control|Intermediate signal, JSR2 inversion|
|IMPL|Decoder|ALU Control|Decoder X128. Additionally modified with Push/Pull (X129) and IR0 signals.|
|INC_SB|ALU Control|Bus Control|Intermediate signal ("Increment SB")|
|NOADL|Bus Control|ALU Control|Intermediate signal ("No ADL")|
|PC/DB|PC Control|Dispatch|Auxiliary output signal for the RW Control circuit that is part of the dispatcher|
|PGX|Bus Control|ALU Control|Intermediate signal ("Page X")|
|/ready|Dispatch|All|Global internal processor readiness signal|
|RTI/5|Decoder|Regs Control, ALU Control|Used to obtain `STKOP` and `NOADL` signals|
|#SBXY|Regs Control|Bus Control|Intermediate signal ("SB Bus X,Y")|
|STK2|Decoder|Regs Control, ALU Control|Auxiliary signal from decoder (X35)|
|STKOP|Regs Control|ALU Control|Intermediate signal ("Stack Operation")|
|STOR|Dispatcher|Regs Control, ALU Control, RW Control|Intermediate signal|
|STXY|Regs Control|Bus Control|Intermediate signal ("Store X,Y")|
|T0|Short Cycle Counter|All|Processor in the T0 instruction execution cycle|
|T1|PC Control|All|Processor in the T1 cycle|
|T2|Decoder|All|Processor in the T2 cycle|
|T6 RMW|Long Cycle Counter|All|Processor in cycle RMW T6 (the name `T5` is the old name of the signal)|
|T7 RMW|Long Cycle Counter|All|Processor in cycle RMW T7 (the name `T6` is the old name of the signal)|
|ZTST|Bus Control|Flags Control|Intermediate signal ("Z Test")|

Do not look for any sacred meaning in the auxiliary signals - just take them as intermediate values of combinatorial logic.

# Registers Control

![6502_locator_regs_control](/BreakingNESWiki/imgstore/6502/6502_locator_regs_control.jpg)

Most likely this control circuit will be observed first, so I will write here: be prepared to see a large number of intermediate signals in the control circuits, which can come sometimes from all other parts of the random logic. A summary table of all the intermediate signals can be found in the main section with the [random logic overview](random_logic.md).

The register control circuit is responsible for generating [control commands](context_control.md) to exchange registers with the internal buses.

![regs_control](/BreakingNESWiki/imgstore/6502/regs_control.jpg)

Inputs:

|Signal|Description|
|---|---|
|X0-X26|Outputs from the decoder|
|/JSR2|Intermediate signal from the [bus control circuit](bus_control.md)|
|STK2|Just an auxiliary signal from another part of the decoder (X35)|
|STOR|Auxiliary signal from the [dispatcher circuit](dispatch.md)|
|/ready|Global processor readiness signal|

Outputs:

|Signal|Description|
|---|---|
|#SBXY|Intermediate signal for [bus control circuitry](bus_control.md)|
|STXY|Intermediate signal for bus control circuitry|
|STKOP|Intermediate signal ("Stack Operation") for the [ALU control circuit](alu_control.md)|
|#Y/SB|Intermediate signal to latch, to obtain a Y/SB command|
|#X/SB|Intermediate signal to latch, to obtain a X/SB command|
|#SB/X|Intermediate signal to latch, to obtain a SB/X command|
|#SB/Y|Intermediate signal to latch, to obtain a SB/Y command|
|#S/SB|Intermediate signal to latch, to obtain a S/SB command|
|#S/ADL|Intermediate signal to latch, to obtain a S/ADL command|
|#SB/S|Intermediate signal to latch, to obtain a SB/S command|
|BRK5|Output X22 from decoder. Used to obtain the `STKOP` signal and also goes to the [interrupt circuitry](interrupts.md)|
|RTI/5|Output X26 from decoder. Used to obtain `STKOP` and `NOADL` signals|

The `TXS` (X13) signal is used within this circuit and does not go outside.

The intermediate signals from the register control circuitry go to the input of the control command latches:

![regs_control_commands_tran](/BreakingNESWiki/imgstore/6502/regs_control_commands_tran.jpg)

Register control commands:

|Command|Description|
|---|---|
|X/SB|Place the value of register X on the SB bus|
|Y/SB|Place the value of register Y on the SB bus|
|SB/X|Place the SB bus value on the X register|
|SB/Y|Place the SB bus value on the Y register|
|S/SB|Place the value of register S on the SB bus|
|S/ADL|Place the value of register S on the ADL bus|
|SB/S|Place the SB bus value on the S register|
|S/S|Refresh the value of the S register. The S/S control command is obtained by a complement of the SB/S signal (active when the SB/S command is inactive)|

## Logic

![regs_control_logisim](/BreakingNESWiki/imgstore/6502/regs_control_logisim.jpg)

## Optimized Schematics

![26_regs_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/26_regs_control_logisim.png)

# ALU Control

![6502_locator_alu_control](/BreakingNESWiki/imgstore/6502/6502_locator_alu_control.jpg)

The [ALU](alu.md) control is designed to generate ALU [control commands](context_control.md).

## Intermediate Signals

|/ROR|SR|AND|CSET|
|---|---|---|---|
|![alu_setup_ror_tran](/BreakingNESWiki/imgstore/6502/alu_setup_ror_tran.jpg)|![alu_setup_sr_tran](/BreakingNESWiki/imgstore/6502/alu_setup_sr_tran.jpg)|![alu_setup_and_tran](/BreakingNESWiki/imgstore/6502/alu_setup_and_tran.jpg)|![alu_setup_cset_tran](/BreakingNESWiki/imgstore/6502/alu_setup_cset_tran.jpg)|

Table of auxiliary and intermediate signals, which are found further in the schematics:

|Signal|Description|
|---|---|
|/ROR|Intermediate signal, used in the ADD/SB7 circuit|
|SR|Intermediate signal|
|AND|Intermediate signal|
|T0|Comes from the cycle counter of short instructions|
|T6 RMW|Comes from the cycle counter of long instructions|
|T7 RMW|Comes from the cycle counter of long instructions|
|/C_OUT|[Flag](flags.md) C value (inverted value)|
|CSET|Intermediate signal ("Carry Set"), used in the main ALU control circuit|
|STK2|Decoder X35|
|RET|Decoder X47|
|SBC0|Decoder X51|
|JSR2|Decoder X48|
|/BR3|Decoder X93 (inverted value). The inversion circuit was lost somewhere in the optimization process.|
|BRK6E|Comes from the [interrupts processing](interrupts.md) circuit|
|STKOP|Comes from [register control](regs_control.md) circuitry|
|/ready|Global internal processor readiness signal|
|INC_SB|Intermediate signal ("Increment SB"), used in the main control circuitry as well as in the [bus control](bus_control.md) circuitry|
|JSR/5|Decoder X56|
|PGX|Comes from the bus control circuitry|
|NOADL|Comes from the bus control circuitry|
|BRFW|Comes from the conditional [branch logic](branch_logic.md)|
|T1|Comes from the PC increment circuit (see [dispatcher](dispatch.md))|
|D_OUT|Flag D value|
|C_OUT|Flag C value|

## ALU Сontrol (Main Part)

The circuit is a mess of gates and 4 latches to generate the input carry for the ALU (control signal `/ACIN`).

![alu_setup_main_tran](/BreakingNESWiki/imgstore/6502/alu_setup_main_tran.jpg)

## BCD Correction Control

BCD correction is applied in the following cases:
- If the BCD mode is enabled with flag D and the current instruction `SBC` (control signal DSATemp)
- If the BCD mode is enabled with flag D and the current instruction `ADC` (control signal DAATemp)

![alu_setup_bcd_tran](/BreakingNESWiki/imgstore/6502/alu_setup_bcd_tran.jpg)

## ADD/SB7

The attentive reader will notice that the processor has support for bit rotation instructions (ROL/ROR). The additional processing associated with these instructions is just handled by this circuit.

![alu_setup_addsb7_tran](/BreakingNESWiki/imgstore/6502/alu_setup_addsb7_tran.jpg)

Logic:

![alu_control_addsb7](/BreakingNESWiki/imgstore/6502/alu_control_addsb7.jpg)

Optimized schematics:

![27_alu_control_addsb7](/BreakingNESWiki/imgstore/6502/ttlworks/27_alu_control_addsb7.png)

## ALU Control Commands

![alu_control_commands_tran](/BreakingNESWiki/imgstore/6502/alu_control_commands_tran.jpg)

|Command|Description|
|---|---|
|Setting the ALU input values||
|NDB/ADD|Load inverse value from DB bus to the BI latch|
|DB/ADD|Load direct value from DB bus to the BI latch|
|0/ADD|Write 0 to the AI latch|
|SB/ADD|Load a value from the SB bus to the AI latch|
|ADL/ADD|Load a value from the ADL bus to the BI latch|
|ALU operation commands||
|ANDS|Logical AND operation (AI & BI)|
|EORS|Logical XOR operation (AI ^ BI)|
|ORS|Logical OR operation (AI \| BI)|
|SRS|Shift Right|
|SUMS|Summation (AI + BI)|
|Control commands of the intermediate ALU result||
|ADD/SB06|Place the value of the ADD latch on the SB bus (bits 0-6)|
|ADD/SB7|Place the value of the ADD latch on the SB bus (bit 7)|
|ADD/ADL|Place the ADD latch value on the ADL bus|
|Additional signals||
|/ACIN|Input carry|
|/DAA|Perform correction after addition|
|/DSA|Perform correction after subtraction|

## Logic

![alu_control_logisim](/BreakingNESWiki/imgstore/6502/alu_control_logisim.jpg)

## Optimized Schematics

![28_alu_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/28_alu_control_logisim.png)

# Program Counter Control

![6502_locator_pc_control](/BreakingNESWiki/imgstore/6502/6502_locator_pc_control.jpg)

The program counter (PC) control circuitry is designed to generate [control commands](context_control.md) to exchange the PC value and the internal buses ADL, ADH and DB.

Nearby is the PC increment circuit, which is discussed in another section on [dispatcher](dispatch.md).

Transistor circuit for obtaining intermediate signals:

![pc_control_trans](/BreakingNESWiki/imgstore/6502/pc_control_trans.jpg)

Output latches and control commands:

![pc_control_commands_tran](/BreakingNESWiki/imgstore/6502/pc_control_commands_tran.jpg)

Inputs:

|Signal|Description|
|---|---|
|BR0|Decoder X73. Additionally modified with the /PRDY signal|
|BR2|Decoder X80|
|BR3|Decoder X93|
|T0|Comes from the cycle counter of short instructions|
|T1|Comes from the PC increment circuit (see [dispatcher](dispatcher.md))|
|ABS/2|Decoder X83. Additionally modified with Push/Pull signal (X129)|
|RTS/5|Decoder X84|
|JSR/5|Decoder X56|
|/ready|Global internal processor readiness signal|

Outputs:

|Signal|Description|
|---|---|
|DL/PCH|Auxiliary output signal for DL/ADH [bus control circuitry](bus_control.md)|
|PC/DB|Auxiliary output signal for the RW Control circuit that is part of the dispatcher|

Control commands:

|Command|Description|
|---|---|
|ADH/PCH|Load ADH bus value into the PCHS latch|
|PCH/PCH|If ADH/PCH is not running, this command is executed (refresh PCH)|
|PCH/ADH|Write the PCH register value to the ADH bus|
|PCH/DB|Write the PCH register value to the DB bus|
|ADL/PCL|Load the ADL bus value into the PCLS latch|
|PCL/PCL|If ADL/PCL is not running, this command is executed (refresh PCL)|
|PCL/ADL|Write the PCL register value to the ADL bus|
|PCL/DB|Write the PCL register value to the DB bus|

## Logic

![pc_control_logisim](/BreakingNESWiki/imgstore/6502/pc_control_logisim.jpg)

## Optimized Schematics

![23_pc_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/23_pc_control_logisim.png)

# Bus Control

![6502_locator_bus_control](/BreakingNESWiki/imgstore/6502/6502_locator_bus_control.jpg)

Bus control is most of all "scattered" around the processor surface. It is easiest to describe all the bus [control commands](context_control.md) first, and then to look at the corresponding circuits individually.

Bus control commands:

|Command|Description|
|---|---|
|External address bus control||
|ADH/ABH|Set the high 8 bits of the external address bus, in accordance with the value of the internal bus ADH|
|ADL/ABL|Set the low-order 8 bits of the external address bus, in accordance with the value of the internal bus ADL|
|ALU connection to SB, DB buses||
|AC/DB|Place the AC value on the DB bus|
|SB/AC|Place the value from the SB bus/BCD correction circuit into the accumulator|
|AC/SB|Place the AC value on the SB bus|
|Control of the SB, DB and ADH internal buses||
|SB/DB|Connect the SB and DB buses|
|SB/ADH|Connect SB and ADH buses|
|0/ADH0|Forced to clear the ADH\[0\] bit|
|0/ADH17|Forced to clear the ADH\[1-7\] bits|
|External data bus control||
|DL/ADL|Write the DL value to the ADL bus|
|DL/ADH|Write the DL value to the ADH bus|
|DL/DB|Exchange the value of the DL and the internal bus DB. The direction of the exchange depends on the operating mode of the external data bus (read/write)|

The motive of all the circuits is roughly as follows:
- The control circuits get a lot of input from the decoder and other auxiliary signals
- All circuits are mostly combinatorial (no triggers, just a mess of gates)
- The outputs from the control circuits go to the output latches of the commands to control the lower part of the processor.

## Auxiliary Signals

Circuits for obtaining auxiliary signals:

|NOADL, IND|JSXY|
|---|---|
|![bus_noadl_ind_tran](/BreakingNESWiki/imgstore/6502/bus_noadl_ind_tran.jpg)|![bus_jsxy_tran](/BreakingNESWiki/imgstore/6502/bus_jsxy_tran.jpg)|

In the `IND` circuit the decoder output X90 is additionally modified by the Push/Pull signal (X129).

The other auxiliary and intermediate signals that can be found in the schematics in this section:

|Signal|Description|
|---|---|
|RTS/5|Decoder X84|
|RTI/5|Decoder X26|
|STXY|Comes from [register control circuitry](regs_control.md)|
|BR0|Decoder X73. Additionally modified with the /PRDY signal|
|T6 RMW|Comes from the cycle counter of long instructions|
|T7 RMW|Comes from the cycle counter of long instructions|
|PGX|Output signal from ADL/ABL circuit|
|JSR/5|Decoder X56|
|T2|Decoder X28|
|!PCH/PCH|Comes from the [PC control circuitry](pc_control.md)|
|SBA|The signal comes out of the #SB/ADH circuit, used in the #ADH/ABH circuit|
|/ready|Global internal processor readiness signal|
|BR3|Decoder X93|
|0/ADL0|Comes from the interrupt vector setting circuit|
|AND|Comes from the [ALU control](alu_control.md) circuit|
|STA|Decoder X79|
|STOR|Intermediate signal from the dispatcher|
|#SBXY|Comes from a register control circuit (not to be confused with STXY)|
|T1|Comes from the PC increment circuit (see [dispatcher](dispatch.md))|
|BR2|Decoder X80|
|ZTST|Output signal for [flags control](flags_control.md) from SB/DB circuit|
|ACRL2|One of the ACR Latch outputs|
|T0|Comes from the cycle counter of short instructions|
|ABS/2|Decoder X83. Additionally modified with Push/Pull signal (X129)|
|JMP/4|Decoder X101|
|IMPL|Decoder X128. Additionally modified with Push/Pull (X129) and IR0 signals.|
|JSR2|Decoder X48|
|/JSR|Inversion of JSR2 for the register control circuit|
|BRK6E|Comes from the [interrupts processing](interrupts.md) circuit|
|INC_SB|Comes from the ALU control circuit|
|DL/PCH|Comes from the PC control circuitry|

The signals are arranged in the order they appear in the schematics.

## External Address Bus Control

Circuits for the generation of intermediate signals:

|#ADL/ABL|#ADH/ABH (1)|#ADH/ABH (2)|
|---|---|---|
|![bus_adlabl_tran](/BreakingNESWiki/imgstore/6502/bus_adlabl_tran.jpg)|![bus_adhabh_tran1](/BreakingNESWiki/imgstore/6502/bus_adhabh_tran1.jpg)|![bus_adhabh_tran2](/BreakingNESWiki/imgstore/6502/bus_adhabh_tran2.jpg)|

The first piece of the #ADH/ABH circuit is to the right of flag B, the second piece is in the interrupt address generation circuitry. The #ADH/ABH signal connects directly between these two pieces.

The output latches of the ADL/ABL and ADH/ABH control commands:

![bus_addr_bus_commands_tran](/BreakingNESWiki/imgstore/6502/bus_addr_bus_commands_tran.jpg)

## ALU Connection to SB, DB

Circuits for the generation of intermediate signals:

|#AC/DB|#SB/AC, #AC/SB|
|---|---|
|![bus_acdb_tran](/BreakingNESWiki/imgstore/6502/bus_acdb_tran.jpg)|![bus_acsb_tran](/BreakingNESWiki/imgstore/6502/bus_acsb_tran.jpg)|

AC/DB, SB/AC, AC/SB control command output latches:

![bus_alu_commands_tran](/BreakingNESWiki/imgstore/6502/bus_alu_commands_tran.jpg)

## SB, DB, ADH Control

Circuits for generating intermediate signals (for 0/ADH0 you get the control command at once):

|#SB/DB (also #0/ADH17)|0/ADH0|#SB/ADH|
|---|---|---|
|![bus_control_tran1](/BreakingNESWiki/imgstore/6502/bus_control_tran1.jpg)|![bus_0adh0_tran](/BreakingNESWiki/imgstore/6502/bus_0adh0_tran.jpg)|![bus_sbadh_tran](/BreakingNESWiki/imgstore/6502/bus_sbadh_tran.jpg)|

SB/DB, SB/ADH, 0/ADH17 control command output latches:

![bus_sb_commands_tran](/BreakingNESWiki/imgstore/6502/bus_sb_commands_tran.jpg)

(0/ADH0 above)

## External Data Bus Control

Circuits for the generation of intermediate signals:

|#DL/ADL|#DL/DB (1)|#DL/DB (2)|
|---|---|---|
|![bus_dladl_tran](/BreakingNESWiki/imgstore/6502/bus_dladl_tran.jpg)|![bus_dldb_tran](/BreakingNESWiki/imgstore/6502/bus_dldb_tran.jpg)|![bus_dldb_tran2](/BreakingNESWiki/imgstore/6502/bus_dldb_tran2.jpg)|

The first piece of #DL/DB circuitry is next to the ACR Latch, the second piece is right inside the ALU control circuitry. The #DL/DB signal connects directly between these two pieces.

DL/ADL, DL/ADH, DL/DB control command output latches:

![bus_data_latch_commands_tran](/BreakingNESWiki/imgstore/6502/bus_data_latch_commands_tran.jpg)

## Logic

![bus_control_logisim](/BreakingNESWiki/imgstore/6502/bus_control_logisim.jpg)

## Optimized Schematics

![7_bus_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/7_bus_control_logisim.png)

# Dispatcher

![6502_locator_dispatch](/BreakingNESWiki/imgstore/6502/6502_locator_dispatch.jpg)

The execution logic (dispatcher or sequencer) is the key mechanism of the processor that "directs" the execution of instructions.

![DispatchUnit](/BreakingNESWiki/imgstore/6502/DispatchUnit.png)

The execution logic consists of the following circuits:
- Intermediate signals
- Processor readiness control and R/W Mode
- Short instruction cycle counter (T0-T1)
- Cycle counter for very long instructions (RMW T6-T7)
- Instruction completion circuit
- ACR latch
- Program counter (PC) increment circuit
- Opcode fetch circuit (Fetch)

[Long instruction cycle counter](extra_counter.md) (T2-T5) is discussed in the corresponding section.

:warning: This processor module is very messy and contains many cycles. Signals come in from practically everywhere and also go out to practically every place. The transistor circuits are "spread out" in an even layer in between the rest of the Random Logic.

## Intermediate Signals

Intermediate signals are obtained from the decoder outputs without any regularity. It was very difficult to separate them from the intermediate signals of the other control circuits, because of the chaotic connections.

|BR2|BR3, D91_92|/MemOP|STORE, STOR|/SHIFT|
|---|---|---|---|---|
|![dispatch_br2_tran](/BreakingNESWiki/imgstore/6502/dispatch_br2_tran.jpg)|![dispatch_br3_tran](/BreakingNESWiki/imgstore/6502/dispatch_br3_tran.jpg)|![dispatch_memop_tran](/BreakingNESWiki/imgstore/6502/dispatch_memop_tran.jpg)|![dispatch_store_tran](/BreakingNESWiki/imgstore/6502/dispatch_store_tran.jpg)|![dispatch_shift_tran](/BreakingNESWiki/imgstore/6502/dispatch_shift_tran.jpg)|

## Processor Readiness and R/W Mode

![dispatch_ready_tran](/BreakingNESWiki/imgstore/6502/dispatch_ready_tran.jpg)

![dispatch_rw_tran](/BreakingNESWiki/imgstore/6502/dispatch_rw_tran.jpg)

![DispReadyRW](/BreakingNESWiki/imgstore/6502/DispReadyRW.jpg)

- /ready: global ready signal of the processor, derived from the `RDY` input signal which comes from the corresponding terminal.
- REST: Reset cycle counters
- WR: The processor is in write mode

## Short Cycle Counter

![dispatch_short_cycle_tran](/BreakingNESWiki/imgstore/6502/dispatch_short_cycle_tran.jpg)

![DispShortCycle](/BreakingNESWiki/imgstore/6502/DispShortCycle.jpg)

- T0: Internal signal (processor in T0 cycle)
- /T0, /T1X: Coming to [decoder](decoder.md) input

## Very Long Cycle Counter

![dispatch_long_cycle_tran](/BreakingNESWiki/imgstore/6502/dispatch_long_cycle_tran.jpg)

![DispRMWCycle](/BreakingNESWiki/imgstore/6502/DispRMWCycle.jpg)

- T6, T7: The processor is in the RMW cycle T6/T7

## Instruction Completion

![dispatch_ends_tran](/BreakingNESWiki/imgstore/6502/dispatch_ends_tran.jpg)

- ENDS: Complete the short instructions

![dispatch_endx_tran](/BreakingNESWiki/imgstore/6502/dispatch_endx_tran.jpg)

- ENDX: Complete long instructions

![dispatch_tresx_tran](/BreakingNESWiki/imgstore/6502/dispatch_tresx_tran.jpg)

- #TRESX: Reset Cycle Counters

![dispatch_tres2_tran](/BreakingNESWiki/imgstore/6502/dispatch_tres2_tran.jpg)

- TRES2: Reset [extra instruction counter](extra_counter.md)

![DispCompletionUnit](/BreakingNESWiki/imgstore/6502/DispCompletionUnit.jpg)

## ACR Latch

![dispatch_acr_latch_tran](/BreakingNESWiki/imgstore/6502/dispatch_acr_latch_tran.jpg)

![DispACRLatch](/BreakingNESWiki/imgstore/6502/DispACRLatch.jpg)

Outputs 2 internal intermediate signals: ACRL1 and ACRL2.

## Increment PC

![dispatch_pc_tran](/BreakingNESWiki/imgstore/6502/dispatch_pc_tran.jpg)

![DispIncrementPC](/BreakingNESWiki/imgstore/6502/DispIncrementPC.jpg)

The circuit contains 3 "branches" of combinatorial logic, which finally form the [control command](context_control.md) to increment PC (`#1/PC`).

There is also a circuit nearby to generate the following signals:
- T1: Processor in cycle T1
- TRES1: Reset short instruction cycle counter

## Opcode Fetch

![dispatch_fetch_tran](/BreakingNESWiki/imgstore/6502/dispatch_fetch_tran.jpg)

![DispFetch](/BreakingNESWiki/imgstore/6502/DispFetch.jpg)

- FETCH: Fetch opcode to [instruction register](ir.md)
- 0/IR: Inject `BRK` operation code, for [interrupt handling](interrupts.md)

## Logic (old all-in-one version)

![dispatcher_logisim](/BreakingNESWiki/imgstore/6502/dispatcher_logisim.jpg)

## Optimized Schematics

![13_dispatcher_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/13_dispatcher_logisim.png)

# Flags Control

![6502_locator_flags_control](/BreakingNESWiki/imgstore/6502/6502_locator_flags_control.jpg)

The flag control circuits are divided into two parts for convenience:
- Intermediate control signals from the decoder (opcode selection)
- Flag control signals

As you can guess, the purpose of the circuit is to control [processor flags](flags.md), depending on the currently executed instruction.

I think it makes sense to show here the relevant part of the wonderful 6502 circuit made by Donald F. Hanson:

![flags_control_hanson](/BreakingNESWiki/imgstore/6502/flags_control_hanson.jpg)

(The missing `0/V` signal has been corrected in the schematic)

## Opcode Selection

|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran1.jpg)|![flags_control_tran2](/BreakingNESWiki/imgstore/6502/flags_control_tran2.jpg)|![flags_control_tran3](/BreakingNESWiki/imgstore/6502/flags_control_tran3.jpg)|
|---|---|---|

Input signals:

- /T0: Processor executes cycle T0 of the current instruction
- /T1X: Processor executes T1 cycle of the current instruction
- T7 RMW: Processor executes T7 cycle of current instruction (RMW)

Output signals:

|Signal|Decoder outputs|Dedicated instructions|
|---|---|---|
|!POUT|98,99|Working with flags outward (saving context after interrupt, `PHP` instruction)|
|/CSI|108|Instructions `CLI`, `SEI`|
|BIT1|109|Instruction `BIT`, cycle T1|
|X110|110|The 110th decoder output (instructions `CLC`, `SEC`), for convenience is left in these circuits. It just goes on to the main flag control circuitry.|
|AVR/V|112|Instructions `ADC`, `SBC`. This signal is the control signal for [flag V](flags.md)|
|/ARIT|107,112,116-119|Matrix of comparison (`CMP`, `CPX`, `CPY`) and shift instructions (`ASL`, `ROL`) where flags are used|
|BIT0|113|Instruction `BIT`, cycle T0|
|!PIN|114,115|Working with flags inside (context loading after `RTI`, instruction `PLP`)|
|/CSD|120|Instructions `CLD`, `SED`|
|CLV|127|Instruction `CLV`|

All of these control signals (except `AVR/V`) are intermediate signals and are not used anywhere else except for the flag control circuitry.

## Flags Control

|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran4.jpg)|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran5.jpg)|
|---|---|

Input signals:

|Signal|Purpose|
|---|---|
|/CSI|see above|
|X110|see above|
|!POUT|see above|
|BIT1|see above|
|ZTST|Comes from SB/DB [bus control circuitry](bus_control.md)|
|/ARIT|see above|
|SR|Shift instruction from [ALU control logic](alu_control.md)|
|/ready|Global internal processor readiness signal|
|!PIN|see above|
|BIT0|see above|
|/CSD|see above|
|CLV|see above|

Output [Flag](flags.md) control signals:

|Signal|Flag|Purpose|
|---|---|---|
|IR5/C|C|Change the value of the flag according to the IR5 bit|
|ACR/C|C|Change the value of the flag according to the ACR value|
|DB/C|C|Change the value of the flag according to DB0 bit|
|DBZ/Z|Z|Change the value of the flag according to the /DBZ value|
|IR5/I|I|Change the value of the flag according to the IR5 bit|
|IR5/D|D|Change the value of the flag according to the IR5 bit|
|DB/V|V|Change the value of the flag according to DB6 bit|
|0/V|V|Clear flag V|
|DB/N|N|Change the value of the flag according to DB7 bit|
|P/DB|All|Place the value of the flags register P on the DB bus|
|DB/P|All|Place the DB bus value on the flag register P|

The control signal `1/V` is obtained by the input contact `SO` and is not shown here.

## Logic

![flags_control_logisim](/BreakingNESWiki/imgstore/6502/flags_control_logisim.jpg)

## Optimized Schematics

![16_flags_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/16_flags_control_logisim.png)

# Flags

![6502_locator_flags](/BreakingNESWiki/imgstore/6502/6502_locator_flags.jpg)

The flags (bits of the P register) are in "scattered" form, as several circuits of the upper part of the processor.

The flags are controlled by the [flags control](flags_control.md) circuit.

Flag B is treated separately in the section on [interrupt handling](interrupts.md). Topologically it is also located in another part of the processor.

## C Flag

![flag_c_tran](/BreakingNESWiki/imgstore/6502/flag_c_tran.jpg)

- IR5/C: Change the flag value according to the IR5 bit (applies during execution of the `SEC` and `CLC` instructions)
- ACR/C: Change the flag value according to the ACR value
- DB/C: Change the value of the flag according to the bit DB0
- /IR5: Inverted IR5 value
- /DB0: Input value from DB bus, in inverted form
- ACR: Result of a carry from the ALU
- /ACR: The result of the carry from the ALU, in inverted form. Also used in [dispatcher](dispatch.md)
- /C_OUT: Output value of flag C, in inverted form

## D Flag

![flag_d_tran](/BreakingNESWiki/imgstore/6502/flag_d_tran.jpg)

- IR5/D: Change the flag value according to the IR5 bit (applied during execution of `SED` and `CLD` instructions)
- DB/P: Common control signal, place the DB bus value on the flag register P
- /IR5: IR5 bit value, in inverted form
- /DB3: Input value from the DB bus, in inverted form
- /D_OUT: Output value of flag D, in inverted form

## I Flag

![flag_i_tran](/BreakingNESWiki/imgstore/6502/flag_i_tran.jpg)

- IR5/I: Change the flag value according to the IR5 bit (applied during execution of `SEI` and `CLI` instructions)
- DB/P: Common control signal, place the DB bus value on the flag register P
- /IR5: IR5 bit value, in inverted form
- /DB2: Input value from the DB bus, in inverted form
- /I_OUT: Output value of flag I, in inverted form. This signal goes to two places: to the interrupt processing circuit and to the circuit for exchanging flag register values with the DB bus (below).

The `/I_OUT` signal is further modified by the `BRK6E` signal in flag B circuitry:

![intr_b_flag_tran](/BreakingNESWiki/imgstore/6502/intr_b_flag_tran.jpg)

## N Flag

![flag_n_tran](/BreakingNESWiki/imgstore/6502/flag_n_tran.jpg)

- DB/N: Change the flag value according to DB7
- /DB7: Input value from DB bus, in inverted form
- /N_OUT: Output value of flag N, in inverted form

## V Flag

![flag_v_tran](/BreakingNESWiki/imgstore/6502/flag_v_tran.jpg)

- 0/V: Clear flag V (applies during execution of `CLV` instructions)
- 1/V: Set flag V. Forced flag setting is done by the `SO` pin.
- AVR/V: Change the value of the flag according to the AVR value
- DB/V: Change the flag value according to DB6
- AVR: Overflow result from the ALU
- SO: Input value from pin `SO`
- /DB6: Input value from DB bus, in inverted form
- /V_OUT: Output value of flag V, in inverted form

## Z Flag

![flag_z_tran](/BreakingNESWiki/imgstore/6502/flag_z_tran.jpg)

- DBZ/Z: Change the flag value according to the /DBZ value
- DB/P: Common control signal, place the DB bus value on the flag P register
- /DBZ: Control signal from the flag exchange circuit with the DB bus (check that all bits of the DB bus are 0)
- /DB1: Input value from the DB bus, in inverted form
- /Z_OUT: Output value of flag Z, in inverted form

## Flags I/O

![flags_io_tran](/BreakingNESWiki/imgstore/6502/flags_io_tran.jpg)

- C_OUT: Flag C value in direct form, used in [ALU control circuit](alu_control.md) (in the circuit to form the `ADD/SB7` signal)
- D_OUT: Flag D value in direct form, used in the ALU control circuit (to form BCD correction signals DAA/DSA)
- P/DB: Place the P flag register value on the DB bus
- /DB0-7: The value of the DB bus bits, in inverted form. It is fed to the input of the corresponding bits of the P register.
- /DBZ: Check that all DB bus bits are 0 (i.e. checking the value to 0). It is used by the Z flag.

Correspondence of the bits of the DB bus and the flag register P:

|DB Bit|Flag|
|---|---|
|0|C|
|1|Z|
|2|I|
|3|D|
|4|B|
|5|-|
|6|V|
|7|N|

"Crazy Zebra I Dont Bother Very Nice"

Flag 5 is not used. The DB5 bit is not changed (not connected) when saving the register P to the DB bus. However, the value of the DB5 bit is checked by the `/DBZ` control signal (to compare the value on the DB bus with zero).

## Logic

![flags_logisim](/BreakingNESWiki/imgstore/6502/flags_logisim.jpg)

## Optimized Schematics

![15_flags_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/15_flags_logisim.png)

# Branch Logic

![6502_locator_branch](/BreakingNESWiki/imgstore/6502/6502_locator_branch.jpg)

The logic of conditional branches determines:
- Whether the branch went forward or backward
- Whether a branch occurred at all

The branch direction is determined by the 7th bit of the branch instruction operand (relative offset) which is stored on the internal data bus (DB). If the 7th bit is 1, it means that branch is made "backwards" (PC = PC - offset).

The branch is checked according to the branch instruction (which differs by 6 and 7 bit of the operation code) as well as the flags: C, V, N, Z.

## Branch Forward

![branch_forward_tran](/BreakingNESWiki/imgstore/6502/branch_forward_tran.jpg)

The BRFW trigger is updated with the value D7 during BR3.PHI1. The rest of the time the trigger stores its current value. The value of the trigger is output as a `BRFW` control signal to the [Program Counter (PC) control circuit](pc_control.md).

The `BR2` is the X80 output of the decoder.

## Branch Taken

![branch_taken_tran](/BreakingNESWiki/imgstore/6502/branch_taken_tran.jpg)

The combinatorial logic first selects by IR6/IR7 which group the branch instruction belongs to (i.e. which flag it checks) and the subsequent XOR selects how the branch instruction is triggered (flag set/reset). 
The output of `/BRTAKEN` is in inverse logic, that is, if branch is triggered, then /BRTAKEN = 0. The consumer of the /BRTAKEN signal is also the PC control circuit.

Inputs `/IR6` and `/IR7` are decoder outputs X121 and X126 respectively. The `/IR5` input comes directly from the [instruction register](ir.md).

Note: The Branch Taken logic operates continuously and the value of the /BRTAKEN control line is updated every cycle, regardless of which instruction is being processed by the processor at the time.

## Logic

![branch_logic_logisim](/BreakingNESWiki/imgstore/6502/branch_logic_logisim.jpg)

## Optimized Schematics

![6_branch_logic_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/6_branch_logic_logisim.png)

# Control Commands

![6502_locator_controls](/BreakingNESWiki/imgstore/6502/6502_locator_controls.jpg)

"Control Commands" is the conventional name for the large number of control signals that go from the top of the processor to the bottom and control the context (registers, buses) and ALU.

![6502_controls_tran1](/BreakingNESWiki/imgstore/6502/6502_controls_tran1.jpg)

![6502_controls_tran2](/BreakingNESWiki/imgstore/6502/6502_controls_tran2.jpg)

![6502_controls_tran3](/BreakingNESWiki/imgstore/6502/6502_controls_tran3.jpg)

![6502_controls_tran4](/BreakingNESWiki/imgstore/6502/6502_controls_tran4.jpg)

The control commands for the flag register are discussed in the corresponding section on [flag management](flags_control.md), since they do not go beyond the top of the processor.

Each control signal usually contains an output latch and sometimes a special "cutoff" transistor that turns the signal off at a certain half-cycle (usually some of the signals are turned off during PHI2). This is because the internal buses are pre-charged during PHI2, and the registers are usually "refreshed" at that time.

Most signals have names like `A/B` which means that the line "connects" `A` to `B`. For example SB/X means that the value from the internal bus SB is placed in register X.

## List

All commands are discussed in more detail in their respective sections. The summary table is just for reference.

|Name|PHI1|PHI2|Description|
|---|---|---|---|
|Register control commands||||
|Y/SB|√| |Y => SB|
|SB/Y|√| |SB => Y|
|X/SB|√| |X => SB|
|SB/X|√| |SB => X|
|S/ADL|√|√|S => ADL|
|S/SB|√|√|S => SB|
|SB/S|√| |SB => S|
|S/S|√| |The S/S command is active if the SB/S command is inactive. This command simply "refreshes" the current state of the S register.|
|ALU control commands||||
|NDB/ADD|√| |~DB => BI|
|DB/ADD|√| |DB => BI|
|0/ADD|√| |0 => AI|
|SB/ADD|√| |SB => AI|
|ADL/ADD|√| |ADL => BI|
|/ACIN|√|√|ALU input carry. The ALU also returns the result of carry (`ACR`) and overflow (`AVR`)|
|ANDS|√|√|AI & BI|
|EORS|√|√|AI ^ BI|
|ORS|√|√|AI \| BI|
|SRS|√|√|>>= 1|
|SUMS|√|√|AI + BI|
|/DAA|√|√|0: Perform BCD correction after addition|
|/DSA|√|√|0: Perform BCD correction after subtraction|
|ADD/SB7|√|√|ADD\[7\] => SB\[7\]|
|ADD/SB06|√|√|ADD\[0-6\] => SB\[0-6\]|
|ADD/ADL|√|√|ADD => ADL|
|SB/AC|√| |SB => AC|
|AC/SB|√| |AC => SB|
|AC/DB|√| |AC => DB|
|Program counter (PC) control commands||||
|#1/PC|√|√|0: Increment the program counter|
|ADH/PCH|√| |ADH => PCH|
|PCH/PCH|√| |If ADH/PCH is not performed, this command is performed (refresh PCH)|
|PCH/ADH|√|√|PCH => ADH|
|PCH/DB|√|√|PCH => DB|
|ADL/PCL|√| |ADL => PCL|
|PCL/PCL|√| |If ADL/PCL is not performed, this command is performed (refresh PCL)|
|PCL/ADL|√|√|PCL => ADL|
|PCL/DB|√|√|PCL => DB|
|Bus control commands||||
|ADH/ABH|√|√|ADH => ABH|
|ADL/ABL|√|√|ADL => ABL|
|0/ADL0, 0/ADL1, 0/ADL2|√|√|Reset some of the ADL bus bits. Used to set the interrupt vector.|
|0/ADH0, 0/ADH17|√|√|Reset some of the ADH bus bits|
|SB/DB|√|√|SB <=> DB, connect the buses|
|SB/ADH|√|√|SB <=> ADH, connect the buses|
|DL latch control commands||||
|DL/ADL|√|√|DL => ADL|
|DL/ADH|√|√|DL => ADH|
|DL/DB|√|√|DL <=> DB|

## ADD/SB7

Be careful, all output values are inverse latch values, except for `ADD/SB7`.

## "Other" PHI2 (/PHI1)

On the left side is a small circuit to pull up PHI2 (which is used by a lot of cutoff transistors, so it must be quite powerful):

![phi2_pullup_tran](/BreakingNESWiki/imgstore/6502/phi2_pullup_tran.jpg)

Optimized logic diagram with explanations:

![9_context_control_gating](/BreakingNESWiki/imgstore/6502/ttlworks/9_context_control_gating.png)

## Command Priority

Although in a real processor all commands are "executed" at the same time, it is still possible to outline some priority that the developers have laid down.

The commands on the bottom of the 6502, in order of execution:

PHI1 "Set Address and R/W Mode":

- Loading on the bus from DL: DL_DB, DL_ADL, DL_ADH
- Registers to the SB bus: Y_SB, X_SB, S_SB
- Saving flags on the DB bus: P_DB
- ADD saving on SB/ADL: ADD_SB7, ADD_SB06, ADD_ADL
- Saving AC: AC_SB, AC_DB
- Saving of old stack pointer value to ADL bus: S_ADL
- Increment PC: n_1PC
- Saving PC to bus: PCL_ADL, PCH_ADH, PCL_DB, PCH_DB
- Bus multiplexing: SB_DB, SB_ADH
- Constant generator: Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17
- Loading ALU operands: NDB_ADD, DB_ADD, Z_ADD, SB_ADD, ADL_ADD
- BCD correction via SB bus: SB_AC
- Loading flags: DB_P, DBZ_Z, DB_N, IR5_C, DB_C, IR5_D, IR5_I, DB_V, Z_V, ACR_C, AVR_V
- Loading registers: SB_X, SB_Y, SB_S / S_S
- Load PC from bus or keep old value: ADH_PCH/PCH_PCH, ADL_PCL/PCL_PCL
- Saving DB to DOR
- Set external bus address: ADH_ABH, ADL_ABL

PHI2 "Read/Write Data":

- Loading the DL with a value from the external data bus
- Registers on SB bus: S_SB
- Saving flags to the DB bus: P_DB
- ALU operation: ANDS, EORS, ORS, SRS, SUMS, n_ACIN, n_DAA, n_DSA
- ADD saving on SB/ADL: ADD_SB7, ADD_SB06, ADD_ADL
- Saving old stack pointer value to ADL bus: S_ADL
- Increment PC: n_1PC (PC is incremented in this half-cycle)
- Saving PC to bus: PCL_ADL, PCH_ADH, PCL_DB, PCH_DB
- Bus multiplexing: SB_DB, SB_ADH
- Constant generator: Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17
- Loading flags: DB_P, DBZ_Z, DB_N, IR5_C, DB_C, IR5_D, IR5_I, DB_V, Z_V, ACR_C, AVR_V
- Setting external data bus from DOR: If WR = 1

# Address Bus

![6502_locator_addr](/BreakingNESWiki/imgstore/6502/6502_locator_addr.jpg)

Although the 6502 communicates with the outside world on a 16-bit address bus, but because the processor is 8-bit in nature, the address bus is internally divided into two 8-bit halves: an upper (ADH) and a lower (ADL).

The internal ADH/ADL address bus connects to the external 16-bit bus (pins A0-A15) through registers ABH/ABL, which contain the last written value (address that has been set).

The address bus is unidirectional. It can only be controlled by the 6502.

Transistor circuit of the lower bits of the ABL (0-2):

![abl02_tran](/BreakingNESWiki/imgstore/6502/abl02_tran.jpg)

(The schematic is the same for ABL1 and ABL2 bits)

The remaining ABL bits (3-7):

![abl37_tran](/BreakingNESWiki/imgstore/6502/abl37_tran.jpg)

ABH bits:

![abh_tran](/BreakingNESWiki/imgstore/6502/abh_tran.jpg)

Control commands:

- 0/ADL0, 0/ADL1, 0/ADL2: The lower 3 bits of the ADL bus can be forced to zero by commands when setting [interrupts vector](interrupts.md)
- ADL/ABL: Place the value of the internal ADL bus on the ABL register
- ADH/ABH: Place the ADH internal bus value on the ABH register

:warning: As time passed, it turned out that FET where 0/ADL0, 0/ADL1, 0/ADL2 commands are used is more convenient to make a part of [Bus Multiplexer](busmux.md) circuit.

## Circuit Flow

Consider the behavior of the circuit when ADL = 0:

![abl_flow_tran](/BreakingNESWiki/imgstore/6502/abl_flow_tran.jpg)

- The flip/flop of the ABL bit is organized on two inverters (not2 and not3) with not2 acting simultaneously as a DLatch (whose input Enable is connected to PHI2)
- PHI2: FF is "refreshed" in this half-step.
- PHI1: In this half-step the old FF value is "cut off" by the PHI2 tristate (located to the left of not2) and the new FF value is loaded from the ADL bus (inverted, see not1) but only if an ADL/ABL command is active
- The output from not2 organizes the final generation of the output value for the external address bus. This part of the circuit contains an inverter not3 to form the FF and also an inverter not4 which controls the amplifier "comb" of the Ax contacts

## Logic

On the logic circuits PHI2 is not used, and FF organized on two inverters is replaced by a regular trigger.

![abl02_logisim](/BreakingNESWiki/imgstore/6502/abl02_logisim.jpg)

![abl_logisim](/BreakingNESWiki/imgstore/6502/abl_logisim.jpg)

![abh_logisim](/BreakingNESWiki/imgstore/6502/abh_logisim.jpg)

## Optimized Schematics

![0_abl02_tran](/BreakingNESWiki/imgstore/6502/ttlworks/0_abl02_tran.png)

# Data Bus

![6502_locator_data](/BreakingNESWiki/imgstore/6502/6502_locator_data.jpg)

The circuits for working with the external data bus consist of 8 identical pieces:

![6502_data_bit_tran](/BreakingNESWiki/imgstore/6502/data_bit_tran.jpg)

(The circuit is shown for bit 0, the rest are the same)

- DOR: The DOR latch stores the output value to be placed on the D0-D7 bus pins. If RD=1 the complementary output lines with DOR are cut off, so the whole output part becomes floating.
- DL: The DL latch stores the input value
- Next to the control signal `DL/DB` you can see the precharge transistor for the internal bus DB (see also [Bus Multiplexer](busmux.md))

Control signals:
- DL/ADL: Place the DL latch value on the internal ADL bus
- DL/ADH: Place the DL latch value on the internal ADH bus
- DL/DB: In read mode (RD=1), the value from the DL latch is placed on the internal DB bus. In write mode (RD=0) the value from the DB bus is placed on the DOR latch

The external data bus (pins D0-D7) is also directly connected to the input of the [predecode circuit](predecode.md).

Optimized schematics:

![11_6502_data_bit_tran](/BreakingNESWiki/imgstore/6502/ttlworks/11_6502_data_bit_tran.png)

## WR Latch

From the R/W control circuit, the latch circuit receives a control signal `WR`. The circuit outputs a control signal `RD` which controls the direction of the external data bus.

![6502_wr_latch_tran](/BreakingNESWiki/imgstore/6502/wr_latch_tran.jpg)

Optimized schematics:

![12_6502_wr_latch_tran](/BreakingNESWiki/imgstore/6502/ttlworks/12_6502_wr_latch_tran.png)

# Registers

![6502_locator_regs](/BreakingNESWiki/imgstore/6502/6502_locator_regs.jpg)

The X and Y registers are used for index addressing. Register S is a stack pointer and the stack is located at addresses 0x100 ... 0x1FF (on the first page).

Schematically the X, Y and S registers consist of 8 identical chunks (bits):

![regs_tran](/BreakingNESWiki/imgstore/6502/regs_tran.jpg)

(In the schematic above, replace SB0 and ADL0 with SBx and ADLx for the remaining register bits)

Each register bit is based on a trigger, loading and unloading of values on the buses is done by [control signals](context_control.md):
- Y/SB: Place the value of the register Y on the SB bus
- SB/Y: Load the Y register value from the SB bus
- X/SB: Place the value of the register X on the SB bus
- SB/X: Load the X register value from the SB bus
- S/ADL: Place the old S register value on the ADL bus
- S/SB: Place the old S register value on the SB bus
- SB/S: Load the new S register value from the SB bus
- S/S: Refresh S register, active when SB/S = 0

So the registers can only connect to two buses: SB and ADL.

:warning: Pay special attention to the design of the S register. It has an input latch (to load a new value) and an output latch (to save the old value). Loading the new value (SB/S) and saving the old value (S/ADL) can happen simultaneously.

## Logic

![regs_logic](/BreakingNESWiki/imgstore/6502/regs_logic.jpg)

- During PHI1 the X and Y registers output their value to the SB bus / are overloaded with new values from the SB bus.
- The S register has an input latch and an output latch. During PHI1 the value from the output latch is placed on the SB or ADL buses and the input latch is either loaded with a new value from the SB bus or refreshed from the output latch (S/S).
- During PHI2 the X and Y registers "store" their old value as the control signals disconnect them from the bus.
- The S register simply outputs its value to the SB or ADL bus during PHI2. The input latch is blocked because the exchange commands are disabled during PHI2.

The SB and ADL buses are precharged during PHI2. This is done because it takes longer to "charge" the bus than to "discharge" it. Therefore, when the bus is not needed - it is precharged, so that it does not have "floating" values.
If the value placed on the bus is 1, then the bus is already prepared ("charged") in advance. If the value placed on the bus is 0, then the bus is "discharged" to ground.

In modern processors the task of precharging the bus is done by dedicated standard cells called Bus Keeper.

In the transistor schematic above you can only see the transistors to charge the SB bus (located in the circuit for the S register bits). The transistors to precharge the ADL bus are scattered next to the program counter (PC).

## Optimized Schematics

![25_regs_logic](/BreakingNESWiki/imgstore/6502/ttlworks/25_regs_logic.png)

# ALU

![6502_locator_alu](/BreakingNESWiki/imgstore/6502/6502_locator_alu.jpg)

It is not possible to show the whole ALU circuit, so let's saw it into its component parts and consider each one separately.

![alu_preview](/BreakingNESWiki/imgstore/6502/alu_preview.jpg)

The ALU consists of the following components:
- Input circuits for AI/BI latch loading
- The main computational part (Operations)
- A fast carry calculation circuit for the BCD 
- Intermediate result (ADD latch)
- BCD correction circuit
- Accumulator (AC)

Generally speaking the ALU is a mess of transistors and wires, but its workings are not very complicated, as you can see later.

Overview of the ALU connections:

![alu_logisim](/BreakingNESWiki/imgstore/6502/alu_logisim.jpg)

## AI/BI Latches

The input circuits consist of 8 identical chunks, which are designed to load input values on the AI and BI latches:

![alu_input_tran](/BreakingNESWiki/imgstore/6502/alu_input_tran.jpg)

(The picture shows the circuit for bit 0, the rest are the same)

Control signals:
- DB/ADD: Load direct value from DB bus to the BI latch
- NDB/ADD: Load inverse value from DB bus to the BI latch
- ADL/ADD: Load a value from the ADL bus to the BI latch
- SB/ADD: Load a value from the SB bus to the AI latch
- 0/ADD: Write 0 to the AI latch

## Computational Part

The ALU uses an inverted carry chain, so the even and odd bit circuits alternate.

Bit 0 is slightly different from the other even bits because it has an input carry (`/ACIN`) and no `SRS` input.

Schematic for bit 0:

![alu_bit0_tran](/BreakingNESWiki/imgstore/6502/alu_bit0_tran.jpg)

Schematics for bits 2, 4, 6:

![alu_bit_even_tran](/BreakingNESWiki/imgstore/6502/alu_bit_even_tran.jpg)

(The circuit for bit 2 is shown, the rest are the same)

Schematics for bits 1, 3, 5, 7:

![alu_bit_odd_tran](/BreakingNESWiki/imgstore/6502/alu_bit_odd_tran.jpg)

(The circuit for bit 1 is shown, the rest are the same)

Optimized schematics:

|Even|Odd|
|---|---|
|![1_alu_even_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/1_alu_even_bit_logisim.png)|![2_alu_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/2_alu_odd_bit_logisim.png)|

Anatomically, the left side deals with logical operations, the right side is the adder (Full Adder), and in the middle is the carry chain.

Control signals for ALU operations:
- ORS: Logical OR operation (AI | BI)
- ANDS: Logical AND operation (AI & BI)
- EORS: Logical XOR operation (AI ^ BI)
- SRS: Shift Right. For this the result of the current `nand` operation is stored as the result of the previous bit.  
- SUMS: Summation (AI + BI)

Notations on the schematics:
- nand: intermediate result of NAND operation for the selected bit
- and: intermediate result of AND operation for the selected bit (obtained by `nand` inversion)
- nor: intermediate result of NOR operation for a selected bit
- xor: intermediate result of EOR operation for the selected bit
- nxor: intermediate result of an ENOR operation for the selected bit
- carry: the result of a carry operation. The carry chain is inverted every bit, but for simplicity all `carry` names do not consider value inversion.
- res: the result of a logical operation or the result of an adder which is then stored on the ADD latch. The result of an operation in inverted form.

To make it clearer how the intermediate results are obtained, all the main motifs are marked in the image below:

![alu_bit_annotated_tran](/BreakingNESWiki/imgstore/6502/alu_bit_annotated_tran.jpg)

(Bit 1 is shown, for the other bits the motif looks similar)

Logic for even bits:

![alu_even_bit_logisim](/BreakingNESWiki/imgstore/6502/alu_even_bit_logisim.jpg)

Logic for odd bits:

![alu_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/alu_odd_bit_logisim.jpg)

Overflow calculation (control signal `AVR`):

![alu_avr_tran](/BreakingNESWiki/imgstore/6502/alu_avr_tran.jpg)

![5_carry_plus_overflow_evaluation](/BreakingNESWiki/imgstore/6502/ttlworks/5_carry_plus_overflow_evaluation.png)

## Fast BCD Carry

This is the circuit that appears in patent US 3991307 (https://patents.google.com/patent/US3991307A).

![alu_bcd_carry_tran1](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_tran1.jpg)

![alu_bcd_carry_tran2](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_tran2.jpg)

The schematics are "layered on the side" for easy perception.

`DC3` output is connected to the carry chain as follows:

![alu_carry3_tran](/BreakingNESWiki/imgstore/6502/alu_carry3_tran.jpg)

How exactly this circuit works is written in the patent, I have nothing much to add. Just a mishmash of logic gates - do the same and it will work.

Besides calculating the carry for BCD the circuit also generates the `ACR` (ALU carry for flags) and `DAAH` control signals for the BCD correction circuit.

Logic:

![alu_bcd_carry_logisim](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_logisim.jpg)

Optimized schematics:

![3_alu_bcd_carry_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/3_alu_bcd_carry_logisim.png)

## Intermediate Result (ADD)

The intermediate result is stored on the ADD latch (stored in inverted form, output to the buses in direct form). The ADD latch circuit consists of 8 identical pieces:

![alu_add_tran](/BreakingNESWiki/imgstore/6502/alu_add_tran.jpg)

(The circuit is shown for bit 0, the others are the same)

- ADD/SB06: Place the value of the ADD latch on the SB bus. The control signal `ADD/SB7` is used instead of ADD/SB06 for bit 7.
- ADD/ADL: Place the ADD latch value on the ADL bus

## BCD Correction

The BCD correction circuit is controlled by two signals: `/DAA` (perform correction after addition) and `/DSA` (perform correction after subtraction).

The outputs of the circuit are connected to the accumulator inputs (AC) and the circuit takes into account the ALU operation when the BCD mode is disabled.

Some of the accumulator inputs are connected directly to the SB bus and do not participate in BCD correction (bits 0 and 4).

The circuit uses 4 auxiliary internal signals in its operation: DAAL, DAAH, DSAL and DSAH. The "L" in the name stands for the lower part of the bits (0-3), the "H" stands for the higher part of the bits (4-7).

Circuits for obtaining auxiliary signals:

|DAAL|DSAL|DSAH|
|---|---|---|
|![alu_daal_tran](/BreakingNESWiki/imgstore/6502/alu_daal_tran.jpg)|![alu_dsal_tran](/BreakingNESWiki/imgstore/6502/alu_dsal_tran.jpg)|![alu_dsah_tran](/BreakingNESWiki/imgstore/6502/alu_dsah_tran.jpg)|

The `DAAH` circuit is in the carry circuit.

The correction circuits use a common motif:
- The input combinatorial circuits, in various combinations accounting for the 4 auxiliary signals and the bits of the intermediate result (ADD latches)
- Output xor, one of the inputs of which is a bit of the bus SB, and the second of the above combinatorial circuits

Sawed schematics:

|Bit 1|Bit 2|Bit 3|Bit 5|Bit 6|Bit 7|
|---|---|---|---|---|---|
|![alu_bcd1_tran](/BreakingNESWiki/imgstore/6502/alu_bcd1_tran.jpg)|![alu_bcd2_tran](/BreakingNESWiki/imgstore/6502/alu_bcd2_tran.jpg)|![alu_bcd3_tran](/BreakingNESWiki/imgstore/6502/alu_bcd3_tran.jpg)|![alu_bcd5_tran](/BreakingNESWiki/imgstore/6502/alu_bcd5_tran.jpg)|![alu_bcd6_tran](/BreakingNESWiki/imgstore/6502/alu_bcd6_tran.jpg)|![alu_bcd7_tran](/BreakingNESWiki/imgstore/6502/alu_bcd7_tran.jpg)|

The auxiliary signals /ADDx on the BCD correction circuits are derived from the values of the ADD latch bits as follows:

![alu_add_temp_tran](/BreakingNESWiki/imgstore/6502/alu_add_temp_tran.jpg)

(Using `/ADD5` as an example)

Logic:

![alu_bcd_logisim](/BreakingNESWiki/imgstore/6502/alu_bcd_logisim.jpg)

Optimized schematics:

![4_alu_bcd_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/4_alu_bcd_logisim.png)

## Accumulator (AC)

The accumulator consists of eight identical pieces:

![alu_ac_tran](/BreakingNESWiki/imgstore/6502/alu_ac_tran.jpg)

(The circuit for bit 3 is shown, the others are the same)

The accumulator inputs a value from the BCD correction circuit (bits 1-3, 5-7) or directly from the SB bus (bits 0 and 4).

In addition to directly outputting the accumulator to the SB and DB buses, other bus operations are also performed at this point, so they are also discussed in this section.

- SB/AC: Place the value from the SB bus/BCD correction circuit into the accumulator
- AC/SB: Place the AC value on the SB bus
- AC/DB: Place the AC value on the DB bus
- SB/DB: Connect the SB bus to DB bus
- SB/ADH: Connect the SB bus to ADH bus
- 0/ADH17: Forced write 0 to ADH bits 1-7. The control signal `0/ADH0` is used for bit 0 instead of 0/ADH17.

:warning: As time passed, it turned out that FET where SB/DB, SB/ADH, 0/ADH0, 0/ADH17 commands are used is more convenient to make a part of [Bus Multiplexer](busmux.md) circuit.

# Program Counter (PC)

![6502_locator_pc](/BreakingNESWiki/imgstore/6502/6502_locator_pc.jpg)

Because of the 8-bit nature of the processor its instruction counter is divided into two 8-bit halves: PCL (Program Counter Low) and PCH (Program Counter High).

The PCH is also divided into two halves: the low part of the bits (0-3) and the high part (4-7).

## PCL

Represents the low 8 least significant bits of PC.

|PCL 0-3|PCL 4-7|
|---|---|
|![pcl03_tran](/BreakingNESWiki/imgstore/6502/pcl03_tran.jpg)|![pcl47_tran](/BreakingNESWiki/imgstore/6502/pcl47_tran.jpg)|

- The circuits alternate for even and odd bits because an optimization known as an inverted carry chain is used
- The control signal `#1/PC` (0: perform PC increment) comes to the PCL0 bit
- PCLC (PCL Carry): Carry from the lowest 8 bits (PC\[0-7\]) to the highest (PC\[8-15\])
- PCL connects to two buses: ADL and DB
- PCL/PCL is used when PCL is not connected to any bus (to maintain the current state)
- Each bit contains two latches (input latch `PCLSx` and output latch `PCLx`) which implement the counter logic

## PCH

Represents the top 8 most significant bits of PC.

:warning: 
The circuits for the even bits (0, 2, ...) of the PCH repeat the circuits for the odd bits (1, 3, ...) of the PCL.
Similarly, circuits for odd bits (1, 3, ...) of PCH repeat circuits for even bits (0, 2, ...) of PCL.

|PCH 0-3|PCH 4-7|
|---|---|
|![pch03_tran](/BreakingNESWiki/imgstore/6502/pch03_tran.jpg)|![pch47_tran](/BreakingNESWiki/imgstore/6502/pch47_tran.jpg)|

The circuit marked as "patch" to form the `PCHC` is actually between the `ADL/PCL` and `#1/PC` control outputs.

- The basic principles of PCH are the same as PCL, but PCH is divided into two halves: the lower half (PCH0-3) and the higher half (PCH4-7)
- PCHC (PCH Carry): Carry from the lowermost to the highestermost PCH half
- The PCH connects to two buses: ADH and DB
- PCH/PCH is used when the PCH is not connected to any bus (to maintain the current state)

## ADL/ADH Precharge

In between the PC bits you can find transistors for precharge of the ADL and ADH buses:

![adl_adh_precharge_tran](/BreakingNESWiki/imgstore/6502/adl_adh_precharge_tran.jpg)

(The image shows the precharge transistors for ADH4 and ADL5. The others are similar)

:warning: As time passed, it turned out that it is more convenient to make the FET where the buses are precharged as part of the [Bus Multiplexer](busmux.md) circuit.

## Logic

It makes sense to show only the bit schematics (the circuitry alternates between even and odd PCL/PCH bits).

This circuit is used, for example, in PCL0 or PCH1:

![pc_even_bit_logisim](/BreakingNESWiki/imgstore/6502/pc_even_bit_logisim.jpg)

This circuit is used, for example, in PCL1 or PCH0:

![pc_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/pc_odd_bit_logisim.jpg)

For these circuits to work correctly in the simulator, FF uses a posedge trigger for the PCL/PCH register.

Optimized schematics (Even):

![20_pc_even_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/20_pc_even_bit_logisim.png)

Optimized schematics (Odd):

![21_pc_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/21_pc_odd_bit_logisim.png)

Optimized schematics for the carry chain:

![22_pc_carry_chain](/BreakingNESWiki/imgstore/6502/ttlworks/22_pc_carry_chain.png)

# Bus Multiplexer

All scattered pieces of schematics of the lower part, where internal buses are connected to each other or buses are connected to constants, it was decided to separate them into a separate section.

The reason for this is that working with buses is a "favorite topic" when designing circuits and it is better to have all places where work with buses happens in one place.

## Precharge

All buses are precharged during PHI2. This is done to form constants: from the value 0xff, which was obtained during precharge, other values are obtained by connecting the required bits to 0.
Note that the charged bus value is retained for the next half-cycle (PHI1), where the required constants are generated.

The SB bus is being precharged in the S register:

![busmpx1](/BreakingNESWiki/imgstore/6502/busmpx1.jpg)

The DB bus is precharged in DataLatch:

![busmpx2](/BreakingNESWiki/imgstore/6502/busmpx2.jpg)

The ADL bus is precharged around the PC register (bits 0-3), with the other FETs scattered between PC and DL:

![busmpx3](/BreakingNESWiki/imgstore/6502/busmpx3.jpg)
![busmpx5](/BreakingNESWiki/imgstore/6502/busmpx5.jpg)

The ADH bus is precharged in the AC register (bits 0-2), with the remaining FETs scattered between PC and DL:

![busmpx4](/BreakingNESWiki/imgstore/6502/busmpx4.jpg)
![busmpx5](/BreakingNESWiki/imgstore/6502/busmpx5.jpg)

## 0/ADL

The commands 0/ADL0, 0/ADL1, 0/ADL2 are used to generate the interrupt address. The FETs are located next to terminals A0-A2.

![busmpx6](/BreakingNESWiki/imgstore/6502/busmpx6.jpg)

## 0/ADH

The 0/ADH0 and 0/ADH17 commands are applied next to the AC register. The 0/ADH0 command applies to bit 0. The 0/ADH17 command applies to bits 1-7.

![busmpx7](/BreakingNESWiki/imgstore/6502/busmpx7.jpg)

## Connection of buses to buses

The SB/DB and SB/ADH commands are used to connect the buses to each other. The FETs to apply these commands are located next to the AC register.

![busmpx8](/BreakingNESWiki/imgstore/6502/busmpx8.jpg)

These commands cause the most trouble when porting 6502 circuits to Verilog or simulation because the bus connection is implemented by a bidirectional FETs.
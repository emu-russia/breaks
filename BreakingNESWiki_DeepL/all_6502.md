# 6502

This section is simply a compilation of all subsections to make it easier to use in neural networks for their fine-tuning.

TODO: Duplicate all image in ASCII art so that they are understood by LLMs which can't analyse pictures.

# 6502 Contents

- [Overview](#6502-overview)
- [Pinout](#pinout)
- [Clock](#clock-generator-1)

## Top Part

- [Instruction Register](#instruction-register)
- [Extended Cycle Counter](#extended-cycle-counter)
- [Decoder](#decoder)
- [Pre-decode](#predecode)
- [Interrupt Processing](#interrupt-processing)
- [Random Logic](#random-logic)
	- [Registers Control](#registers-control)
	- [ALU Control](#alu-control)
	- [Program Counter Control](#program-counter-control)
	- [Bus Control](#bus-control)
	- [Dispatcher](#dispatcher)
	- [Flags Control](#flags-control)
	- [Flags](#flags)
	- [Branch Logic](#branch-logic)
- [Control Commands](#control-commands)

## Bottom Part

- [Address Bus](#address-bus-1)
- [Data Bus](#data-bus-1)
- [Registers](#registers-1)
- [ALU](#alu)
- [Program Counter](#program-counter-pc)
- [Bus Multiplexer](#bus-multiplexer)

Appendix:

- [6502 Verilog Model]()

# 6502 Overview

The 6502 processor was developed by MOS. It was based on the architecture of the Motorola 6800 processor:

|6502|6800|
|---|---|
|<img src="/BreakingNESWiki/imgstore/6502/6502_die_shot.jpg" width="200px">|<img src="/BreakingNESWiki/imgstore/6502/6800.jpg" width="220px">|

In both cases the top part is occupied by the decoder and random logic, and the whole bottom part of the processor is occupied by the context and the ALU.

## Architecture

The processor is divided into two parts: the upper part and the lower part.

The upper part contains the control logic, which issues a number of control lines ("commands") to the lower part.
The lower part contains the context of the processor: internal buses and registers, with one exception - the flags register (P) is in the upper part in a "spread out" form.

Also in the lower part is the [ALU](#alu).

The processor is clocked by the PHI0 clock pulse, both half-cycles are used.
During the first half-cycle (PHI1) the processor is in "Set Address and R/W Mode" mode.
During the second half-cycle (PHI2) the processor is in "Read/Write Data" mode, during this half-cycle external devices can put data on the data bus and get data from the processor.

6502 overview chart:

![6502_logisim_big](/BreakingNESWiki/imgstore/6502/6502_logisim_big.png)

## Registers

- PD: current operation code for precoding
- IR: instruction register (stores the current operation code)
- X, Y: index registers
- S: Stack pointer
- AI, BI: input values for ALU
- ADD: Intermediate result of an ALU operation
- AC: accumulator
- PCH/PCL: program counter in two halves
- PCHS/PCLS: program counter auxiliary registers (S stands for "Select")
- ABH/ABL: registers for output to the external address bus
- DL: data latch, stores the last read value of the external data bus
- DOR: data output register, holds the value which will be written to the data bus
- P: flag register, actually consists of a set of latches scattered around the circuit

The following registers are directly available to the programmer: A (Accumulator), X, Y, S, P, PC (Program Counter).

## External Buses

There are only two external buses: a 16-bit address bus (ADDR) and an 8-bit data bus (DATA). The address bus is one-way - only the processor can write to it. The data bus is bidirectional.

## Internal Buses

- ADH/ADL: address bus
- SB: Side bus, register exchange bus
- DB: Internal data bus

During the second half-step (PHI2) all internal buses are precharged and have a value of 0xFF. This is done because it is faster to "discharge" the transistor at the right moment than to "charge" it (the change of 1=>0 is faster than the change of 0=>1).

## Register-Bus Connections

![6502_context](/BreakingNESWiki/imgstore/6502/6502_context.jpg)

By connecting buses and registers in series, the processor executes a variety of instructions. The variety of connections provides a variety of processor instructions, and the division of instructions into clock cycles allows complex actions to be performed. In addition, the ALU is controlled (addition, logical operations, etc.).

## Software Model

### Addressing Modes

Addressing modes are described here because they should be kept in mind when analyzing circuits.

**Addressing** is a way to get the operand to (or load it from) the desired memory location. The developers of the 6502 were very generous and added as many as two X and Y index registers to the context.

"Indexed" means that an offset is added to the memory address in a certain way to get a new address. This is usually needed to access arrays. In this case the beginning of the array will be a fixed address and the value in the index register will be the array index (offset).

List of addressing modes:
- Immediate (immediate operand). In this case the operand is stored in the instruction itself (usually the second byte, after the operation code). Example `LDA #$1C`: A = 0x1C
- Absolute (absolute addressing). The instruction specifies the full 16-bit address from which to get the operand. For example `LDA $1234`: A = \[$1234\]
- Zero Page Absolute: Developers have made an optimized version of absolute addressing by adding the ability to address only page zero (pages are 256 bytes in size). Example `LDA $56`: In this case the processor itself makes the highest 8 bits of the address equal to 0x00, while the lowest 8 bits are taken from the instruction. The final address is 0x0056. A = \[0x0056\]. This is done to save instruction size (one byte is saved).
- Indexed: In this addressing mode an offset from the X or Y register is added to the constant address value. For example `LDA $1234, X`: A = \[$1234 + X\]
- Zero Page Indexed: Similar to Indexed but only the X register can be used. Example `LDA $33, X`: A = \[$0033 + X\]

And then the special magic begins:
- Pre-indexed Indirect: The value of the operand which is the address in page zero is added to the value of register X and the indirect address is obtained. The address the indirect address refers to is then used to get the value of the operand. Example `LDA ($34, X)`: A = \[\[$0034 + X\]\]. Important: When you add an address and a value in the X register, it "wraps" around 256 bytes. That is, it does not wrap to the higher half of the address. (0xFF + 0x02 will be 0x0001, not 0x0101). **Indirect** means "take address by address".
- Post-indexed Indirect: Different from the previous one in that the indirect address from page zero is selected first, and then the index register Y value is added to it. Example `LDA ($2A), Y`: A = \[\[$002A\] + Y\].

### Instruction Set

The 6502 has all the necessary instructions and also includes such rather handy instructions as bit rotation (ROL/ROR) and bit testing (BIT). Not all processors of the time contained such instructions.

The instruction type and address mode are fully contained in the operation code, to simplify decoding, but the bus width (8 bits) does not allow all instructions to be executed in a single clock cycle. Also, the decoder is somewhat unoptimized, so the minimum instruction execution time is 2 clock cycles, with the first clock cycle always taken by sampling the operation code (the first byte of the instruction).

Summary of instructions:

|Instruction|Description|
|---|---|
|ADC |Add Memory to Accumulator with Carry|
|AND |"AND" Memory with Accumulator|
|ASL |Shift Left One Bit (Memory or Accumulator)|
|BCC |Branch on Carry Clear|
|BCS |Branch on Carry Set|
|BEQ |Branch on Result Zero|
|BIT |Test Bits in Memory with Accumulator|
|BMI |Branch on Result Minus|
|BNE |Branch on Result not Zero|
|BPL |Branch on Result Plus|
|BRK |Force Break|
|BVC |Branch on Overflow Clear|
|BVS |Branch on Overflow Set|
|CLC |Clear Carry Flag|
|CLD |Clear Decimal Mode|
|CLI |Clear interrupt Disable Bit|
|CLV |Clear Overflow Flag|
|CMP |Compare Memory and Accumulator|
|CPX |Compare Memory and Index X|
|CPY |Compare Memory and Index Y|
|DEC |Decrement Memory by One|
|DEX |Decrement Index X by One|
|DEY |Decrement Index Y by One|
|EOR |"Exclusive-Or" Memory with Accumulator|
|INC |Increment Memory by One|
|INX |Increment Index X by One|
|INY |Increment Index Y by One|
|JMP |Jump to New Location|
|JSR |Jump to New Location Saving Return Address|
|LDA |Load Accumulator with Memory|
|LDX |Load Index X with Memory|
|LDY |Load Index Y with Memory|
|LSR |Shift Right One Bit (Memory or Accumulator)|
|NOP |No Operation|
|ORA |"OR" Memory with Accumulator|
|PHA |Push Accumulator on Stack|
|PHP |Push Processor Status on Stack|
|PLA |Pull Accumulator from Stack|
|PLP |Pull Processor Status from Stack|
|ROL |Rotate One Bit Left (Memory or Accumulator)|
|ROR |Rotate One Bit Right (Memory or Accumulator)|
|RTI |Return from Interrupt|
|RTS |Return from Subroutine|
|SBC |Subtract Memory from Accumulator with Borrow|
|SEC |Set Carry Flag|
|SED |Set Decimal Mode|
|SEI |Set Interrupt Disable Status|
|STA |Store Accumulator in Memory|
|STX |Store Index X in Memory|
|STY |Store Index Y in Memory|
|TAX |Transfer Accumulator to Index X|
|TAY |Transfer Accumulator to Index Y|
|TSX |Transfer Stack Pointer to Index X|
|TXA |Transfer Index X to Accumulator|
|TXS |Transfer Index X to Stack Pointer|
|TYA |Transfer Index Y to Accumulator|

The developers chose the encoding so that it would be easier to process by [decoder](#decoder) and [random logic](#random-logic).

Table of 6502 opcodes (for reference):

![6502_opcode_table](/BreakingNESWiki/imgstore/6502/6502_opcode_table.jpg)

You can find a description of the instructions in any Reference Manual for 6502.

### Interrupts

6502 interrupts:
- IRQ: hardware interrupt. Can be disabled with flag I (interrupt disable), if flag I=1 the interrupt is "disabled" and does not go to the CPU. 
- NMI: non-maskable interrupt. It has higher priority than IRQ, triggered on falling edge. 
- RES: hardware reset. After powering up the 6502 it is necessary to set the /RES pin to 0 for a few cycles so that the processor "comes to its senses".
- BRK: software interrupt. It is initiated by the `BRK` instruction.

## Note on Transistor Circuits

The transistor circuits of each component are chopped into component parts so that they don't take up too much space.

To keep you from getting lost, each section includes a special "locator" at the beginning that marks the approximate location of the component being studied on the large 6502 "family portrait" (https://github.com/emu-russia/breaks/blob/master/Docs/6502/6502.jpg)

Example locator:

![6502_locator_alu_control](/BreakingNESWiki/imgstore/6502/6502_locator_alu_control.jpg)

## Note on Logic Circuits

The logic circuits are mostly made in the Logisim program. The following element is used to denote DLatch:

|DLatch (transistor circuit)|DLatch (logic equivalent)|
|---|---|
|![dlatch_tran](/BreakingNESWiki/imgstore/dlatch_tran.jpg)|![dlatch_logic](/BreakingNESWiki/imgstore/dlatch_logic.jpg)|

For convenience, the logical variant of DLatch has two outputs (`out` and `/out`), since the current value of DLatch (out) is often used as an input of a NOR operation.

The optimized versions of the logic diagrams are compiled by @ttlworks and contain an additional source of information for analysis.

# Pinout

The study of any integrated circuit begins with the pinout.

![6502_pads_map](/BreakingNESWiki/imgstore/6502/6502_pads_map.jpg)

![6502_pinout](/BreakingNESWiki/imgstore/6502/6502_pinout.png)

|Name|Direction|Description|
|---|---|---|
|VCC| => 6502     |Power +5 V|
|VSS| 6502 =>     |Ground|
|/NMI| => 6502  |Non-maskable interrupt signal, active low|
|/IRQ| => 6502  |Maskable interrupt signal, active low|
|/RES| => 6502  |Reset signal, active low|
|PHI0| => 6502 |Reference clock signal|
|PHI1| 6502 =>  |First half-cycle, processor in `Set address+RW` mode|
|PHI2| 6502 => |Second half-cycle, processor in `Read/Write Data` mode|
|RDY| => 6502 |Processor Ready (1: ready)|
|SO| => 6502 |Forced setting of the overflow flag (V)|
|R/W| 6502 => |Data bus direction (R/W=1: processor reads data, R/W=0: processor writes)|
|SYNC| 6502 => |The processor is on cycle T1 (opcode fetch)|
|A0-A15| 6502 => |Address bus|
|D0-D7| 6502 <=> |Data bus (bidirectional)|
|N.C.| -- |Not connected|

## VDD/VSS

From the official datasheet we know that the operating range of VDD = +5.0 volts +/- 5%.

## Clock Generator

The clock signals are described in a separate section (see [clock generator](#clock-generator-1)).

## /NMI, /IRQ, /RES

![intpads_trans](/BreakingNESWiki/imgstore/6502/intpads_trans.jpg)

Each terminal circuitry contains a FF where the interrupt arrival event is stored. The FF value corresponds to the control signals `/NMIP`, `/IRQP` and `RESP` (the value from FF for the /RES terminal is output as active-high value).

The "P" in the name of the control signals stands for "Pad" (bonding pad).

:warning: Note that the `Q` output is used for NMI and IRQ FF, and the `#Q` output is used for RES FF. The FF circuitry features cyclically closed AOI-21 elements.

![int_ff](/BreakingNESWiki/imgstore/6502/int_ff.png)

## RDY

|![rdy_tran](/BreakingNESWiki/imgstore/6502/rdy_tran.jpg)|![rdy_nice](/BreakingNESWiki/imgstore/6502/rdy_nice.jpg)|
|---|---|

The RDY pin goes to the internal `RDY` signal and also through the DLATCH delay chain as the `/PRDY` ("Previous Ready") signal.
/PRDY goes to the [decoder](#decoder) input `Branch T0`.

The RDY pin can be used to temporarily suspend the processor, e.g. while an external device performs a DMA.

## SYNC

|![sync_tran](/BreakingNESWiki/imgstore/6502/sync_tran.jpg)|![sync_nice](/BreakingNESWiki/imgstore/6502/sync_nice.jpg)|
|---|---|

The SYNC signal comes from the internal T1 signal (opcode fetch).

## SO

![so_tran](/BreakingNESWiki/imgstore/6502/so_tran.jpg)

The internal signal `SO` is fed to the [flag V](#flags) input to process the control signal `1/V`.

## R/W

![rw_tran](/BreakingNESWiki/imgstore/6502/rw_tran.jpg)

The `WR` signal comes from [dispatcher](#dispatcher) and defines the operating mode of the processor (WR:1 - processor writes data, WR:0 - processor reads data).

## Address Bus

See [Address Bus](#address-bus-1).

## Data Bus

See [Data Bus](#data-bus-1).

## Optimized Schematics

![19_pads](/BreakingNESWiki/imgstore/6502/ttlworks/19_pads.png)

# Clock Generator

The 6502 includes two clock reference circuits: an external and an internal one.

The processor inputs one clock signal, `PHI0`, and outputs two clock signals, `PHI1` and `PHI2`.

This principle is based on the fact that each clock cycle of the processor consists of two "modes" (or "states"):
- PHI1=1: Set address and R/W mode
- PHI2=1: Read/write data

During write mode the `PHI1` signal is high. During this time, external devices can use the address set on the external address bus of the processor.

During read mode the signal `PHI2` is high. During this time external devices can write data to the processor's data bus so that the processor can use it for its own purposes.

The signals `PHI1` and `PHI2` are called half-cycles and are derived from the original clock signal `PHI0` as follows:
- When `PHI0` is low - the `PHI1` signal is high
- When `PHI0` is high - the `PHI2` signal is also high

|PHI0|PHI1|PHI2|
|---|---|---|
|0|1|0|
|1|0|1|

This approach to organizing cycle time scheduling is not uncommon among older processors and is commonly referred to as "Dual-rail CLK".

## Internal Clock

![clock_internal](/BreakingNESWiki/imgstore/6502/clock_internal.jpg)

The circuit is quite complicated, because it is not quite "digital". The numerous transistors that act as inverters slightly delay the PHI0 signal, so the PHI1 and PHI2 signals going inside the processor are a bit "laggy". Here is the logical representation of the circuit:

![clock_internal_logic](/BreakingNESWiki/imgstore/6502/clock_internal_logic.jpg)

Logical analysis:

![clock_internal_logic_zero](/BreakingNESWiki/imgstore/6502/clock_internal_logic_zero.jpg)

![clock_internal_logic_one](/BreakingNESWiki/imgstore/6502/clock_internal_logic_one.jpg)

The layout of the clock signals should be about the following:
- PHI1/PHI2 are slightly lagging relative to PHI0
- The lower level of PHI1/PHI2 is slightly longer than the upper level, so that both signals are guaranteed not to have a high level

![4672299](/BreakingNESWiki/imgstore/6502/waves/4672299.png)

The simulation in Altera Quartus shows "lag", but does not show the elongated lower level (it is hand-drawn in the picture above).

BigEd from the 6502.org forum suggested that he ran a simulation on the 6502 FPGA netlist and got the following sweeps:

![cclk-rising](/BreakingNESWiki/imgstore/6502/waves/cclk-rising.png)

![cclk-falling](/BreakingNESWiki/imgstore/6502/waves/cclk-falling.png)

The signal designations are as follows: clk0 = PHI0, cp1 = PHI1, cclk = PHI2 (according to the netlist with Visual6502)

The schematic on which his simulation was based corresponds to the one in Balasz's documentation:

![clock_balazs](/BreakingNESWiki/imgstore/6502/clock_balazs.png)

http://forum.6502.org/viewtopic.php?f=8&t=2208&start=195

It turns out that because of the asymmetrical inverter stage the rising edge is delayed, so the lower level is as if "delayed".

The official documentation gives the following diagram:

![clock_timing_datasheet](/BreakingNESWiki/imgstore/6502/clock_timing_datasheet.jpg)

Optimized schematics:

![8_clock_internal](/BreakingNESWiki/imgstore/6502/ttlworks/8_clock_internal.png)

## External Clock

![clock_external](/BreakingNESWiki/imgstore/6502/clock_external.jpg)

The PHI1/PHI2 reference signals are also output to the outside for consumers.

The logic circuit of the external wiring of the clock signals does not differ from the internal wiring circuit, except that the outputs of PHI1/PHI2 go to the same contacts through the "comb" of powerful transistors.

## Why PHI

In the official 6502 datasheet the half-cycles are called "phases", respectively the name of these signals is Φ1 and Φ2. For unification we use the designations PHI1 and PHI2.

# Instruction Register

![6502_locator_ir](/BreakingNESWiki/imgstore/6502/6502_locator_ir.jpg)

The Instruction Register (IR) stores the current operation code, for processing on [decoder](#decoder). The operation code is loaded into the IR from [predecode logic](#predecode).

## Transistor Circuit

![ir_tran](/BreakingNESWiki/imgstore/6502/ir_tran.jpg)

The outputs in the schematic are on the left because the decoder is topologically located on the left side.

- IR0 and IR1 are combined into one common line `IR01` to save lines
- IR0 is used only for the 128th decoder line (IMPL) (this operation with IR0 is part of the random logic)
- /IR5 goes additionally to flags and is used in set/clear flags instructions (SEI/CLI, SED/CLD, SEC/CLC)

## Logic

![ir_logic](/BreakingNESWiki/imgstore/6502/ir_logic.jpg)

- During PHI1 the IR value is overloaded from the [Predecode (PD)](#predecode) latch, but only if the `FETCH` command is active
- During PHI2 the IR is "refreshed" (this is not shown in logic circuit)

It should be noted that an inverted operation code (PD) value is fed to the IR input and is also stored on the latch in an inverted form.

## Optimized Schematics

![18_ir_logic](/BreakingNESWiki/imgstore/6502/ttlworks/18_ir_logic.png)

# Extended Cycle Counter

![6502_locator_extended_counter](/BreakingNESWiki/imgstore/6502/6502_locator_extended_counter.jpg)

The 6502 has 3 cycle counters:
- The base counter, used for short instructions (Counts T0-T1 cycles)
- Extended counter (which we will talk about here) used for long instructions (Counts cycles T2-T5)
- Counter for very long instructions (Counts cycles RMW T6-T7)

One cycle (T) refers to two consecutive half-cycles (PHI1 + PHI2) of the processor.

## Transistor Circuit

![extended_cycle_counter_trans](/BreakingNESWiki/imgstore/6502/extended_cycle_counter_trans.jpg)

The whole circuit is a shift register, with a control signal `T1` as its input. While the shift register is running, the value of T1 is shifted and goes to the output of `/T2`, then to `/T3` and so on. The /T2-/T5 outputs are in inverse logic.

The shift register is used as a counter for easy transfer of the current cycle (/T2-/T5) to the decoder input.

The register is reset by the `TRES2` command and is done after the instruction has been processed.

The circuit includes multiplexers on the `/ready` signal. This is done so that when the processor is not ready (ready=0) - shift register remains in the current state.

## Logic

![extended_cycle_counter_logic](/BreakingNESWiki/imgstore/6502/extended_cycle_counter_logic.jpg)

## Optimized Schematics

![14_extended_cycle_counter_logic](/BreakingNESWiki/imgstore/6502/ttlworks/14_extended_cycle_counter_logic.png)

# Decoder

![6502_locator_decoder](/BreakingNESWiki/imgstore/6502/6502_locator_decoder.jpg)

The decoder is an ordinary demultiplexer, but a very large one. The formula for the demultiplexer is 21-to-130. Sometimes the 6502 instruction decoder is also called a PLA.

Topologically, the decoder is divided by ground lines into several groups, so we'll stick to the same division, for convenience.

## Decoder Inputs

The input signals are:
- /T0, /T1X: current cycle for short (2 clock) instructions. These signals are output from [dispatch logic](#dispatcher).
- /T2, /T3, /T4, /T5: current cycle for long instructions. Signals are output from [extended cycle counter](#extended-cycle-counter).
- /IR0, /IR1, IR01: the lower bits of the operation code from [instruction register](#instruction-register). To reduce the number of lines 0 and 1 bits are combined into one control line `IR01`.
- IR2-IR7, /IR2-/IR7: direct and inverse values of the remaining bits. The direct and inverse forms are needed to check the bit for 0 and 1.

## Principle

Schematically, each output is a multi-input NOR element.

![decoder_nice1](/BreakingNESWiki/imgstore/6502/decoder_nice1.jpg)

![decoder_nice2](/BreakingNESWiki/imgstore/6502/decoder_nice2.jpg)

The @ttlworks version of the decoder:

![10_decoder](/BreakingNESWiki/imgstore/6502/ttlworks/10_decoder.png)

## Special Lines

Additional logical operations are applied to some decoder outputs, which although territorially are in the decoder area, are actually part of [random logic](#random-logic). Most likely this logic got into the decoder simply because it was more convenient to split the connections that way.

List:
- Internal Push/Pull line: a special (129th) line that does not extend beyond the decoder. It is used to "cut off" Push/pull instructions when selecting instructions. It is used in three lines: 83, 90, and 128. Appears on the schematic in duplicate, for different parts of the decoder.
- /PRDY: this line goes to decoder line 73 (Branch T0)
- IR0: normally the common signal IR01 is used to check the two lowest bits of the operation code, but exclusively for the 128th line (IMPL), IR0 is used (IR0 is not included in the mask for the table below).

## PLA Contents

|Group|N|Mask value (Raw bits)|Decoded mask value|Cycle (T)|Comments|Where to use|
|---|---|---|---|---|---|---|
|A|||||||
|A01   |0 |000101100000100100000   |100XX100 |TX     |STY|Register control|
|A02   |1 |000000010110001000100   |XXX100X1 |T3     |OP ind, Y|Register control|
|A03   |2 |000000011010001001000   |XXX110X1 |T2     |OP abs, Y|Register control|
|A04   |3 |010100011001100100000   |1X001000 |T0     |DEY INY  |Register control|
|A05   |4 |010101011010100100000   |10011000 |T0     |TYA      |Register control|
|A06   |5 |010110000001100100000   |1100XX00 |T0     |CPY INY  |Register control|
|B|||||||
|B01   |6 |000000100010000001000   |XXX1X1XX |T2     |OP zpg, X/Y & OP abs, X/Y |Register control|
|B02   |7 |000001000000100010000   |10XXXX1X |TX     |LDX STX A<->X S<->X       |Register control|
|B03   |8 |000000010101001001000   |XXX000X1 |T2     |OP ind, X        |Register control|
|B04   |9 |010101011001100010000   |1000101X |T0     |TXA              |Register control|
|B05  |10 |010110011001100010000   |1100101X |T0     |DEX              |Register control|
|B06  |11 |011010000001100100000   |1110XX00 |T0     |CPX INX          |Register control|
|B07  |12 |000101000000100010000   |100XXX1X |TX     |STX TXA TXS|Register control|
|B08  |13 |010101011010100010000   |1001101X |T0     |TXS                |Register control|
|B09  |14 |011001000000100010000   |101XXX1X |T0     |LDX TAX TSX|Register control|
|B10  |15 |100110011001100010000   |1100101X |T1     |DEX|Register control|
|B11  |16 |101010011001100100000   |11101000 |T1     |INX|Register control|
|B12  |17 |011001011010100010000   |1011101X |T0     |TSX|Register control|
|B13  |18 |100100011001100100000   |1X001000 |T1     |DEY INY|Register control|
|B14  |19 |011001100000100100000   |101XX100 |T0     |LDY|Register control|
|B15  |20 |011001000001100100000   |1010XX00 |T0     |LDY TAY|Register control|
|C|||||||
|C01  |21 |011001010101010100000   |00100000 |T0     |JSR|Register control|
|C02  |22 |000101010101010100001   |00000000 |T5     |BRK|Register control; Auxiliary signal BRK5|
|C03  |23 |010100011001010100000   |0X001000 |T0     |Push|Register control|
|C04  |24 |001010010101010100010   |01100000 |T4     |RTS|Register control|
|C05  |25 |001000011001010100100   |0X101000 |T3     |Pull|Register control|
|C06  |26 |000110010101010100001   |01000000 |T5     |RTI|Register control; Auxiliary signal RTI/5|
|C07  |27 |001010000000010010000   |011XXX1X |TX     |ROR|To obtain an auxiliary /ROR signal for the ADD/SB7 circuit|
|C08  |28 |000000000000000001000   |XXXXXXXX |T2     |T2 ANY|Auxiliary signal T2 (processor is in cycle T2)|
|C09  |29 |010110000000011000000   |010XXXX1 |T0     |EOR|ALU Control|
|C10  |30 |000010101001010100000   |01X01100 |TX     |JMP (excluder for C11)|ALU Control|
|C11  |31 |000000101001000001000   |XXX011XX |T2     |ALU absolute|ALU Control|
|C12  |32 |010101000000011000000   |000XXXX1 |T0     |ORA|ALU Control|
|C13  |33 |000000000100000001000   |XXXX0XXX |T2     |The entire "left" half of the opcode table (values `X0-X7`)|ALU Control|
|C14  |34 |010000000000000000000   |XXXXXXXX |T0     |T0 ANY|ALU Control|
|C15  |35 |000000010001010101000   |0XX0X000 |T2     |BRK JSR RTI RTS Push/pull - stack operations on T2|Regs Control, ALU Control; Auxiliary signal STK2|
|C16  |36 |000000000001010100100   |0XX0XX00 |T3     |BRK JSR RTI RTS Push/pull + BIT JMP|ALU Control|
|D|||||||
|D01  |37 |000001010101010100010   |00X00000 |T4     |BRK JSR|ALU Control|
|D02  |38 |000110010101010100010   |01000000 |T4     |RTI|ALU Control|
|D03  |39 |000000010101001000100   |XXX000X1 |T3     |OP X, ind|ALU Control|
|D04  |40 |000000010110001000010   |XXX100X1 |T4     |OP ind, Y|ALU Control|
|D05  |41 |000000010110001001000   |XXX100X1 |T2     |OP ind, Y|ALU Control|
|D06  |42 |000000001010000000100   |XXX11XXX |T3     |RIGHT ODD|ALU Control|
|D07  |43 |001000011001010100000   |0X101000 |TX     |Pull|ALU Control|
|D08  |44 |001010000000100010000   |111XXX1X |TX     |INC NOP|ALU Control|
|D09  |45 |000000010101001000010   |XXX000X1 |T4     |OP X, ind|ALU Control; Bus Control (DL/DB)|
|D10  |46 |000000010110001000100   |XXX100X1 |T3     |OP ind, Y|Bus Control (DL/DB)|
|D11  |47 |000010010101010100000   |01X00000 |TX     |RTI RTS|Bus Control (DL/DB); Auxiliary signal RET|
|D12  |48 |001001010101010101000   |00100000 |T2     |JSR|Auxiliary signal JSR2|
|D13  |49 |010010000001100100000   |11X0XX00 |T0     |CPY CPX INY INX|ALU Control|
|D14  |50 |010110000000101000000   |110XXXX1 |T0     |CMP|ALU Control|
|D15  |51 |011010000000101000000   |111XXXX1 |T0     |SBC|ALU Control; Auxiliary signal SBC0|
|D16  |52 |011010000000001000000   |X11XXXX1 |T0     |ADC SBC|ALU Control|
|D17  |53 |001001000000010010000   |001XXX1X |TX     |ROL|ALU Control|
|E|||||||
|E01  |54 |000010101001010100100   |01X01100 |T3     |JMP ind|ALU Control|
|E02  |55 |000001000000010010000   |00XXXX1X |TX     |ASL ROL|Bus Control|
|E03  |56 |001001010101010100001   |00100000 |T5     |JSR|Auxiliary signal JSR/5|
|E04  |57 |000000010001010101000   |0XX0X000 |T2     |BRK JSR RTI RTS Push/pull|Bus Control|
|E05  |58 |010101011010100100000   |10011000 |T0     |TYA|Bus Control|
|E06  |59 |100000000000011000000   |0XXXXXX1 |T1     |UPPER ODD|Bus Control|
|E07  |60 |101010000000001000000   |X11XXXX1 |T1     |ADC SBC|Bus Control|
|E08  |61 |100000011001010010000   |0XX0101X |T1     |ASL ROL LSR ROR|Bus Control|
|E09  |62 |010101011001100010000   |1000101X |T0     |TXA|Bus Control|
|E10  |63 |011010011001010100000   |01101000 |T0     |PLA|Bus Control|
|E11  |64 |011001000000101000000   |101XXXX1 |T0     |LDA|Bus Control|
|E12  |65 |010000000000001000000   |XXXXXXX1 |T0     |ALL ODD|Bus Control|
|E13  |66 |011001011001100100000   |10101000 |T0     |TAY|Bus Control|
|E14  |67 |010000011001010010000   |0XX0101X |T0     |ASL ROL LSR ROR|Bus Control|
|E15  |68 |011001011001100010000   |1010101X |T0     |TAX|Bus Control|
|E16  |69 |011001100001010100000   |0010X100 |T0     |BIT0|ALU Control (AND)|
|E17  |70 |011001000000011000000   |001XXXX1 |T0     |AND0|ALU Control (AND)|
|E18  |71 |000000001010000000010   |XXX11XXX |T4     |OP abs,XY|Bus Control (ADL/ABL)|
|E19  |72 |000000010110001000001   |XXX100X1 |T5     |OP ind,Y|Bus Control (ADL/ABL)|
|F|||||||
|F01  |73 |010000010110000100000   |XXX10000 |T0 |<-  Branch. :warning: Additionally affected by the /PRDY line (from the RDY contact), immediately on the spot|Auxiliary signal BR0|
|F02  |74 |000110011001010101000   |01001000 |T2     |PHA|Bus Control (AC/DB)|
|F03  |75 |010010011001010010000   |01X0101X |T0     |LSR ROR|ALU Control (SR)|
|F04  |76 |000010000000010010000   |01XXXX1X |TX     |LSR ROR|ALU Control (SR)|
|F05  |77 |000101010101010101000   |00000000 |T2     |BRK|PC Control|
|F06  |78 |001001010101010100100   |00100000 |T3     |JSR|PC Control|
|F07  |79 |000101000000101000000   |100XXXX1 |TX     |STA|Auxiliary signal STA|
|F08  |80 |000000010110000101000   |XXX10000 |T2     |BR2 (Branch T2)|PC control circuit and PC increment circuit|
|F09  |81 |000000100100000001000   |XXXX01XX |T2     |zero page|Bus Control (DL/ADL)|
|F10  |82 |000000010100001001000   |XXXX00X1 |T2     |ALU indirect|Bus Control (DL/ADL)|
|F11  |83 |000000001000000001000   |XXXX1XXX |T2     |The entire "right" half of the opcode table (`X8-XF` values). The Push/Pull opcode exclusion operation is additionally applied to this line, right in place|Auxiliary signal ABS/2|
|F12  |84 |001010010101010100001   |01100000 |T5     |RTS|Auxiliary signal RTS/5|
|F13  |85 |000000000000000000010   |XXXXXXXX |T4     |T4 ANY|Bus Control (NOADL)|
|F14  |86 |000000000000000000100   |XXXXXXXX |T3     |T3 ANY|Bus Control (NOADL)|
|F15  |87 |010100010101010100000   |0X000000 |T0     |BRK RTI|Bus Control (NOADL)|
|F16  |88 |010010101001010100000   |01X01100 |T0     |JMP|Bus Control (IND)|
|F17  |89 |000000010101001000001   |XXX000X1 |T5     |OP X, ind|Bus Control (NOADL, IND)|
|F18  |90 |000000001000000000100   |XXXX1XXX |T3     |The entire "right" half of the opcode table (`X8-XF` values). The Push/Pull opcode exclusion operation is additionally applied to this line, right in place|Bus Control (IND)|
|G|||||||
|G01  |91 |000000010110001000010   |XXX100X1 |T4     |OP ind, Y|Cycle Counter Reset, Bus Control (IND)|
|G02  |92 |000000001010000000100   |XXX11XXX |T3     |RIGHT ODD|Cycle Counter Reset|
|G03  |93 |000000010110000100100   |XXX10000 |T3     |BR3 (Branch T3)|PC control circuit and PC increment circuit|
|G04  |94 |000100010101010100000   |0X000000 |TX     |BRK RTI|PC Control (JB)|
|G05  |95 |001001010101010100000   |00100000 |TX     |JSR|PC Control (JB)|
|G06  |96 |000010101001010100000   |01X01100 |TX     |JMP|PC Control (JB), ENDX (Long instruction completion)|
|P/P |129 |000000011001010100000   |0XX01000 |TX |<-  Push/pull opcodes, used as an exclusive for F11 & F18 (in situ)|First pp instance|
|G07  |97 |000101000000100000000   |100XXXXX |TX     |STORE|For RW Control and to obtain an auxiliary STOR signal|
|G08  |98 |000101010101010100010   |00000000 |T4     |BRK|RW Control, !POUT (flags control)|
|G09  |99 |000101011001010101000   |00001000 |T2     |PHP|!POUT (flags control)|
|G10 |100 |000100011001010101000   |0X001000 |T2     |Push|RW Control, ENDX (Long instruction completion)|
|G11 |101 |000010101001010100010   |01X01100 |T4     |JMP ind|ENDX, Bus Control; Auxiliary signal JMP/4|
|G12 |102 |000010010101010100001   |01X00000 |T5     |RTI RTS|ENDX (Long instruction completion)|
|G13 |103 |001001010101010100001   |00100000 |T5     |JSR|ENDX (Long instruction completion)|
|H|||||||
|H01 |104 |000110101001010101000   |01001100 |T2     |JMP abs|ENDX (Long instruction completion)|
|H02 |105 |001000011001010100100   |0X101000 |T3     |Pull|ENDX (Long instruction completion)|
|H03 |106 |000010000000000010000   |X1XXXX1X |TX     |LSR ROR DEC INC DEX NOP (4x4 bottom right)|Cycle Counter 5-6|
|H04 |107 |000001000000010010000   |00XXXX1X |TX     |ASL ROL|Cycle Counter 5-6, flags control|
|H05 |108 |010010011010010100000   |01X11000 |T0     |CLI SEI|flags control|
|H06 |109 |101001100001010100000   |0010X100 |T1     |BIT|flags control|
|H07 |110 |010001011010010100000   |00X11000 |T0     |CLC SEC|flags control|
|H08 |111 |000000100110000000100   |XXX101XX |T3     |Memory zero page X/Y|MemOP|
|H09 |112 |101010000000001000000   |X11XXXX1 |T1     |ADC SBC|flags control|
|H10 |113 |011001100001010100000   |0010X100 |T0     |BIT|flags control|
|H11 |114 |011001011001010100000   |00101000 |T0     |PLP|flags control|
|H12 |115 |000110010101010100010   |01000000 |T4     |RTI|flags control|
|H13 |116 |100110000000101000000   |110XXXX1 |T1     |CMP|flags control|
|H14 |117 |100010101001100100000   |11X01100 |T1     |CPY CPX abs|flags control|
|H15 |118 |100001011001010010000   |00X0101X |T1     |ASL ROL|flags control|
|H16 |119 |100010000101100100000   |11X00X00 |T1     |CPY CPX zpg/immed|flags control|
|K|||||||
|P/P |129 |000000011001010100000   |0XX01000 |TX     |<-  Push/pull opcodes, used as an exclusive for K09 (in situ)|Second pp instance|
|K01 |120 |010010011010100100000   |11X11000 |T0     |CLD SED|flags control|
|K02 |121 |000001000000000000000   |X0XXXXXX |TX     |/IR6|Branch Logic|
|K03 |122 |000000101001000000100   |XXX011XX |T3     |Memory absolute|MemOP|
|K04 |123 |000000100101000001000   |XXX001XX |T2     |Memory zero page|MemOP|
|K05 |124 |000000010100001000001   |XXXX00X1 |T5     |Memory indirect|MemOP|
|K06 |125 |000000001010000000010   |XXX11XXX |T4     |Memory absolute X/Y|MemOP|
|K07 |126 |000000000000010000000   |0XXXXXXX |TX     |/IR7|Branch Logic|
|K08 |127 |001001011010100100000   |10111000 |TX     |CLV|flags control|
|K09 |128 |000000011000000000000   |XXXX10X0 |TX     |IMPL. :warning: The Push/Pull opcode exclusion operation is additionally applied to this line, right on the spot. Also, the mask for this line does not take into account the `& ~IR0` operation|Bus Control (DL/DB)|

## What Raw bits mean

If you think of a decoder as a 21x130 ROM, where each bit represents a transistor, then the `Raw bits` value will represent one line of the decoder. This is why it is called the mask value.

For example, the picture shows the 5th line of the decoder. The bit order in the picture is bottom-up from the most significant bits to the least significant bits (msb -> lsb). 0 means no transistor, 1 means present.

![decoder_line](/BreakingNESWiki/imgstore/6502/decoder_line.jpg)

## Online Decoder

You can use an online decoder to highlight opcodes: https://github.com/emu-russia/breaks/blob/master/Docs/6502/decoder.htm

In the `Raw bits` field you can insert the mask value from the table above and when you press the `Make IR Mask` button you will get the decoded mask value (e.g. `11X00X00`). 
The decoded mask value can be inserted into the `IR` field and when the `Decode` button is pressed, the opcodes that correspond to the specified IR mask will be highlighted in the table.

## Branch T0 Skip

From pin [RDY](#pinout) a special line `/PRDY` comes through the delay line. If the processor was not ready when the _previous_ instruction finished, then if the next instruction is a conditional branch, its cycle 0 (T0) is skipped.

The meaning of this operation is not known yet.

## Why the decoder is so big and scary

Actually, there is nothing scary about it.

The decoder was compiled according to the requirements of random logic. Random logic is divided into several parts (domains) and each part corresponds to its own zone in the decoder, which was specially chosen so that the necessary opcodes were processed.

In other words - it is not random logic that adjusts to decoder, but vice versa. The impression that the decoder is "more important" is formed simply because it is above random logic.

# Predecode

![6502_locator_predecode](/BreakingNESWiki/imgstore/6502/6502_locator_predecode.jpg)

The circuit is designed to define the "class" of an instruction: 
- A short instruction which is executed in 2 clock cycles (`TWOCYCLE`)
- An instruction of type `IMPLIED` which has no operands (takes 1 byte in memory)

![predecode_tran](/BreakingNESWiki/imgstore/6502/predecode_tran.jpg)

The operation code received from the external data bus (D0...D7) is first stored on the transparent DLatch and then during PHI2 on the PREDECODE (PD) latch (in inverted form), after which the precoding logic immediately determines the instruction class (the circuit is combinatorial).

The output `/TWOCYCLE` is used by a short cycle counter. The output `/IMPLIED` is used by the PC increment logic.

The PD latch value is fed to the [instruction register](#instruction-register) input in inverted form.

Also the control line `0/IR` is fed to the Predecode logic input which "injects" the BRK operation into the instruction stream. This occurs during interrupt processing, to initialize the BRK sequence (all interrupts simply mimic the BRK instruction, with slight modifications).

The pre-decode circuit works closely with the [dispatcher](#dispatcher), all control signals go there.

## Logic

![predecode_logic](/BreakingNESWiki/imgstore/6502/predecode_logic.jpg)

The predecoding logic is self-descriptive:
- 2-cycle instructions are: Direct operand instructions OR all single-byte instructions EXCEPT push/pull instructions (specified by mask XXX010X1 + 1XX000X0 + XXXX10X0 - 0XX0XX0X)
- Single-byte instructions are set by mask XXXX10X0

TWOCYCLE instructions:

![predecode_twocycle](/BreakingNESWiki/imgstore/6502/predecode_twocycle.jpg)

IMPLIED instructions:

![predecode_implied](/BreakingNESWiki/imgstore/6502/predecode_implied.jpg)

## Optimized Schematics

![24_predecode_logic](/BreakingNESWiki/imgstore/6502/ttlworks/24_predecode_logic.png)

# Interrupt Processing

![6502_locator_intr](/BreakingNESWiki/imgstore/6502/6502_locator_intr.jpg)

Interrupt processing includes the following circuits:
- NMI edge detection
- Cycle counter 6-7 for interrupt handling
- Setting the low-order bits of the interrupt vector address (ADL0-3)
- Circuit for issuing internal signal `DORES`.
- B Flag

The common designation for the 6502 interrupt handling process is called "BRK-sequence".

Three signals `/NMIP`, `/IRQP` and `RESP` come to the input of the circuits from the corresponding input pads.

## NMI Processing

Transistor circuit (includes cycle counter 6-7 and NMI edge detector):

![intr_cycles_nmip_tran](/BreakingNESWiki/imgstore/6502/intr_cycles_nmip_tran.jpg)

## Interrupt vector address and Reset FF

Transistor circuit:

![intr_resp_address_tran](/BreakingNESWiki/imgstore/6502/intr_resp_address_tran.jpg)

The circuit for getting the control signal `DORES` ("Do Reset") (which is binned to all other internals) is combined here with the interrupt vector setting circuit to save space.

## B Flag

Transistor circuit:

![intr_b_flag_tran](/BreakingNESWiki/imgstore/6502/intr_b_flag_tran.jpg)

## Logic

Interrupt handling schematic:

![int_control_logisim](/BreakingNESWiki/imgstore/6502/int_control_logisim.jpg)

To handle interrupts an additional circuit is required to generate cycles 6 and 7 (because they do not come from the decoder) (control signals `BRK6E` and `BRK7`). And the control signal BRK6E ("Break Cycle 6 End") starts during PHI2 of cycle 6 and ends during PHI1 of cycle 7. This is done to determine the edge of the /NMI signal.

The detection of the /NMI edge is done by a classic edge detection circuit based on two RS triggers.

The /RES signal is additionally stored on RESET FLIP/FLOP, because it is required for other random logic circuits (particularly for special control of the R/W pin).

The arrival of any interrupt is reflected on flag B, the output of which (`B_OUT`) forces the processor to execute a BRK instruction (operation code 0x00). This way the developers have unified the handling of all interrupts.

The last small circuit forms the address (or vector) of the interrupts (control signals 0/ADL0, 0/ADL1 and 0/ADL2), which control the lowest 3 bits of the address bus.

Schematic for setting the address of the interrupt handler:

![int_address_logisim](/BreakingNESWiki/imgstore/6502/int_address_logisim.jpg)

## Optimized Schematics

![17_interrupt_logic](/BreakingNESWiki/imgstore/6502/ttlworks/17_interrupt_logic.png)

# Random Logic

![6502_locator_random](/BreakingNESWiki/imgstore/6502/6502_locator_random.jpg)

The name has nothing to do with random numbers, it simply reflects the essence of randomly scattered circuits here and there.

This logic is the thinking organ of the processor and completely determines its behavior when processing and executing instructions.

From the hardware point of view, the random logic is a "handmade" product of MOS engineers, which is a mess of transistors and wires. Therefore, it would be more correct to use the name "chaotic logic" instead of random logic.

There is no need to give a full-size transistor circuit here, because it will be easier to master it by component parts.

Below you can see all the function blocks of the random logic:
- [Register control](#registers-control)
- [ALU control](#alu-control)
- [Program counter (PC) control](#program-counter-control)
- [Bus control](#bus-control)
- [Execution logic (dispatch)](#dispatcher)
- [Flags control logic](#flags-control)
- [Flags](#flags)
- [Conditional branch logic](#branch-logic)

Overview schematic:

![random_logic_logisim](/BreakingNESWiki/imgstore/6502/random_logic_logisim.jpg)

## Principle of Operation

In general, the operation of the logic is quite complex (did you think I would say simple again? :smiley:):
- The execution logic (dispatch) conducts the work of the entire processor. It determines when to terminate an instruction and also controls the PC increment and the cycle counter. Additionally it includes a processor readiness circuit (RDY) which is controlled by the RDY pin.
- After the execution logic has started executing the next instruction - the code of that instruction as well as the current cycle is fed to the decoder
- Depending on the results of decoding the control circuitry of registers, ALU, PC and buses give outward to the lower part special [control commands](#control-commands)
- Additionally, the behavior of the processor is affected by its flags as well as interrupt handling logic. And flags are also affected by executable instructions.

All this is closely coupled to control the lower part of the processor, where its context (registers), ALU and communication with the outside world via buses are located.

## Auxiliary Signals

This section contains a table of auxiliary signals exchanged between all parts of the random logic (for reference):

|Name|From|To|Description|
|---|---|---|---|
|ACRL1|Dispatch|Dispatch|One of the ACR Latch outputs|
|ACRL2|Dispatch|Bus Control|One of the ACR Latch outputs|
|AND|ALU Control|Bus Control|Used when forming an ALU `ANDS` command|
|BR2|Decoder|PC Control, PC Increment|Branch T2|
|BR3|Decoder|PC Control, PC Increment|Branch T3|
|BRFW|Branch Logic, ALU Control|PC Control|Branch forward (whenever taken)|
|BRK5|Decoder|Interrupts, Regs Control|Used to obtain the `STKOP` signal and also goes into the [interrupt handling](#interrupt-processing) circuit|
|BRK6E|Interrupts|ALU Control, Bus Control|BRK6 (cycle 6 of the interrupt sequence), during the half-step PHI2|
|/BRTAKEN|Branch Logic|PC Control|Branch taken|
|C_OUT|Flags|ALU Control|Flag C value|
|/C_OUT|Flags|ALU Control|Flag C value (inverted)|
|DL/PCH|PC Control|Bus Control|Intermediate signal|
|D_OUT|Flags|ALU Control|Flag D value|
|JSR2|Decoder|Regs Control, ALU Control, Bus Control|To obtain the `JSXY` signal and other bus control circuits|
|/JSR2|Bus Control|Regs Control|Intermediate signal, JSR2 inversion|
|IMPL|Decoder|ALU Control|Decoder X128. Additionally modified with Push/Pull (X129) and IR0 signals.|
|INC_SB|ALU Control|Bus Control|Intermediate signal ("Increment SB")|
|NOADL|Bus Control|ALU Control|Intermediate signal ("No ADL")|
|PC/DB|PC Control|Dispatch|Auxiliary output signal for the RW Control circuit that is part of the dispatcher|
|PGX|Bus Control|ALU Control|Intermediate signal ("Page X")|
|/ready|Dispatch|All|Global internal processor readiness signal|
|RTI/5|Decoder|Regs Control, ALU Control|Used to obtain `STKOP` and `NOADL` signals|
|#SBXY|Regs Control|Bus Control|Intermediate signal ("SB Bus X,Y")|
|STK2|Decoder|Regs Control, ALU Control|Auxiliary signal from decoder (X35)|
|STKOP|Regs Control|ALU Control|Intermediate signal ("Stack Operation")|
|STOR|Dispatcher|Regs Control, ALU Control, RW Control|Intermediate signal|
|STXY|Regs Control|Bus Control|Intermediate signal ("Store X,Y")|
|T0|Short Cycle Counter|All|Processor in the T0 instruction execution cycle|
|T1|PC Control|All|Processor in the T1 cycle|
|T2|Decoder|All|Processor in the T2 cycle|
|T6 RMW|Long Cycle Counter|All|Processor in cycle RMW T6 (the name `T5` is the old name of the signal)|
|T7 RMW|Long Cycle Counter|All|Processor in cycle RMW T7 (the name `T6` is the old name of the signal)|
|ZTST|Bus Control|Flags Control|Intermediate signal ("Z Test")|

Do not look for any sacred meaning in the auxiliary signals - just take them as intermediate values of combinatorial logic.

# Registers Control

![6502_locator_regs_control](/BreakingNESWiki/imgstore/6502/6502_locator_regs_control.jpg)

Most likely this control circuit will be observed first, so I will write here: be prepared to see a large number of intermediate signals in the control circuits, which can come sometimes from all other parts of the random logic. A summary table of all the intermediate signals can be found in the main section with the [random logic overview](#random-logic).

The register control circuit is responsible for generating [control commands](#control-commands) to exchange registers with the internal buses.

![regs_control](/BreakingNESWiki/imgstore/6502/regs_control.jpg)

Inputs:

|Signal|Description|
|---|---|
|X0-X26|Outputs from the decoder|
|/JSR2|Intermediate signal from the [bus control circuit](#bus-control)|
|STK2|Just an auxiliary signal from another part of the decoder (X35)|
|STOR|Auxiliary signal from the [dispatcher circuit](#dispatcher)|
|/ready|Global processor readiness signal|

Outputs:

|Signal|Description|
|---|---|
|#SBXY|Intermediate signal for [bus control circuitry](#bus-control)|
|STXY|Intermediate signal for bus control circuitry|
|STKOP|Intermediate signal ("Stack Operation") for the [ALU control circuit](#alu-control)|
|#Y/SB|Intermediate signal to latch, to obtain a Y/SB command|
|#X/SB|Intermediate signal to latch, to obtain a X/SB command|
|#SB/X|Intermediate signal to latch, to obtain a SB/X command|
|#SB/Y|Intermediate signal to latch, to obtain a SB/Y command|
|#S/SB|Intermediate signal to latch, to obtain a S/SB command|
|#S/ADL|Intermediate signal to latch, to obtain a S/ADL command|
|#SB/S|Intermediate signal to latch, to obtain a SB/S command|
|BRK5|Output X22 from decoder. Used to obtain the `STKOP` signal and also goes to the [interrupt circuitry](#interrupt-processing)|
|RTI/5|Output X26 from decoder. Used to obtain `STKOP` and `NOADL` signals|

The `TXS` (X13) signal is used within this circuit and does not go outside.

The intermediate signals from the register control circuitry go to the input of the control command latches:

![regs_control_commands_tran](/BreakingNESWiki/imgstore/6502/regs_control_commands_tran.jpg)

Register control commands:

|Command|Description|
|---|---|
|X/SB|Place the value of register X on the SB bus|
|Y/SB|Place the value of register Y on the SB bus|
|SB/X|Place the SB bus value on the X register|
|SB/Y|Place the SB bus value on the Y register|
|S/SB|Place the value of register S on the SB bus|
|S/ADL|Place the value of register S on the ADL bus|
|SB/S|Place the SB bus value on the S register|
|S/S|Refresh the value of the S register. The S/S control command is obtained by a complement of the SB/S signal (active when the SB/S command is inactive)|

## Logic

![regs_control_logisim](/BreakingNESWiki/imgstore/6502/regs_control_logisim.jpg)

## Optimized Schematics

![26_regs_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/26_regs_control_logisim.png)

# ALU Control

![6502_locator_alu_control](/BreakingNESWiki/imgstore/6502/6502_locator_alu_control.jpg)

The [ALU](#alu) control is designed to generate ALU [control commands](#control-commands).

## Intermediate Signals

|/ROR|SR|AND|CSET|
|---|---|---|---|
|![alu_setup_ror_tran](/BreakingNESWiki/imgstore/6502/alu_setup_ror_tran.jpg)|![alu_setup_sr_tran](/BreakingNESWiki/imgstore/6502/alu_setup_sr_tran.jpg)|![alu_setup_and_tran](/BreakingNESWiki/imgstore/6502/alu_setup_and_tran.jpg)|![alu_setup_cset_tran](/BreakingNESWiki/imgstore/6502/alu_setup_cset_tran.jpg)|

Table of auxiliary and intermediate signals, which are found further in the schematics:

|Signal|Description|
|---|---|
|/ROR|Intermediate signal, used in the ADD/SB7 circuit|
|SR|Intermediate signal|
|AND|Intermediate signal|
|T0|Comes from the cycle counter of short instructions|
|T6 RMW|Comes from the cycle counter of long instructions|
|T7 RMW|Comes from the cycle counter of long instructions|
|/C_OUT|[Flag](#flags) C value (inverted value)|
|CSET|Intermediate signal ("Carry Set"), used in the main ALU control circuit|
|STK2|Decoder X35|
|RET|Decoder X47|
|SBC0|Decoder X51|
|JSR2|Decoder X48|
|/BR3|Decoder X93 (inverted value). The inversion circuit was lost somewhere in the optimization process.|
|BRK6E|Comes from the [interrupts processing](#interrupt-processing) circuit|
|STKOP|Comes from [register control](#registers-control) circuitry|
|/ready|Global internal processor readiness signal|
|INC_SB|Intermediate signal ("Increment SB"), used in the main control circuitry as well as in the [bus control](#bus-control) circuitry|
|JSR/5|Decoder X56|
|PGX|Comes from the bus control circuitry|
|NOADL|Comes from the bus control circuitry|
|BRFW|Comes from the conditional [branch logic](#branch-logic)|
|T1|Comes from the PC increment circuit (see [dispatcher](#dispatcher))|
|D_OUT|Flag D value|
|C_OUT|Flag C value|

## ALU Сontrol (Main Part)

The circuit is a mess of gates and 4 latches to generate the input carry for the ALU (control signal `/ACIN`).

![alu_setup_main_tran](/BreakingNESWiki/imgstore/6502/alu_setup_main_tran.jpg)

## BCD Correction Control

BCD correction is applied in the following cases:
- If the BCD mode is enabled with flag D and the current instruction `SBC` (control signal DSATemp)
- If the BCD mode is enabled with flag D and the current instruction `ADC` (control signal DAATemp)

![alu_setup_bcd_tran](/BreakingNESWiki/imgstore/6502/alu_setup_bcd_tran.jpg)

## ADD/SB7

The attentive reader will notice that the processor has support for bit rotation instructions (ROL/ROR). The additional processing associated with these instructions is just handled by this circuit.

![alu_setup_addsb7_tran](/BreakingNESWiki/imgstore/6502/alu_setup_addsb7_tran.jpg)

Logic:

![alu_control_addsb7](/BreakingNESWiki/imgstore/6502/alu_control_addsb7.jpg)

Optimized schematics:

![27_alu_control_addsb7](/BreakingNESWiki/imgstore/6502/ttlworks/27_alu_control_addsb7.png)

## ALU Control Commands

![alu_control_commands_tran](/BreakingNESWiki/imgstore/6502/alu_control_commands_tran.jpg)

|Command|Description|
|---|---|
|Setting the ALU input values||
|NDB/ADD|Load inverse value from DB bus to the BI latch|
|DB/ADD|Load direct value from DB bus to the BI latch|
|0/ADD|Write 0 to the AI latch|
|SB/ADD|Load a value from the SB bus to the AI latch|
|ADL/ADD|Load a value from the ADL bus to the BI latch|
|ALU operation commands||
|ANDS|Logical AND operation (AI & BI)|
|EORS|Logical XOR operation (AI ^ BI)|
|ORS|Logical OR operation (AI \| BI)|
|SRS|Shift Right|
|SUMS|Summation (AI + BI)|
|Control commands of the intermediate ALU result||
|ADD/SB06|Place the value of the ADD latch on the SB bus (bits 0-6)|
|ADD/SB7|Place the value of the ADD latch on the SB bus (bit 7)|
|ADD/ADL|Place the ADD latch value on the ADL bus|
|Additional signals||
|/ACIN|Input carry|
|/DAA|Perform correction after addition|
|/DSA|Perform correction after subtraction|

## Logic

![alu_control_logisim](/BreakingNESWiki/imgstore/6502/alu_control_logisim.jpg)

## Optimized Schematics

![28_alu_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/28_alu_control_logisim.png)

# Program Counter Control

![6502_locator_pc_control](/BreakingNESWiki/imgstore/6502/6502_locator_pc_control.jpg)

The program counter (PC) control circuitry is designed to generate [control commands](#control-commands) to exchange the PC value and the internal buses ADL, ADH and DB.

Nearby is the PC increment circuit, which is discussed in another section on [dispatcher](#dispatcher).

Transistor circuit for obtaining intermediate signals:

![pc_control_trans](/BreakingNESWiki/imgstore/6502/pc_control_trans.jpg)

Output latches and control commands:

![pc_control_commands_tran](/BreakingNESWiki/imgstore/6502/pc_control_commands_tran.jpg)

Inputs:

|Signal|Description|
|---|---|
|BR0|Decoder X73. Additionally modified with the /PRDY signal|
|BR2|Decoder X80|
|BR3|Decoder X93|
|T0|Comes from the cycle counter of short instructions|
|T1|Comes from the PC increment circuit (see [dispatcher](#dispatcher))|
|ABS/2|Decoder X83. Additionally modified with Push/Pull signal (X129)|
|RTS/5|Decoder X84|
|JSR/5|Decoder X56|
|/ready|Global internal processor readiness signal|

Outputs:

|Signal|Description|
|---|---|
|DL/PCH|Auxiliary output signal for DL/ADH [bus control circuitry](#bus-control)|
|PC/DB|Auxiliary output signal for the RW Control circuit that is part of the dispatcher|

Control commands:

|Command|Description|
|---|---|
|ADH/PCH|Load ADH bus value into the PCHS latch|
|PCH/PCH|If ADH/PCH is not running, this command is executed (refresh PCH)|
|PCH/ADH|Write the PCH register value to the ADH bus|
|PCH/DB|Write the PCH register value to the DB bus|
|ADL/PCL|Load the ADL bus value into the PCLS latch|
|PCL/PCL|If ADL/PCL is not running, this command is executed (refresh PCL)|
|PCL/ADL|Write the PCL register value to the ADL bus|
|PCL/DB|Write the PCL register value to the DB bus|

## Logic

![pc_control_logisim](/BreakingNESWiki/imgstore/6502/pc_control_logisim.jpg)

## Optimized Schematics

![23_pc_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/23_pc_control_logisim.png)

# Bus Control

![6502_locator_bus_control](/BreakingNESWiki/imgstore/6502/6502_locator_bus_control.jpg)

Bus control is most of all "scattered" around the processor surface. It is easiest to describe all the bus [control commands](#control-commands) first, and then to look at the corresponding circuits individually.

Bus control commands:

|Command|Description|
|---|---|
|External address bus control||
|ADH/ABH|Set the high 8 bits of the external address bus, in accordance with the value of the internal bus ADH|
|ADL/ABL|Set the low-order 8 bits of the external address bus, in accordance with the value of the internal bus ADL|
|ALU connection to SB, DB buses||
|AC/DB|Place the AC value on the DB bus|
|SB/AC|Place the value from the SB bus/BCD correction circuit into the accumulator|
|AC/SB|Place the AC value on the SB bus|
|Control of the SB, DB and ADH internal buses||
|SB/DB|Connect the SB and DB buses|
|SB/ADH|Connect SB and ADH buses|
|0/ADH0|Forced to clear the ADH\[0\] bit|
|0/ADH17|Forced to clear the ADH\[1-7\] bits|
|External data bus control||
|DL/ADL|Write the DL value to the ADL bus|
|DL/ADH|Write the DL value to the ADH bus|
|DL/DB|Exchange the value of the DL and the internal bus DB. The direction of the exchange depends on the operating mode of the external data bus (read/write)|

The motive of all the circuits is roughly as follows:
- The control circuits get a lot of input from the decoder and other auxiliary signals
- All circuits are mostly combinatorial (no triggers, just a mess of gates)
- The outputs from the control circuits go to the output latches of the commands to control the lower part of the processor.

## Auxiliary Signals

Circuits for obtaining auxiliary signals:

|NOADL, IND|JSXY|
|---|---|
|![bus_noadl_ind_tran](/BreakingNESWiki/imgstore/6502/bus_noadl_ind_tran.jpg)|![bus_jsxy_tran](/BreakingNESWiki/imgstore/6502/bus_jsxy_tran.jpg)|

In the `IND` circuit the decoder output X90 is additionally modified by the Push/Pull signal (X129).

The other auxiliary and intermediate signals that can be found in the schematics in this section:

|Signal|Description|
|---|---|
|RTS/5|Decoder X84|
|RTI/5|Decoder X26|
|STXY|Comes from [register control circuitry](#registers-control)|
|BR0|Decoder X73. Additionally modified with the /PRDY signal|
|T6 RMW|Comes from the cycle counter of long instructions|
|T7 RMW|Comes from the cycle counter of long instructions|
|PGX|Output signal from ADL/ABL circuit|
|JSR/5|Decoder X56|
|T2|Decoder X28|
|!PCH/PCH|Comes from the [PC control circuitry](#program-counter-control)|
|SBA|The signal comes out of the #SB/ADH circuit, used in the #ADH/ABH circuit|
|/ready|Global internal processor readiness signal|
|BR3|Decoder X93|
|0/ADL0|Comes from the interrupt vector setting circuit|
|AND|Comes from the [ALU control](#alu-control) circuit|
|STA|Decoder X79|
|STOR|Intermediate signal from the dispatcher|
|#SBXY|Comes from a register control circuit (not to be confused with STXY)|
|T1|Comes from the PC increment circuit (see [dispatcher](#dispatcher))|
|BR2|Decoder X80|
|ZTST|Output signal for [flags control](#flags-control) from SB/DB circuit|
|ACRL2|One of the ACR Latch outputs|
|T0|Comes from the cycle counter of short instructions|
|ABS/2|Decoder X83. Additionally modified with Push/Pull signal (X129)|
|JMP/4|Decoder X101|
|IMPL|Decoder X128. Additionally modified with Push/Pull (X129) and IR0 signals.|
|JSR2|Decoder X48|
|/JSR|Inversion of JSR2 for the register control circuit|
|BRK6E|Comes from the [interrupts processing](#interrupt-processing) circuit|
|INC_SB|Comes from the ALU control circuit|
|DL/PCH|Comes from the PC control circuitry|

The signals are arranged in the order they appear in the schematics.

## External Address Bus Control

Circuits for the generation of intermediate signals:

|#ADL/ABL|#ADH/ABH (1)|#ADH/ABH (2)|
|---|---|---|
|![bus_adlabl_tran](/BreakingNESWiki/imgstore/6502/bus_adlabl_tran.jpg)|![bus_adhabh_tran1](/BreakingNESWiki/imgstore/6502/bus_adhabh_tran1.jpg)|![bus_adhabh_tran2](/BreakingNESWiki/imgstore/6502/bus_adhabh_tran2.jpg)|

The first piece of the #ADH/ABH circuit is to the right of flag B, the second piece is in the interrupt address generation circuitry. The #ADH/ABH signal connects directly between these two pieces.

The output latches of the ADL/ABL and ADH/ABH control commands:

![bus_addr_bus_commands_tran](/BreakingNESWiki/imgstore/6502/bus_addr_bus_commands_tran.jpg)

## ALU Connection to SB, DB

Circuits for the generation of intermediate signals:

|#AC/DB|#SB/AC, #AC/SB|
|---|---|
|![bus_acdb_tran](/BreakingNESWiki/imgstore/6502/bus_acdb_tran.jpg)|![bus_acsb_tran](/BreakingNESWiki/imgstore/6502/bus_acsb_tran.jpg)|

AC/DB, SB/AC, AC/SB control command output latches:

![bus_alu_commands_tran](/BreakingNESWiki/imgstore/6502/bus_alu_commands_tran.jpg)

## SB, DB, ADH Control

Circuits for generating intermediate signals (for 0/ADH0 you get the control command at once):

|#SB/DB (also #0/ADH17)|0/ADH0|#SB/ADH|
|---|---|---|
|![bus_control_tran1](/BreakingNESWiki/imgstore/6502/bus_control_tran1.jpg)|![bus_0adh0_tran](/BreakingNESWiki/imgstore/6502/bus_0adh0_tran.jpg)|![bus_sbadh_tran](/BreakingNESWiki/imgstore/6502/bus_sbadh_tran.jpg)|

SB/DB, SB/ADH, 0/ADH17 control command output latches:

![bus_sb_commands_tran](/BreakingNESWiki/imgstore/6502/bus_sb_commands_tran.jpg)

(0/ADH0 above)

## External Data Bus Control

Circuits for the generation of intermediate signals:

|#DL/ADL|#DL/DB (1)|#DL/DB (2)|
|---|---|---|
|![bus_dladl_tran](/BreakingNESWiki/imgstore/6502/bus_dladl_tran.jpg)|![bus_dldb_tran](/BreakingNESWiki/imgstore/6502/bus_dldb_tran.jpg)|![bus_dldb_tran2](/BreakingNESWiki/imgstore/6502/bus_dldb_tran2.jpg)|

The first piece of #DL/DB circuitry is next to the ACR Latch, the second piece is right inside the ALU control circuitry. The #DL/DB signal connects directly between these two pieces.

DL/ADL, DL/ADH, DL/DB control command output latches:

![bus_data_latch_commands_tran](/BreakingNESWiki/imgstore/6502/bus_data_latch_commands_tran.jpg)

## Logic

![bus_control_logisim](/BreakingNESWiki/imgstore/6502/bus_control_logisim.jpg)

## Optimized Schematics

![7_bus_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/7_bus_control_logisim.png)

# Dispatcher

![6502_locator_dispatch](/BreakingNESWiki/imgstore/6502/6502_locator_dispatch.jpg)

The execution logic (dispatcher or sequencer) is the key mechanism of the processor that "directs" the execution of instructions.

![DispatchUnit](/BreakingNESWiki/imgstore/6502/DispatchUnit.png)

The execution logic consists of the following circuits:
- Intermediate signals
- Processor readiness control and R/W Mode
- Short instruction cycle counter (T0-T1)
- Cycle counter for very long instructions (RMW T6-T7)
- Instruction completion circuit
- ACR latch
- Program counter (PC) increment circuit
- Opcode fetch circuit (Fetch)

[Long instruction cycle counter](#extended-cycle-counter) (T2-T5) is discussed in the corresponding section.

:warning: This processor module is very messy and contains many cycles. Signals come in from practically everywhere and also go out to practically every place. The transistor circuits are "spread out" in an even layer in between the rest of the Random Logic.

## Intermediate Signals

Intermediate signals are obtained from the decoder outputs without any regularity. It was very difficult to separate them from the intermediate signals of the other control circuits, because of the chaotic connections.

|BR2|BR3, D91_92|/MemOP|STORE, STOR|/SHIFT|
|---|---|---|---|---|
|![dispatch_br2_tran](/BreakingNESWiki/imgstore/6502/dispatch_br2_tran.jpg)|![dispatch_br3_tran](/BreakingNESWiki/imgstore/6502/dispatch_br3_tran.jpg)|![dispatch_memop_tran](/BreakingNESWiki/imgstore/6502/dispatch_memop_tran.jpg)|![dispatch_store_tran](/BreakingNESWiki/imgstore/6502/dispatch_store_tran.jpg)|![dispatch_shift_tran](/BreakingNESWiki/imgstore/6502/dispatch_shift_tran.jpg)|

## Processor Readiness and R/W Mode

![dispatch_ready_tran](/BreakingNESWiki/imgstore/6502/dispatch_ready_tran.jpg)

![dispatch_rw_tran](/BreakingNESWiki/imgstore/6502/dispatch_rw_tran.jpg)

![DispReadyRW](/BreakingNESWiki/imgstore/6502/DispReadyRW.jpg)

- /ready: global ready signal of the processor, derived from the `RDY` input signal which comes from the corresponding terminal.
- REST: Reset cycle counters
- WR: The processor is in write mode

## Short Cycle Counter

![dispatch_short_cycle_tran](/BreakingNESWiki/imgstore/6502/dispatch_short_cycle_tran.jpg)

![DispShortCycle](/BreakingNESWiki/imgstore/6502/DispShortCycle.jpg)

- T0: Internal signal (processor in T0 cycle)
- /T0, /T1X: Coming to [decoder](#decoder) input

## Very Long Cycle Counter

![dispatch_long_cycle_tran](/BreakingNESWiki/imgstore/6502/dispatch_long_cycle_tran.jpg)

![DispRMWCycle](/BreakingNESWiki/imgstore/6502/DispRMWCycle.jpg)

- T6, T7: The processor is in the RMW cycle T6/T7

## Instruction Completion

![dispatch_ends_tran](/BreakingNESWiki/imgstore/6502/dispatch_ends_tran.jpg)

- ENDS: Complete the short instructions

![dispatch_endx_tran](/BreakingNESWiki/imgstore/6502/dispatch_endx_tran.jpg)

- ENDX: Complete long instructions

![dispatch_tresx_tran](/BreakingNESWiki/imgstore/6502/dispatch_tresx_tran.jpg)

- #TRESX: Reset Cycle Counters

![dispatch_tres2_tran](/BreakingNESWiki/imgstore/6502/dispatch_tres2_tran.jpg)

- TRES2: Reset [extra instruction counter](#extended-cycle-counter)

![DispCompletionUnit](/BreakingNESWiki/imgstore/6502/DispCompletionUnit.jpg)

## ACR Latch

![dispatch_acr_latch_tran](/BreakingNESWiki/imgstore/6502/dispatch_acr_latch_tran.jpg)

![DispACRLatch](/BreakingNESWiki/imgstore/6502/DispACRLatch.jpg)

Outputs 2 internal intermediate signals: ACRL1 and ACRL2.

## Increment PC

![dispatch_pc_tran](/BreakingNESWiki/imgstore/6502/dispatch_pc_tran.jpg)

![DispIncrementPC](/BreakingNESWiki/imgstore/6502/DispIncrementPC.jpg)

The circuit contains 3 "branches" of combinatorial logic, which finally form the [control command](#control-commands) to increment PC (`#1/PC`).

There is also a circuit nearby to generate the following signals:
- T1: Processor in cycle T1
- TRES1: Reset short instruction cycle counter

## Opcode Fetch

![dispatch_fetch_tran](/BreakingNESWiki/imgstore/6502/dispatch_fetch_tran.jpg)

![DispFetch](/BreakingNESWiki/imgstore/6502/DispFetch.jpg)

- FETCH: Fetch opcode to [instruction register](#instruction-register)
- 0/IR: Inject `BRK` operation code, for [interrupt handling](#interrupt-processing)

## Logic (old all-in-one version)

![dispatcher_logisim](/BreakingNESWiki/imgstore/6502/dispatcher_logisim.jpg)

## Optimized Schematics

![13_dispatcher_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/13_dispatcher_logisim.png)

# Flags Control

![6502_locator_flags_control](/BreakingNESWiki/imgstore/6502/6502_locator_flags_control.jpg)

The flag control circuits are divided into two parts for convenience:
- Intermediate control signals from the decoder (opcode selection)
- Flag control signals

As you can guess, the purpose of the circuit is to control [processor flags](#flags), depending on the currently executed instruction.

I think it makes sense to show here the relevant part of the wonderful 6502 circuit made by Donald F. Hanson:

![flags_control_hanson](/BreakingNESWiki/imgstore/6502/flags_control_hanson.jpg)

(The missing `0/V` signal has been corrected in the schematic)

## Opcode Selection

|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran1.jpg)|![flags_control_tran2](/BreakingNESWiki/imgstore/6502/flags_control_tran2.jpg)|![flags_control_tran3](/BreakingNESWiki/imgstore/6502/flags_control_tran3.jpg)|
|---|---|---|

Input signals:

- /T0: Processor executes cycle T0 of the current instruction
- /T1X: Processor executes T1 cycle of the current instruction
- T7 RMW: Processor executes T7 cycle of current instruction (RMW)

Output signals:

|Signal|Decoder outputs|Dedicated instructions|
|---|---|---|
|!POUT|98,99|Working with flags outward (saving context after interrupt, `PHP` instruction)|
|/CSI|108|Instructions `CLI`, `SEI`|
|BIT1|109|Instruction `BIT`, cycle T1|
|X110|110|The 110th decoder output (instructions `CLC`, `SEC`), for convenience is left in these circuits. It just goes on to the main flag control circuitry.|
|AVR/V|112|Instructions `ADC`, `SBC`. This signal is the control signal for [flag V](#flags)|
|/ARIT|107,112,116-119|Matrix of comparison (`CMP`, `CPX`, `CPY`) and shift instructions (`ASL`, `ROL`) where flags are used|
|BIT0|113|Instruction `BIT`, cycle T0|
|!PIN|114,115|Working with flags inside (context loading after `RTI`, instruction `PLP`)|
|/CSD|120|Instructions `CLD`, `SED`|
|CLV|127|Instruction `CLV`|

All of these control signals (except `AVR/V`) are intermediate signals and are not used anywhere else except for the flag control circuitry.

## Flags Control

|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran4.jpg)|![flags_control_tran1](/BreakingNESWiki/imgstore/6502/flags_control_tran5.jpg)|
|---|---|

Input signals:

|Signal|Purpose|
|---|---|
|/CSI|see above|
|X110|see above|
|!POUT|see above|
|BIT1|see above|
|ZTST|Comes from SB/DB [bus control circuitry](#bus-control)|
|/ARIT|see above|
|SR|Shift instruction from [ALU control logic](#alu-control)|
|/ready|Global internal processor readiness signal|
|!PIN|see above|
|BIT0|see above|
|/CSD|see above|
|CLV|see above|

Output [Flag](#flags) control signals:

|Signal|Flag|Purpose|
|---|---|---|
|IR5/C|C|Change the value of the flag according to the IR5 bit|
|ACR/C|C|Change the value of the flag according to the ACR value|
|DB/C|C|Change the value of the flag according to DB0 bit|
|DBZ/Z|Z|Change the value of the flag according to the /DBZ value|
|IR5/I|I|Change the value of the flag according to the IR5 bit|
|IR5/D|D|Change the value of the flag according to the IR5 bit|
|DB/V|V|Change the value of the flag according to DB6 bit|
|0/V|V|Clear flag V|
|DB/N|N|Change the value of the flag according to DB7 bit|
|P/DB|All|Place the value of the flags register P on the DB bus|
|DB/P|All|Place the DB bus value on the flag register P|

The control signal `1/V` is obtained by the input contact `SO` and is not shown here.

## Logic

![flags_control_logisim](/BreakingNESWiki/imgstore/6502/flags_control_logisim.jpg)

## Optimized Schematics

![16_flags_control_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/16_flags_control_logisim.png)

# Flags

![6502_locator_flags](/BreakingNESWiki/imgstore/6502/6502_locator_flags.jpg)

The flags (bits of the P register) are in "scattered" form, as several circuits of the upper part of the processor.

The flags are controlled by the [flags control](#flags-control) circuit.

Flag B is treated separately in the section on [interrupt handling](#interrupt-processing). Topologically it is also located in another part of the processor.

## C Flag

![flag_c_tran](/BreakingNESWiki/imgstore/6502/flag_c_tran.jpg)

- IR5/C: Change the flag value according to the IR5 bit (applies during execution of the `SEC` and `CLC` instructions)
- ACR/C: Change the flag value according to the ACR value
- DB/C: Change the value of the flag according to the bit DB0
- /IR5: Inverted IR5 value
- /DB0: Input value from DB bus, in inverted form
- ACR: Result of a carry from the ALU
- /ACR: The result of the carry from the ALU, in inverted form. Also used in [dispatcher](#dispatcher)
- /C_OUT: Output value of flag C, in inverted form

## D Flag

![flag_d_tran](/BreakingNESWiki/imgstore/6502/flag_d_tran.jpg)

- IR5/D: Change the flag value according to the IR5 bit (applied during execution of `SED` and `CLD` instructions)
- DB/P: Common control signal, place the DB bus value on the flag register P
- /IR5: IR5 bit value, in inverted form
- /DB3: Input value from the DB bus, in inverted form
- /D_OUT: Output value of flag D, in inverted form

## I Flag

![flag_i_tran](/BreakingNESWiki/imgstore/6502/flag_i_tran.jpg)

- IR5/I: Change the flag value according to the IR5 bit (applied during execution of `SEI` and `CLI` instructions)
- DB/P: Common control signal, place the DB bus value on the flag register P
- /IR5: IR5 bit value, in inverted form
- /DB2: Input value from the DB bus, in inverted form
- /I_OUT: Output value of flag I, in inverted form. This signal goes to two places: to the interrupt processing circuit and to the circuit for exchanging flag register values with the DB bus (below).

The `/I_OUT` signal is further modified by the `BRK6E` signal in flag B circuitry:

![intr_b_flag_tran](/BreakingNESWiki/imgstore/6502/intr_b_flag_tran.jpg)

## N Flag

![flag_n_tran](/BreakingNESWiki/imgstore/6502/flag_n_tran.jpg)

- DB/N: Change the flag value according to DB7
- /DB7: Input value from DB bus, in inverted form
- /N_OUT: Output value of flag N, in inverted form

## V Flag

![flag_v_tran](/BreakingNESWiki/imgstore/6502/flag_v_tran.jpg)

- 0/V: Clear flag V (applies during execution of `CLV` instructions)
- 1/V: Set flag V. Forced flag setting is done by the `SO` pin.
- AVR/V: Change the value of the flag according to the AVR value
- DB/V: Change the flag value according to DB6
- AVR: Overflow result from the ALU
- SO: Input value from pin `SO`
- /DB6: Input value from DB bus, in inverted form
- /V_OUT: Output value of flag V, in inverted form

## Z Flag

![flag_z_tran](/BreakingNESWiki/imgstore/6502/flag_z_tran.jpg)

- DBZ/Z: Change the flag value according to the /DBZ value
- DB/P: Common control signal, place the DB bus value on the flag P register
- /DBZ: Control signal from the flag exchange circuit with the DB bus (check that all bits of the DB bus are 0)
- /DB1: Input value from the DB bus, in inverted form
- /Z_OUT: Output value of flag Z, in inverted form

## Flags I/O

![flags_io_tran](/BreakingNESWiki/imgstore/6502/flags_io_tran.jpg)

- C_OUT: Flag C value in direct form, used in [ALU control circuit](#alu-control) (in the circuit to form the `ADD/SB7` signal)
- D_OUT: Flag D value in direct form, used in the ALU control circuit (to form BCD correction signals DAA/DSA)
- P/DB: Place the P flag register value on the DB bus
- /DB0-7: The value of the DB bus bits, in inverted form. It is fed to the input of the corresponding bits of the P register.
- /DBZ: Check that all DB bus bits are 0 (i.e. checking the value to 0). It is used by the Z flag.

Correspondence of the bits of the DB bus and the flag register P:

|DB Bit|Flag|
|---|---|
|0|C|
|1|Z|
|2|I|
|3|D|
|4|B|
|5|-|
|6|V|
|7|N|

"Crazy Zebra I Dont Bother Very Nice"

Flag 5 is not used. The DB5 bit is not changed (not connected) when saving the register P to the DB bus. However, the value of the DB5 bit is checked by the `/DBZ` control signal (to compare the value on the DB bus with zero).

## Logic

![flags_logisim](/BreakingNESWiki/imgstore/6502/flags_logisim.jpg)

## Optimized Schematics

![15_flags_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/15_flags_logisim.png)

# Branch Logic

![6502_locator_branch](/BreakingNESWiki/imgstore/6502/6502_locator_branch.jpg)

The logic of conditional branches determines:
- Whether the branch went forward or backward
- Whether a branch occurred at all

The branch direction is determined by the 7th bit of the branch instruction operand (relative offset) which is stored on the internal data bus (DB). If the 7th bit is 1, it means that branch is made "backwards" (PC = PC - offset).

The branch is checked according to the branch instruction (which differs by 6 and 7 bit of the operation code) as well as the flags: C, V, N, Z.

## Branch Forward

![branch_forward_tran](/BreakingNESWiki/imgstore/6502/branch_forward_tran.jpg)

The BRFW trigger is updated with the value D7 during BR3.PHI1. The rest of the time the trigger stores its current value. The value of the trigger is output as a `BRFW` control signal to the [Program Counter (PC) control circuit](#program-counter-control).

The `BR2` is the X80 output of the decoder.

## Branch Taken

![branch_taken_tran](/BreakingNESWiki/imgstore/6502/branch_taken_tran.jpg)

The combinatorial logic first selects by IR6/IR7 which group the branch instruction belongs to (i.e. which flag it checks) and the subsequent XOR selects how the branch instruction is triggered (flag set/reset). 
The output of `/BRTAKEN` is in inverse logic, that is, if branch is triggered, then /BRTAKEN = 0. The consumer of the /BRTAKEN signal is also the PC control circuit.

Inputs `/IR6` and `/IR7` are decoder outputs X121 and X126 respectively. The `/IR5` input comes directly from the [instruction register](#instruction-register).

Note: The Branch Taken logic operates continuously and the value of the /BRTAKEN control line is updated every cycle, regardless of which instruction is being processed by the processor at the time.

## Logic

![branch_logic_logisim](/BreakingNESWiki/imgstore/6502/branch_logic_logisim.jpg)

## Optimized Schematics

![6_branch_logic_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/6_branch_logic_logisim.png)

# Control Commands

![6502_locator_controls](/BreakingNESWiki/imgstore/6502/6502_locator_controls.jpg)

"Control Commands" is the conventional name for the large number of control signals that go from the top of the processor to the bottom and control the context (registers, buses) and ALU.

![6502_controls_tran1](/BreakingNESWiki/imgstore/6502/6502_controls_tran1.jpg)

![6502_controls_tran2](/BreakingNESWiki/imgstore/6502/6502_controls_tran2.jpg)

![6502_controls_tran3](/BreakingNESWiki/imgstore/6502/6502_controls_tran3.jpg)

![6502_controls_tran4](/BreakingNESWiki/imgstore/6502/6502_controls_tran4.jpg)

The control commands for the flag register are discussed in the corresponding section on [flag management](#flags-control), since they do not go beyond the top of the processor.

Each control signal usually contains an output latch and sometimes a special "cutoff" transistor that turns the signal off at a certain half-cycle (usually some of the signals are turned off during PHI2). This is because the internal buses are pre-charged during PHI2, and the registers are usually "refreshed" at that time.

Most signals have names like `A/B` which means that the line "connects" `A` to `B`. For example SB/X means that the value from the internal bus SB is placed in register X.

## List

All commands are discussed in more detail in their respective sections. The summary table is just for reference.

|Name|PHI1|PHI2|Description|
|---|---|---|---|
|Register control commands||||
|Y/SB|√| |Y => SB|
|SB/Y|√| |SB => Y|
|X/SB|√| |X => SB|
|SB/X|√| |SB => X|
|S/ADL|√|√|S => ADL|
|S/SB|√|√|S => SB|
|SB/S|√| |SB => S|
|S/S|√| |The S/S command is active if the SB/S command is inactive. This command simply "refreshes" the current state of the S register.|
|ALU control commands||||
|NDB/ADD|√| |~DB => BI|
|DB/ADD|√| |DB => BI|
|0/ADD|√| |0 => AI|
|SB/ADD|√| |SB => AI|
|ADL/ADD|√| |ADL => BI|
|/ACIN|√|√|ALU input carry. The ALU also returns the result of carry (`ACR`) and overflow (`AVR`)|
|ANDS|√|√|AI & BI|
|EORS|√|√|AI ^ BI|
|ORS|√|√|AI \| BI|
|SRS|√|√|>>= 1|
|SUMS|√|√|AI + BI|
|/DAA|√|√|0: Perform BCD correction after addition|
|/DSA|√|√|0: Perform BCD correction after subtraction|
|ADD/SB7|√|√|ADD\[7\] => SB\[7\]|
|ADD/SB06|√|√|ADD\[0-6\] => SB\[0-6\]|
|ADD/ADL|√|√|ADD => ADL|
|SB/AC|√| |SB => AC|
|AC/SB|√| |AC => SB|
|AC/DB|√| |AC => DB|
|Program counter (PC) control commands||||
|#1/PC|√|√|0: Increment the program counter|
|ADH/PCH|√| |ADH => PCH|
|PCH/PCH|√| |If ADH/PCH is not performed, this command is performed (refresh PCH)|
|PCH/ADH|√|√|PCH => ADH|
|PCH/DB|√|√|PCH => DB|
|ADL/PCL|√| |ADL => PCL|
|PCL/PCL|√| |If ADL/PCL is not performed, this command is performed (refresh PCL)|
|PCL/ADL|√|√|PCL => ADL|
|PCL/DB|√|√|PCL => DB|
|Bus control commands||||
|ADH/ABH|√|√|ADH => ABH|
|ADL/ABL|√|√|ADL => ABL|
|0/ADL0, 0/ADL1, 0/ADL2|√|√|Reset some of the ADL bus bits. Used to set the interrupt vector.|
|0/ADH0, 0/ADH17|√|√|Reset some of the ADH bus bits|
|SB/DB|√|√|SB <=> DB, connect the buses|
|SB/ADH|√|√|SB <=> ADH, connect the buses|
|DL latch control commands||||
|DL/ADL|√|√|DL => ADL|
|DL/ADH|√|√|DL => ADH|
|DL/DB|√|√|DL <=> DB|

## ADD/SB7

Be careful, all output values are inverse latch values, except for `ADD/SB7`.

## "Other" PHI2 (/PHI1)

On the left side is a small circuit to pull up PHI2 (which is used by a lot of cutoff transistors, so it must be quite powerful):

![phi2_pullup_tran](/BreakingNESWiki/imgstore/6502/phi2_pullup_tran.jpg)

Optimized logic diagram with explanations:

![9_context_control_gating](/BreakingNESWiki/imgstore/6502/ttlworks/9_context_control_gating.png)

## Command Priority

Although in a real processor all commands are "executed" at the same time, it is still possible to outline some priority that the developers have laid down.

The commands on the bottom of the 6502, in order of execution:

PHI1 "Set Address and R/W Mode":

- Loading on the bus from DL: DL_DB, DL_ADL, DL_ADH
- Registers to the SB bus: Y_SB, X_SB, S_SB
- Saving flags on the DB bus: P_DB
- ADD saving on SB/ADL: ADD_SB7, ADD_SB06, ADD_ADL
- Saving AC: AC_SB, AC_DB
- Saving of old stack pointer value to ADL bus: S_ADL
- Increment PC: n_1PC
- Saving PC to bus: PCL_ADL, PCH_ADH, PCL_DB, PCH_DB
- Bus multiplexing: SB_DB, SB_ADH
- Constant generator: Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17
- Loading ALU operands: NDB_ADD, DB_ADD, Z_ADD, SB_ADD, ADL_ADD
- BCD correction via SB bus: SB_AC
- Loading flags: DB_P, DBZ_Z, DB_N, IR5_C, DB_C, IR5_D, IR5_I, DB_V, Z_V, ACR_C, AVR_V
- Loading registers: SB_X, SB_Y, SB_S / S_S
- Load PC from bus or keep old value: ADH_PCH/PCH_PCH, ADL_PCL/PCL_PCL
- Saving DB to DOR
- Set external bus address: ADH_ABH, ADL_ABL

PHI2 "Read/Write Data":

- Loading the DL with a value from the external data bus
- Registers on SB bus: S_SB
- Saving flags to the DB bus: P_DB
- ALU operation: ANDS, EORS, ORS, SRS, SUMS, n_ACIN, n_DAA, n_DSA
- ADD saving on SB/ADL: ADD_SB7, ADD_SB06, ADD_ADL
- Saving old stack pointer value to ADL bus: S_ADL
- Increment PC: n_1PC (PC is incremented in this half-cycle)
- Saving PC to bus: PCL_ADL, PCH_ADH, PCL_DB, PCH_DB
- Bus multiplexing: SB_DB, SB_ADH
- Constant generator: Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17
- Loading flags: DB_P, DBZ_Z, DB_N, IR5_C, DB_C, IR5_D, IR5_I, DB_V, Z_V, ACR_C, AVR_V
- Setting external data bus from DOR: If WR = 1

# Address Bus

![6502_locator_addr](/BreakingNESWiki/imgstore/6502/6502_locator_addr.jpg)

Although the 6502 communicates with the outside world on a 16-bit address bus, but because the processor is 8-bit in nature, the address bus is internally divided into two 8-bit halves: an upper (ADH) and a lower (ADL).

The internal ADH/ADL address bus connects to the external 16-bit bus (pins A0-A15) through registers ABH/ABL, which contain the last written value (address that has been set).

The address bus is unidirectional. It can only be controlled by the 6502.

Transistor circuit of the lower bits of the ABL (0-2):

![abl02_tran](/BreakingNESWiki/imgstore/6502/abl02_tran.jpg)

(The schematic is the same for ABL1 and ABL2 bits)

The remaining ABL bits (3-7):

![abl37_tran](/BreakingNESWiki/imgstore/6502/abl37_tran.jpg)

ABH bits:

![abh_tran](/BreakingNESWiki/imgstore/6502/abh_tran.jpg)

Control commands:

- 0/ADL0, 0/ADL1, 0/ADL2: The lower 3 bits of the ADL bus can be forced to zero by commands when setting [interrupts vector](#interrupt-processing)
- ADL/ABL: Place the value of the internal ADL bus on the ABL register
- ADH/ABH: Place the ADH internal bus value on the ABH register

:warning: As time passed, it turned out that FET where 0/ADL0, 0/ADL1, 0/ADL2 commands are used is more convenient to make a part of [Bus Multiplexer](#bus-multiplexer) circuit.

## Circuit Flow

Consider the behavior of the circuit when ADL = 0:

![abl_flow_tran](/BreakingNESWiki/imgstore/6502/abl_flow_tran.jpg)

- The flip/flop of the ABL bit is organized on two inverters (not2 and not3) with not2 acting simultaneously as a DLatch (whose input Enable is connected to PHI2)
- PHI2: FF is "refreshed" in this half-step.
- PHI1: In this half-step the old FF value is "cut off" by the PHI2 tristate (located to the left of not2) and the new FF value is loaded from the ADL bus (inverted, see not1) but only if an ADL/ABL command is active
- The output from not2 organizes the final generation of the output value for the external address bus. This part of the circuit contains an inverter not3 to form the FF and also an inverter not4 which controls the amplifier "comb" of the Ax contacts

## Logic

On the logic circuits PHI2 is not used, and FF organized on two inverters is replaced by a regular trigger.

![abl02_logisim](/BreakingNESWiki/imgstore/6502/abl02_logisim.jpg)

![abl_logisim](/BreakingNESWiki/imgstore/6502/abl_logisim.jpg)

![abh_logisim](/BreakingNESWiki/imgstore/6502/abh_logisim.jpg)

## Optimized Schematics

![0_abl02_tran](/BreakingNESWiki/imgstore/6502/ttlworks/0_abl02_tran.png)

# Data Bus

![6502_locator_data](/BreakingNESWiki/imgstore/6502/6502_locator_data.jpg)

The circuits for working with the external data bus consist of 8 identical pieces:

![6502_data_bit_tran](/BreakingNESWiki/imgstore/6502/data_bit_tran.jpg)

(The circuit is shown for bit 0, the rest are the same)

- DOR: The DOR latch stores the output value to be placed on the D0-D7 bus pins. If RD=1 the complementary output lines with DOR are cut off, so the whole output part becomes floating.
- DL: The DL latch stores the input value
- Next to the control signal `DL/DB` you can see the precharge transistor for the internal bus DB (see also [Bus Multiplexer](#bus-multiplexer))

Control signals:
- DL/ADL: Place the DL latch value on the internal ADL bus
- DL/ADH: Place the DL latch value on the internal ADH bus
- DL/DB: In read mode (RD=1), the value from the DL latch is placed on the internal DB bus. In write mode (RD=0) the value from the DB bus is placed on the DOR latch

The external data bus (pins D0-D7) is also directly connected to the input of the [predecode circuit](#predecode).

Optimized schematics:

![11_6502_data_bit_tran](/BreakingNESWiki/imgstore/6502/ttlworks/11_6502_data_bit_tran.png)

## WR Latch

From the R/W control circuit, the latch circuit receives a control signal `WR`. The circuit outputs a control signal `RD` which controls the direction of the external data bus.

![6502_wr_latch_tran](/BreakingNESWiki/imgstore/6502/wr_latch_tran.jpg)

Optimized schematics:

![12_6502_wr_latch_tran](/BreakingNESWiki/imgstore/6502/ttlworks/12_6502_wr_latch_tran.png)

# Registers

![6502_locator_regs](/BreakingNESWiki/imgstore/6502/6502_locator_regs.jpg)

The X and Y registers are used for index addressing. Register S is a stack pointer and the stack is located at addresses 0x100 ... 0x1FF (on the first page).

Schematically the X, Y and S registers consist of 8 identical chunks (bits):

![regs_tran](/BreakingNESWiki/imgstore/6502/regs_tran.jpg)

(In the schematic above, replace SB0 and ADL0 with SBx and ADLx for the remaining register bits)

Each register bit is based on a trigger, loading and unloading of values on the buses is done by [control signals](#control-commands):
- Y/SB: Place the value of the register Y on the SB bus
- SB/Y: Load the Y register value from the SB bus
- X/SB: Place the value of the register X on the SB bus
- SB/X: Load the X register value from the SB bus
- S/ADL: Place the old S register value on the ADL bus
- S/SB: Place the old S register value on the SB bus
- SB/S: Load the new S register value from the SB bus
- S/S: Refresh S register, active when SB/S = 0

So the registers can only connect to two buses: SB and ADL.

:warning: Pay special attention to the design of the S register. It has an input latch (to load a new value) and an output latch (to save the old value). Loading the new value (SB/S) and saving the old value (S/ADL) can happen simultaneously.

## Logic

![regs_logic](/BreakingNESWiki/imgstore/6502/regs_logic.jpg)

- During PHI1 the X and Y registers output their value to the SB bus / are overloaded with new values from the SB bus.
- The S register has an input latch and an output latch. During PHI1 the value from the output latch is placed on the SB or ADL buses and the input latch is either loaded with a new value from the SB bus or refreshed from the output latch (S/S).
- During PHI2 the X and Y registers "store" their old value as the control signals disconnect them from the bus.
- The S register simply outputs its value to the SB or ADL bus during PHI2. The input latch is blocked because the exchange commands are disabled during PHI2.

The SB and ADL buses are precharged during PHI2. This is done because it takes longer to "charge" the bus than to "discharge" it. Therefore, when the bus is not needed - it is precharged, so that it does not have "floating" values.
If the value placed on the bus is 1, then the bus is already prepared ("charged") in advance. If the value placed on the bus is 0, then the bus is "discharged" to ground.

In modern processors the task of precharging the bus is done by dedicated standard cells called Bus Keeper.

In the transistor schematic above you can only see the transistors to charge the SB bus (located in the circuit for the S register bits). The transistors to precharge the ADL bus are scattered next to the program counter (PC).

## Optimized Schematics

![25_regs_logic](/BreakingNESWiki/imgstore/6502/ttlworks/25_regs_logic.png)

# ALU

![6502_locator_alu](/BreakingNESWiki/imgstore/6502/6502_locator_alu.jpg)

It is not possible to show the whole ALU circuit, so let's saw it into its component parts and consider each one separately.

![alu_preview](/BreakingNESWiki/imgstore/6502/alu_preview.jpg)

The ALU consists of the following components:
- Input circuits for AI/BI latch loading
- The main computational part (Operations)
- A fast carry calculation circuit for the BCD 
- Intermediate result (ADD latch)
- BCD correction circuit
- Accumulator (AC)

Generally speaking the ALU is a mess of transistors and wires, but its workings are not very complicated, as you can see later.

Overview of the ALU connections:

![alu_logisim](/BreakingNESWiki/imgstore/6502/alu_logisim.jpg)

## AI/BI Latches

The input circuits consist of 8 identical chunks, which are designed to load input values on the AI and BI latches:

![alu_input_tran](/BreakingNESWiki/imgstore/6502/alu_input_tran.jpg)

(The picture shows the circuit for bit 0, the rest are the same)

Control signals:
- DB/ADD: Load direct value from DB bus to the BI latch
- NDB/ADD: Load inverse value from DB bus to the BI latch
- ADL/ADD: Load a value from the ADL bus to the BI latch
- SB/ADD: Load a value from the SB bus to the AI latch
- 0/ADD: Write 0 to the AI latch

## Computational Part

The ALU uses an inverted carry chain, so the even and odd bit circuits alternate.

Bit 0 is slightly different from the other even bits because it has an input carry (`/ACIN`) and no `SRS` input.

Schematic for bit 0:

![alu_bit0_tran](/BreakingNESWiki/imgstore/6502/alu_bit0_tran.jpg)

Schematics for bits 2, 4, 6:

![alu_bit_even_tran](/BreakingNESWiki/imgstore/6502/alu_bit_even_tran.jpg)

(The circuit for bit 2 is shown, the rest are the same)

Schematics for bits 1, 3, 5, 7:

![alu_bit_odd_tran](/BreakingNESWiki/imgstore/6502/alu_bit_odd_tran.jpg)

(The circuit for bit 1 is shown, the rest are the same)

Optimized schematics:

|Even|Odd|
|---|---|
|![1_alu_even_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/1_alu_even_bit_logisim.png)|![2_alu_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/2_alu_odd_bit_logisim.png)|

Anatomically, the left side deals with logical operations, the right side is the adder (Full Adder), and in the middle is the carry chain.

Control signals for ALU operations:
- ORS: Logical OR operation (AI | BI)
- ANDS: Logical AND operation (AI & BI)
- EORS: Logical XOR operation (AI ^ BI)
- SRS: Shift Right. For this the result of the current `nand` operation is stored as the result of the previous bit.  
- SUMS: Summation (AI + BI)

Notations on the schematics:
- nand: intermediate result of NAND operation for the selected bit
- and: intermediate result of AND operation for the selected bit (obtained by `nand` inversion)
- nor: intermediate result of NOR operation for a selected bit
- xor: intermediate result of EOR operation for the selected bit
- nxor: intermediate result of an ENOR operation for the selected bit
- carry: the result of a carry operation. The carry chain is inverted every bit, but for simplicity all `carry` names do not consider value inversion.
- res: the result of a logical operation or the result of an adder which is then stored on the ADD latch. The result of an operation in inverted form.

To make it clearer how the intermediate results are obtained, all the main motifs are marked in the image below:

![alu_bit_annotated_tran](/BreakingNESWiki/imgstore/6502/alu_bit_annotated_tran.jpg)

(Bit 1 is shown, for the other bits the motif looks similar)

Logic for even bits:

![alu_even_bit_logisim](/BreakingNESWiki/imgstore/6502/alu_even_bit_logisim.jpg)

Logic for odd bits:

![alu_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/alu_odd_bit_logisim.jpg)

Overflow calculation (control signal `AVR`):

![alu_avr_tran](/BreakingNESWiki/imgstore/6502/alu_avr_tran.jpg)

![5_carry_plus_overflow_evaluation](/BreakingNESWiki/imgstore/6502/ttlworks/5_carry_plus_overflow_evaluation.png)

## Fast BCD Carry

This is the circuit that appears in patent US 3991307 (https://patents.google.com/patent/US3991307A).

![alu_bcd_carry_tran1](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_tran1.jpg)

![alu_bcd_carry_tran2](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_tran2.jpg)

The schematics are "layered on the side" for easy perception.

`DC3` output is connected to the carry chain as follows:

![alu_carry3_tran](/BreakingNESWiki/imgstore/6502/alu_carry3_tran.jpg)

How exactly this circuit works is written in the patent, I have nothing much to add. Just a mishmash of logic gates - do the same and it will work.

Besides calculating the carry for BCD the circuit also generates the `ACR` (ALU carry for flags) and `DAAH` control signals for the BCD correction circuit.

Logic:

![alu_bcd_carry_logisim](/BreakingNESWiki/imgstore/6502/alu_bcd_carry_logisim.jpg)

Optimized schematics:

![3_alu_bcd_carry_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/3_alu_bcd_carry_logisim.png)

## Intermediate Result (ADD)

The intermediate result is stored on the ADD latch (stored in inverted form, output to the buses in direct form). The ADD latch circuit consists of 8 identical pieces:

![alu_add_tran](/BreakingNESWiki/imgstore/6502/alu_add_tran.jpg)

(The circuit is shown for bit 0, the others are the same)

- ADD/SB06: Place the value of the ADD latch on the SB bus. The control signal `ADD/SB7` is used instead of ADD/SB06 for bit 7.
- ADD/ADL: Place the ADD latch value on the ADL bus

## BCD Correction

The BCD correction circuit is controlled by two signals: `/DAA` (perform correction after addition) and `/DSA` (perform correction after subtraction).

The outputs of the circuit are connected to the accumulator inputs (AC) and the circuit takes into account the ALU operation when the BCD mode is disabled.

Some of the accumulator inputs are connected directly to the SB bus and do not participate in BCD correction (bits 0 and 4).

The circuit uses 4 auxiliary internal signals in its operation: DAAL, DAAH, DSAL and DSAH. The "L" in the name stands for the lower part of the bits (0-3), the "H" stands for the higher part of the bits (4-7).

Circuits for obtaining auxiliary signals:

|DAAL|DSAL|DSAH|
|---|---|---|
|![alu_daal_tran](/BreakingNESWiki/imgstore/6502/alu_daal_tran.jpg)|![alu_dsal_tran](/BreakingNESWiki/imgstore/6502/alu_dsal_tran.jpg)|![alu_dsah_tran](/BreakingNESWiki/imgstore/6502/alu_dsah_tran.jpg)|

The `DAAH` circuit is in the carry circuit.

The correction circuits use a common motif:
- The input combinatorial circuits, in various combinations accounting for the 4 auxiliary signals and the bits of the intermediate result (ADD latches)
- Output xor, one of the inputs of which is a bit of the bus SB, and the second of the above combinatorial circuits

Sawed schematics:

|Bit 1|Bit 2|Bit 3|Bit 5|Bit 6|Bit 7|
|---|---|---|---|---|---|
|![alu_bcd1_tran](/BreakingNESWiki/imgstore/6502/alu_bcd1_tran.jpg)|![alu_bcd2_tran](/BreakingNESWiki/imgstore/6502/alu_bcd2_tran.jpg)|![alu_bcd3_tran](/BreakingNESWiki/imgstore/6502/alu_bcd3_tran.jpg)|![alu_bcd5_tran](/BreakingNESWiki/imgstore/6502/alu_bcd5_tran.jpg)|![alu_bcd6_tran](/BreakingNESWiki/imgstore/6502/alu_bcd6_tran.jpg)|![alu_bcd7_tran](/BreakingNESWiki/imgstore/6502/alu_bcd7_tran.jpg)|

The auxiliary signals /ADDx on the BCD correction circuits are derived from the values of the ADD latch bits as follows:

![alu_add_temp_tran](/BreakingNESWiki/imgstore/6502/alu_add_temp_tran.jpg)

(Using `/ADD5` as an example)

Logic:

![alu_bcd_logisim](/BreakingNESWiki/imgstore/6502/alu_bcd_logisim.jpg)

Optimized schematics:

![4_alu_bcd_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/4_alu_bcd_logisim.png)

## Accumulator (AC)

The accumulator consists of eight identical pieces:

![alu_ac_tran](/BreakingNESWiki/imgstore/6502/alu_ac_tran.jpg)

(The circuit for bit 3 is shown, the others are the same)

The accumulator inputs a value from the BCD correction circuit (bits 1-3, 5-7) or directly from the SB bus (bits 0 and 4).

In addition to directly outputting the accumulator to the SB and DB buses, other bus operations are also performed at this point, so they are also discussed in this section.

- SB/AC: Place the value from the SB bus/BCD correction circuit into the accumulator
- AC/SB: Place the AC value on the SB bus
- AC/DB: Place the AC value on the DB bus
- SB/DB: Connect the SB bus to DB bus
- SB/ADH: Connect the SB bus to ADH bus
- 0/ADH17: Forced write 0 to ADH bits 1-7. The control signal `0/ADH0` is used for bit 0 instead of 0/ADH17.

:warning: As time passed, it turned out that FET where SB/DB, SB/ADH, 0/ADH0, 0/ADH17 commands are used is more convenient to make a part of [Bus Multiplexer](#bus-multiplexer) circuit.

# Program Counter (PC)

![6502_locator_pc](/BreakingNESWiki/imgstore/6502/6502_locator_pc.jpg)

Because of the 8-bit nature of the processor its instruction counter is divided into two 8-bit halves: PCL (Program Counter Low) and PCH (Program Counter High).

The PCH is also divided into two halves: the low part of the bits (0-3) and the high part (4-7).

## PCL

Represents the low 8 least significant bits of PC.

|PCL 0-3|PCL 4-7|
|---|---|
|![pcl03_tran](/BreakingNESWiki/imgstore/6502/pcl03_tran.jpg)|![pcl47_tran](/BreakingNESWiki/imgstore/6502/pcl47_tran.jpg)|

- The circuits alternate for even and odd bits because an optimization known as an inverted carry chain is used
- The control signal `#1/PC` (0: perform PC increment) comes to the PCL0 bit
- PCLC (PCL Carry): Carry from the lowest 8 bits (PC\[0-7\]) to the highest (PC\[8-15\])
- PCL connects to two buses: ADL and DB
- PCL/PCL is used when PCL is not connected to any bus (to maintain the current state)
- Each bit contains two latches (input latch `PCLSx` and output latch `PCLx`) which implement the counter logic

## PCH

Represents the top 8 most significant bits of PC.

:warning: 
The circuits for the even bits (0, 2, ...) of the PCH repeat the circuits for the odd bits (1, 3, ...) of the PCL.
Similarly, circuits for odd bits (1, 3, ...) of PCH repeat circuits for even bits (0, 2, ...) of PCL.

|PCH 0-3|PCH 4-7|
|---|---|
|![pch03_tran](/BreakingNESWiki/imgstore/6502/pch03_tran.jpg)|![pch47_tran](/BreakingNESWiki/imgstore/6502/pch47_tran.jpg)|

The circuit marked as "patch" to form the `PCHC` is actually between the `ADL/PCL` and `#1/PC` control outputs.

- The basic principles of PCH are the same as PCL, but PCH is divided into two halves: the lower half (PCH0-3) and the higher half (PCH4-7)
- PCHC (PCH Carry): Carry from the lowermost to the highestermost PCH half
- The PCH connects to two buses: ADH and DB
- PCH/PCH is used when the PCH is not connected to any bus (to maintain the current state)

## ADL/ADH Precharge

In between the PC bits you can find transistors for precharge of the ADL and ADH buses:

![adl_adh_precharge_tran](/BreakingNESWiki/imgstore/6502/adl_adh_precharge_tran.jpg)

(The image shows the precharge transistors for ADH4 and ADL5. The others are similar)

:warning: As time passed, it turned out that it is more convenient to make the FET where the buses are precharged as part of the [Bus Multiplexer](#bus-multiplexer) circuit.

## Logic

It makes sense to show only the bit schematics (the circuitry alternates between even and odd PCL/PCH bits).

This circuit is used, for example, in PCL0 or PCH1:

![pc_even_bit_logisim](/BreakingNESWiki/imgstore/6502/pc_even_bit_logisim.jpg)

This circuit is used, for example, in PCL1 or PCH0:

![pc_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/pc_odd_bit_logisim.jpg)

For these circuits to work correctly in the simulator, FF uses a posedge trigger for the PCL/PCH register.

Optimized schematics (Even):

![20_pc_even_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/20_pc_even_bit_logisim.png)

Optimized schematics (Odd):

![21_pc_odd_bit_logisim](/BreakingNESWiki/imgstore/6502/ttlworks/21_pc_odd_bit_logisim.png)

Optimized schematics for the carry chain:

![22_pc_carry_chain](/BreakingNESWiki/imgstore/6502/ttlworks/22_pc_carry_chain.png)

# Bus Multiplexer

All scattered pieces of schematics of the lower part, where internal buses are connected to each other or buses are connected to constants, it was decided to separate them into a separate section.

The reason for this is that working with buses is a "favorite topic" when designing circuits and it is better to have all places where work with buses happens in one place.

## Precharge

All buses are precharged during PHI2. This is done to form constants: from the value 0xff, which was obtained during precharge, other values are obtained by connecting the required bits to 0.
Note that the charged bus value is retained for the next half-cycle (PHI1), where the required constants are generated.

The SB bus is being precharged in the S register:

![busmpx1](/BreakingNESWiki/imgstore/6502/busmpx1.jpg)

The DB bus is precharged in DataLatch:

![busmpx2](/BreakingNESWiki/imgstore/6502/busmpx2.jpg)

The ADL bus is precharged around the PC register (bits 0-3), with the other FETs scattered between PC and DL:

![busmpx3](/BreakingNESWiki/imgstore/6502/busmpx3.jpg)
![busmpx5](/BreakingNESWiki/imgstore/6502/busmpx5.jpg)

The ADH bus is precharged in the AC register (bits 0-2), with the remaining FETs scattered between PC and DL:

![busmpx4](/BreakingNESWiki/imgstore/6502/busmpx4.jpg)
![busmpx5](/BreakingNESWiki/imgstore/6502/busmpx5.jpg)

## 0/ADL

The commands 0/ADL0, 0/ADL1, 0/ADL2 are used to generate the interrupt address. The FETs are located next to terminals A0-A2.

![busmpx6](/BreakingNESWiki/imgstore/6502/busmpx6.jpg)

## 0/ADH

The 0/ADH0 and 0/ADH17 commands are applied next to the AC register. The 0/ADH0 command applies to bit 0. The 0/ADH17 command applies to bits 1-7.

![busmpx7](/BreakingNESWiki/imgstore/6502/busmpx7.jpg)

## Connection of buses to buses

The SB/DB and SB/ADH commands are used to connect the buses to each other. The FETs to apply these commands are located next to the AC register.

![busmpx8](/BreakingNESWiki/imgstore/6502/busmpx8.jpg)

These commands cause the most trouble when porting 6502 circuits to Verilog or simulation because the bus connection is implemented by a bidirectional FETs.

# 6502 Verilog Model

This model is not verified and may contain errors, but I think the neural network will figure it out.

```verilog

`timescale 1ns/1ns

// Top module for MOS 6502 Core

// Top->Bottom Operations

`define Y_SB bop[0]			// Y => SB
`define SB_Y bop[1]			// SB => Y
`define X_SB bop[2]			// X => SB
`define SB_X bop[3]			// SB => X
`define S_ADL bop[4]		// S => ADL
`define S_SB bop[5]			// S => SB
`define SB_S bop[6]			// SB => S
`define S_S bop[7]			// The S/S command is active if the SB/S command is inactive (refresh S)
`define NDB_ADD bop[8]		// ~DB => BI
`define DB_ADD bop[9]		// DB => BI
`define Z_ADD bop[10]		// 0 => AI
`define SB_ADD bop[11]		// SB => AI
`define ADL_ADD bop[12]		// ADL => BI
`define ANDS bop[13]		// AI & BI
`define EORS bop[14]		// AI ^ BI
`define ORS bop[15]			// AI | BI
`define SRS bop[16]			// >>= 1
`define SUMS bop[17]		// AI + BI
`define ADD_SB7 bop[18]		// ADD[7] => SB[7]
`define ADD_SB06 bop[19]	// ADD[0-6] => SB[0-6]
`define ADD_ADL bop[20]		// ADD => ADL
`define SB_AC bop[21]		// SB => AC
`define AC_SB bop[22]		// AC => SB
`define AC_DB bop[23]		// AC => DB
`define ADH_PCH bop[24]		// ADH => PCH
`define PCH_PCH bop[25]		// If ADH/PCH is not performed, this command is performed (refresh PCH)
`define PCH_ADH bop[26]		// PCH => ADH
`define PCH_DB bop[27]		// PCH => DB
`define ADL_PCL bop[28]		// ADL => PCL
`define PCL_PCL bop[29]		// If ADL/PCL is not performed, this command is performed (refresh PCL)
`define PCL_ADL bop[30]		// PCL => ADL
`define PCL_DB bop[31]		// PCL => DB
`define ADH_ABH bop[32]		// ADH => ABH
`define ADL_ABL bop[33]		// ADL => ABL
`define Z_ADL0 bop[34]		// Reset some of the ADL bus bits (0). Used to set the interrupt vector.
`define Z_ADL1 bop[35]		// Reset some of the ADL bus bits (1). Used to set the interrupt vector.
`define Z_ADL2 bop[36]		// Reset some of the ADL bus bits (2). Used to set the interrupt vector.
`define Z_ADH0 bop[37]		// Reset some of the ADH bus bits (0)
`define Z_ADH17 bop[38]		// Reset some of the ADH bus bits (1-7)
`define SB_DB bop[39]		// SB <=> DB, connect the two buses
`define SB_ADH bop[40]		// SB <=> ADH
`define DL_ADL bop[41]		// DL => ADL
`define DL_ADH bop[42]		// DL => ADH
`define DL_DB bop[43]		// DL <=> DB


module Core6502 (n_NMI, n_IRQ, n_RES, PHI0, PHI1, PHI2, RDY, SO, RnW, SYNC, A, D);

	input n_NMI;		// Non-maskable interrupt signal, active low
	input n_IRQ;		// Maskable interrupt signal, active low
	input n_RES;		// Reset signal, active low
	input PHI0;			// Reference clock signal
	output PHI1;		// First half-cycle, processor in `Set RW / Address` mode
	output PHI2;		// Second half-cycle, processor in `Read/Write Data` mode
	input RDY;			// Processor Ready (1: ready)
	input SO;			// Forced setting of the overflow flag (V)
	output RnW;			// Data bus direction (R/W=1: processor reads data, R/W=0: processor writes)
	output SYNC;		// The processor is on cycle T1 (opcode fetch)
	output [15:0] A;	// Address bus
	inout [7:0] D; 		// Data bus (bidirectional)

	// Wires

	wire n_NMIP;
	wire n_IRQP;
	wire RESP;
	wire RDY_frompad;
	wire n_PRDY;
	wire SO_frompad;
	wire WR_topad;
	wire T1_topad;

	wire PHI1_tocore;
	wire PHI2_tocore;

	wire ACR;
	wire AVR;
	wire [7:0] DB;

	wire [43:0] bop;	// Control "Commands"
	wire n_ACIN;		// ALU input carry. The ALU also returns the result of carry (ACR) and overflow (AVR)
	wire n_DAA;			// 0: Perform BCD correction after addition
	wire n_DSA;			// 0: Perform BCD correction after subtraction
	wire n_IPC;			// 0: Increment the program counter	

	// Module instantiation

	ClkGen clk (
		.PHI0(PHI0), 
		.PHI1(PHI1_tocore), 
		.PHI2(PHI2_tocore), 
		.PHI1_topad(PHI1), 
		.PHI2_topad(PHI2) );

	PadsLogic pads (
		.PHI1(PHI1), 
		.PHI2(PHI2),
		.n_NMI(n_NMI), 
		.n_IRQ(n_IRQ), 
		.n_RES(n_RES), 
		.n_NMIP(n_NMIP), 
		.n_IRQP(n_IRQP), 
		.RESP(RESP), 
		.RDY(RDY), 
		.RDY_frompad(RDY_frompad), 
		.n_PRDY(n_PRDY), 
		.T1_topad(T1_topad), 
		.SYNC(SYNC), 
		.SO(SO), 
		.SO_frompad(SO_frompad),
		.WR_topad(WR_topad), 
		.RnW(RnW) );

	Core6502_Top top (
		.PHI1(PHI1_tocore),
		.PHI2(PHI2_tocore), 
		.n_NMIP(n_NMIP),
		.n_IRQP(n_IRQP),
		.RESP(RESP),
		.RDY_frompad(RDY_frompad),
		.n_PRDY(n_PRDY),
		.SO_frompad(SO_frompad),
		.bop(bop),
		.n_ACIN(n_ACIN),
		.n_DAA(n_DAA),
		.n_DSA(n_DSA),
		.n_IPC(n_IPC),
		.WR(WR_topad),
		.T1(T1_topad),
		.ACR(ACR),
		.AVR(AVR),
		.DB(DB),
		.D(D) );

	Core6502_Bot bot (
		.PHI1(PHI1_tocore),
		.PHI2(PHI2_tocore),
		.bop(bop),
		.n_ACIN(n_ACIN),
		.n_DAA(n_DAA),
		.n_DSA(n_DSA),
		.n_IPC(n_IPC),
		.WR(WR_topad),
		.ACR(ACR),
		.AVR(AVR),
		.DB(DB),
		.A(A),
		.D(D) );

endmodule // Core6502

module Core6502_Top (
	PHI1, PHI2, 
	n_NMIP, n_IRQP, RESP, RDY_frompad, n_PRDY, SO_frompad,
	bop, n_ACIN, n_DAA, n_DSA, n_IPC, WR, T1, ACR, AVR, DB, D);

	input PHI1;
	input PHI2;
	input n_NMIP;
	input n_IRQP;
	input RESP;
	input RDY_frompad;
	input n_PRDY;
	input SO_frompad;
	output [43:0] bop;
	output n_ACIN;
	output n_DAA;
	output n_DSA;
	output n_IPC;
	output WR;
	output T1;
	input ACR;
	input AVR;
	inout [7:0] DB; 	// Internal databus to Flags
	inout [7:0] D; 		// External databus to Predecode

	wire IR5_C;		// Change the value of the flag according to the IR5 bit
	wire ACR_C;		// Change the value of the flag according to the ACR value
	wire DB_C;		// Change the value of the flag according to DB0 bit
	wire DBZ_Z;		// Change the value of the flag according to the /DBZ value
	wire IR5_I;		// Change the value of the flag according to the IR5 bit
	wire IR5_D;		// Change the value of the flag according to the IR5 bit
	wire DB_V;		// Change the value of the flag according to DB6 bit
	wire Z_V;		// Clear flag V
	wire DB_N;		// Change the value of the flag according to DB7 bit
	wire P_DB;		// Place the value of the flags register P on the DB bus
	wire DB_P;		// Place the DB bus value on the flag register P

	wire Z_IR;
	wire [7:0] n_PD;
	wire n_IMPLIED;
	wire n_TWOCYCLE;
	wire n_BRTAKEN;
	wire BRFW;

	wire FETCH;
	wire IR01;
	wire [7:0] IR;
	wire [7:0] n_IR;

	wire TRES2;
	wire n_ready;
	wire T0;
	wire T1;
	wire n_T2;
	wire n_T3;
	wire n_T4;
	wire n_T5;
	wire n_T0;
	wire n_T1X;
	wire T6;
	wire T7;

	wire [129:0] Decoder_out;

	wire BRK5;
	wire BRK5_RDY;
	wire BRK6E;
	wire BRK7;
	wire DORES;
	wire n_DONMI;
	wire B_OUT;	

	wire STXY;
	wire n_SBXY;
	wire STKOP;
	wire STOR;
	wire ACRL2;
	wire DL_PCH;
	wire INC_SB;
	wire n_PCH_PCH;
	wire n_ADL_PCL;
	wire PC_DB;
	wire SR;
	wire AND;
	wire ZTST;
	wire PGX;

	// Flags output

	wire n_ZOUT;
	wire n_NOUT;
	wire n_COUT;
	wire n_DOUT;
	wire n_IOUT;
	wire n_VOUT;

	wire BR0;
	assign BR0 = Decoder_out[73] & ~n_PRDY;

	PreDecode pd (
		.PHI2(PHI2),
		.Z_IR(Z_IR),
		.Data_bus(D),
		.n_PD(n_PD),
		.n_IMPLIED(n_IMPLIED),
		.n_TWOCYCLE(n_TWOCYCLE) );

	IR ir (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.n_PD(n_PD),
		.FETCH(FETCH),
		.IR01(IR01),
		.IR_out(IR),
		.n_IR_out(n_IR) );

	ExtraCounter extcnt (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.TRES2(TRES2),
		.n_ready(n_ready),
		.T1(T1),
		.n_T2(n_T2),
		.n_T3(n_T3),
		.n_T4(n_T4),
		.n_T5(n_T5) );

	Decoder dec (
		.n_T0(n_T0),
		.n_T1X(n_T1X),
		.n_T2(n_T2),
		.n_T3(n_T3),
		.n_T4(n_T4),
		.n_T5(n_T5), 
		.IR01(IR01),
		.IR(IR),
		.n_IR(n_IR),
		.X(Decoder_out) );

	BRKProcessing brk (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.BRK5(Decoder_out[22]),
		.n_ready(n_ready),
		.RESP(RESP),
		.n_NMIP(n_NMIP),
		.BR2(Decoder_out[80]),
		.T0(T0),
		.n_IRQP(n_IRQP),
		.n_IOUT(n_IOUT),
		.BRK6E(BRK6E),
		.BRK7(BRK7),
		.BRK5_RDY(BRK5_RDY),
		.DORES(DORES),
		.n_DONMI(n_DONMI),
		.B_OUT(B_OUT) );

	IntVector int (
		.PHI2(PHI2),
		.BRK5_RDY(BRK5_RDY),
		.BRK7(BRK7),
		.DORES(DORES),
		.n_DONMI(n_DONMI),
		.Z_ADL0(`Z_ADL0),
		.Z_ADL1(`Z_ADL1),
		.Z_ADL2(`Z_ADL2) );

	Regs_Control regctl (
		.PHI1(PHI1),
		.PHI2(PHI2), 
		.STOR(STOR),
		.n_ready(n_ready), 
		.X(Decoder_out),
		.STXY(STXY),
		.n_SBXY(n_SBXY),
		.STKOP(STKOP), 
		.Y_SB(`Y_SB),
		.X_SB(`X_SB),
		.S_SB(`S_SB),
		.SB_X(`SB_X),
		.SB_Y(`SB_Y),
		.SB_S(`SB_S),
		.S_S(`S_S),
		.S_ADL(`S_ADL) );

	ALU_Control aluctl (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.BRFW(BRFW),
		.n_ready(n_ready),
		.BRK6E(BRK6E),
		.STKOP(STKOP),
		.PGX(PGX),
		.X(Decoder_out),
		.T0(T0),
		.T1(T1),
		.T6(T6),
		.T7(T7),
		.n_DOUT(n_DOUT),
		.n_COUT(n_COUT),
		.INC_SB(INC_SB),
		.SR(SR),
		.AND(AND),
		.NDB_ADD(`NDB_ADD),
		.DB_ADD(`DB_ADD),
		.Z_ADD(`Z_ADD),
		.SB_ADD(`SB_ADD),
		.ADL_ADD(`ADL_ADD),
		.ADD_SB06(`ADD_SB06),
		.ADD_SB7(`ADD_SB7),
		.ADD_ADL(`ADD_ADL),
		.ANDS(`ANDS),
		.EORS(`EORS),
		.ORS(`ORS),
		.SRS(`SRS),
		.SUMS(`SUMS),
		.n_ACIN(n_ACIN),
		.n_DAA(n_DAA),
		.n_DSA(n_DSA) );

	Bus_Control busctl (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.n_SBXY(n_SBXY),
		.AND(AND),
		.STOR(STOR),
		.Z_ADL0(`Z_ADL0),
		.ACRL2(ACRL2),
		.DL_PCH(DL_PCH),
		.n_ready(n_ready),
		.INC_SB(INC_SB),
		.BRK6E(BRK6E),
		.STXY(STXY),
		.n_PCH_PCH(n_PCH_PCH),
		.T0(T0),
		.T1(T1),
		.T6(T6),
		.T7(T7),
		.BR0(BR0),
		.X(Decoder_out),
		.ZTST(ZTST),
		.PGX(PGX), 
		.Z_ADH0(`Z_ADH0),
		.Z_ADH17(`Z_ADH17),
		.SB_AC(`SB_AC),
		.ADL_ABL(`ADL_ABL),
		.AC_SB(`AC_SB),
		.SB_DB(`SB_DB),
		.AC_DB(`AC_DB),
		.SB_ADH(`SB_ADH),
		.DL_ADH(`DL_ADH),
		.DL_ADL(`DL_ADL),
		.ADH_ABH(`ADH_ABH),
		.DL_DB(`DL_DB) );

	PC_Control pcctl (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.n_ready(n_ready),
		.T0(T0),
		.T1(T1), 
		.BR0(BR0),
		.X(Decoder_out),
		.PCL_DB(`PCL_DB),
		.PCH_DB(`PCH_DB),
		.PC_DB(PC_DB),
		.PCL_ADL(`PCL_ADL),
		.PCH_ADH(`PCH_ADH),
		.PCL_PCL(`PCL_PCL),
		.ADL_PCL(`ADL_PCL),
		.n_ADL_PCL(n_ADL_PCL),
		.DL_PCH(DL_PCH),
		.ADH_PCH(`ADH_PCH),
		.PCH_PCH(`PCH_PCH),
		.n_PCH_PCH(n_PCH_PCH) );

	Flags_Control fctl (
		.PHI2(PHI2),
		.X(Decoder_out),
		.T7(T7),
		.ZTST(ZTST),
		.n_ready(n_ready),
		.SR(SR),
		.P_DB(P_DB),
		.IR5_I(IR5_I),
		.IR5_C(IR5_C),
		.IR5_D(IR5_D),
		.Z_V(Z_V),
		.ACR_C(ACR_C),
		.DBZ_Z(DBZ_Z),
		.DB_N(DB_N),
		.DB_P(DB_P),
		.DB_C(DB_C),
		.DB_V(DB_V) );

	Dispatch disp (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.BRK6E(BRK6E),
		.RESP(RESP),
		.ACR(ACR),
		.DORES(DORES),
		.PC_DB(PC_DB),
		.RDY(RDY_frompad),
		.B_OUT(B_OUT),
		.BRFW(BRFW),
		.n_BRTAKEN(n_BRTAKEN),
		.n_TWOCYCLE(n_TWOCYCLE),
		.n_IMPLIED(n_IMPLIED),
		.n_ADL_PCL(n_ADL_PCL), 
		.X(Decoder_out), 
		.ACRL2(ACRL2),
		.T6(T6),
		.T7(T7),
		.TRES2(TRES2),
		.STOR(STOR),
		.Z_IR(Z_IR),
		.FETCH(FETCH),
		.n_ready(n_ready),
		.WR(WR),
		.T1(T1),
		.n_T0(n_T0),
		.T0(T0),
		.n_T1X(n_T1X),
		.n_IPC(n_IPC) );

	BranchLogic branch (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.n_IR5(n_IR[5]),
		.X(Decoder_out),
		.n_COUT(n_COUT),
		.n_VOUT(n_VOUT),
		.n_NOUT(n_NOUT),
		.n_ZOUT(n_ZOUT),
		.DB(DB),
		.BR2(Decoder_out[80]),
		.n_BRTAKEN(n_BRTAKEN),
		.BRFW(BRFW) );

	Flags flags (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.P_DB(P_DB),
		.DB_P(DB_P),
		.DBZ_Z(DBZ_Z),
		.DB_N(DB_N),
		.IR5_C(IR5_C),
		.DB_C(DB_C),
		.ACR_C(ACR_C),
		.IR5_D(IR5_D),
		.IR5_I(IR5_I),
		.DB_V(DB_V),
		.Z_V(Z_V),
		.ACR(ACR),
		.AVR(AVR),
		.B_OUT(B_OUT),
		.n_IR5(n_IR[5]),
		.BRK6E(BRK6E),
		.Dec112(Decoder_out[112]),
		.SO_frompad(SO_frompad), 
		.DB(DB),
		.n_ZOUT(n_ZOUT),
		.n_NOUT(n_NOUT),
		.n_COUT(n_COUT),
		.n_DOUT(n_DOUT),
		.n_IOUT(n_IOUT),
		.n_VOUT(n_VOUT) );

endmodule // Core6502_Top

module Core6502_Bot (PHI1, PHI2, bop, n_ACIN, n_DAA, n_DSA, n_IPC, WR, ACR, AVR, DB, A, D);

	input PHI1;
	input PHI2;
	input [43:0] bop;
	input n_ACIN;
	input n_DAA;
	input n_DSA;
	input n_IPC;
	input WR;
	output ACR;
	output AVR;
	output [15:0] A;
	inout [7:0] DB; 	// Internal data bus
	inout [7:0] D;

	wire [7:0] SB; 		// Side bus
	wire [7:0] ADL;		// Address bus low
	wire [7:0] ADH;		// Address bus high

	wire RD_to_db;

	Regs regs (
		.PHI2(PHI2),
		.Y_SB(`Y_SB),
		.SB_Y(`SB_Y),
		.X_SB(`X_SB),
		.SB_X(`SB_X),
		.S_SB(`S_SB),
		.S_ADL(`S_ADL),
		.S_S(`S_S),
		.SB_S(`SB_S), 
		.SB(SB),
		.ADL(ADL) );

	ALU alu (
		.PHI2(PHI2),
		.NDB_ADD(`NDB_ADD),
		.DB_ADD(`DB_ADD),
		.Z_ADD(`Z_ADD),
		.SB_ADD(`SB_ADD),
		.ADL_ADD(`ADL_ADD),
		.ADD_SB06(`ADD_SB06),
		.ADD_SB7(`ADD_SB7),
		.ADD_ADL(`ADD_ADL),
		.ANDS(`ANDS),
		.EORS(`EORS),
		.ORS(`ORS),
		.SRS(`SRS),
		.SUMS(`SUMS), 
		.SB_AC(`SB_AC),
		.AC_SB(`AC_SB),
		.AC_DB(`AC_DB),
		.n_ACIN(n_ACIN),
		.n_DAA(n_DAA),
		.n_DSA(n_DSA),
		.SB(SB),
		.DB(DB),
		.ADL(ADL),
		.ADH(ADH),
		.ACR(ACR),
		.AVR(AVR) );

	PC pc (
		.PHI2(PHI2),
		.n_IPC(n_IPC),
		.ADL_PCL(`ADL_PCL),
		.PCL_PCL(`PCL_PCL),
		.PCL_ADL(`PCL_ADL),
		.PCL_DB(`PCL_DB),
		.ADH_PCH(`ADH_PCH),
		.PCH_PCH(`PCH_PCH),
		.PCH_ADH(`PCH_ADH),
		.PCH_DB(`PCH_DB),
		.ADL(ADL),
		.ADH(ADH),
		.DB(DB) );

	AddrBusBit abl [7:0] (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.ADX(ADL),
		.ADX_ABX(`ADL_ABL),
		.ABus_out(A[7:0]) );

	AddrBusBit abh [7:0] (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.ADX(ADH),
		.ADX_ABX(`ADH_ABH),
		.ABus_out(A[15:8]) );

	WRLatch wrl (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.WR(WR),
		.RD(RD_to_db) );

	DataBusBit db [7:0] (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.ADL(ADL),
		.ADH(ADH),
		.DB(DB),
		.DB_Ext(D),
		.DL_ADL(`DL_ADL),
		.DL_ADH(`DL_ADH),
		.DL_DB(`DL_DB),
		.RD(RD_to_db) );

	BusMux busmux (
		.PHI2(PHI2),
		.SB(SB),
		.DB(DB),
		.ADL(ADL),
		.ADH(ADH),
		.Z_ADL0(`Z_ADL0),
		.Z_ADL1(`Z_ADL1),
		.Z_ADL2(`Z_ADL2),
		.Z_ADH0(`Z_ADH0),
		.Z_ADH17(`Z_ADH17),
		.SB_DB(`SB_DB),
		.SB_ADH(`SB_ADH) );

endmodule // Core6502_Bot

// The logic next to the terminal pads.

module PadsLogic (
	PHI1, PHI2,
	n_NMI, n_IRQ, n_RES, n_NMIP, n_IRQP, RESP, 
	RDY, RDY_frompad, n_PRDY, 
	T1_topad, SYNC, SO, SO_frompad,
	WR_topad, RnW);

	input PHI1;
	input PHI2;
	input n_NMI;
	input n_IRQ; 
	input n_RES; 
	output n_NMIP;
	output n_IRQP; 
	output RESP;
	
	input RDY;
	output RDY_frompad;
	output n_PRDY;

	input T1_topad;
	output SYNC;

	input SO;
	output SO_frompad;

	input WR_topad;
	output RnW;

	// Implementation of logic that is located around terminals (pads)

	// Interrupt pads
	// Input inverters can act as transparent latches (since the values of external interrupt signals can be `Z`),
	// but there's probably no point in doing that, they usually put pull-ups on the outside for them anyway. 

	wire nmip_ff_q;
	int_ff nmip_ff (.PHI2(PHI2), .d(~n_NMI), .q(nmip_ff_q));
	assign n_NMIP = ~nmip_ff_q;

	wire irqp_ff_q;
	int_ff irqp_ff (.PHI2(PHI2), .d(~n_IRQ), .q(irqp_ff_q));
	dlatch irqp_latch (.d(irqp_ff_q), .en(PHI1), .nq(n_IRQP));

	wire resp_ff_nq;	// !!!
	int_ff resp_ff (.PHI2(PHI2), .d(~n_RES), .nq(resp_ff_nq));
	dlatch resp_latch (.d(resp_ff_nq), .en(PHI1), .nq(RESP));

	// Others

	assign RDY_frompad = RDY;
	wire prdy_latch1_nq;
	dlatch prdy_latch1 (.d(~RDY), .en(PHI2), .nq(prdy_latch1_nq));
	dlatch prdy_latch2 (.d(prdy_latch1_nq), .en(PHI1), .nq(n_PRDY));

	buf (SYNC, T1_topad);

	wire so_latch1_nq;
	wire so_latch2_nq;
	wire so_latch3_q;
	dlatch so_latch1 (.d(~SO), .en(PHI1), .nq(so_latch1_nq));
	dlatch so_latch2 (.d(so_latch1_nq), .en(PHI2), .nq(so_latch2_nq));
	dlatch so_latch3 (.d(so_latch2_nq), .en(PHI1), .q(so_latch3_q));
	nor (SO_frompad, so_latch3_q, so_latch1_nq);

	dlatch rw_latch (.d(WR_topad), .en(PHI1), .nq(RnW));

endmodule // PadsLogic

// Implementation of flip-flops that are next to interrupt terminals (NMI/IRQ/RES)
module int_ff (PHI2, d, q, nq);

	input PHI2; 		// 1: enable (level-triggered)
	input d;
	output q;
	output nq;

	// Cycle of two AOI-21s
	wire g0_out;
	wire g1_out;
	aoi g0 (.a0(~d), .a1(PHI2), .b(g1_out), .x(g0_out));
	aoi g1 (.a0(d), .a1(PHI2), .b(g0_out), .x(g1_out));

	assign q = g0_out;
	assign nq = g1_out;

endmodule // int_ff

module ClkGen (PHI0, PHI1, PHI2, PHI1_topad, PHI2_topad);

	input PHI0;
	output PHI1;
	output PHI2;
	output PHI1_topad;
	output PHI2_topad;

	Phi1Gen phi1_tocore (.PHI0(PHI0), .PHI1(PHI1) );
	Phi2Gen phi2_tocore (.PHI0(PHI0), .PHI1(PHI1), .PHI2(PHI2) );

	Phi1Gen phi1_topad (.PHI0(PHI0), .PHI1(PHI1_topad) );
	Phi2Gen phi2_topad (.PHI0(PHI0), .PHI1(PHI1_topad), .PHI2(PHI2_topad) );

endmodule 	// ClkGen

module Phi1Gen (PHI0, PHI1);

	input PHI0;
	output PHI1;

	assign PHI1 = ~(~(~PHI0));

endmodule // Phi1Gen

module Phi2Gen (PHI0, PHI1, PHI2);

	input PHI0;
	input PHI1;
	output PHI2;

	wire tmp1;
	wire tmp2;
	assign tmp1 = ~PHI0 | PHI1;
	assign tmp2 = ~PHI0 & tmp1;
	assign PHI2 = ~(tmp2 ? tmp2 : tmp1);	

endmodule // Phi2Gen

// The handling of all exceptions and BRK instruction is unified and is referred to as the "BRK sequence".

module BRKProcessing (
	PHI1, PHI2,
	BRK5, n_ready, RESP, n_NMIP, BR2, T0, n_IRQP, n_IOUT,
	BRK6E, BRK7, BRK5_RDY, DORES, n_DONMI, B_OUT);

	input PHI1;
	input PHI2;

	input BRK5;
	input n_ready;
	input RESP;
	input n_NMIP;
	input BR2;
	input T0;
	input n_IRQP;
	input n_IOUT;

	output BRK6E;
	output BRK7;
	output BRK5_RDY;
	output DORES;
	output n_DONMI;
	output B_OUT;

	// BRK sequence cycles 6-7

	wire BRK5_RDY;
	and (BRK5_RDY, BRK5, ~n_ready);
	dlatch brk5_latch (.d(BRK5_RDY), .en(PHI2), .q(brk5_latch_q) );
	wire brk5_latch_q;
	wire tmp2;
	nand (tmp2, n_ready, brk6_latch1_nq);
	wire brk6_latch1_d;
	and (brk6_latch1_d, ~brk5_latch_q, tmp2);
	dlatch brk6_latch1 (.d(brk6_latch1_d), .en(PHI1), .nq(brk6_latch1_nq) );
	wire brk6_latch1_nq;
	dlatch brk6_latch2 (.d(brk6_latch1_nq), .en(PHI2), .nq(brk6_latch2) );
	wire brk6_latch2_nq;
	nor (BRK6E, brk6_latch2_nq, n_ready);
	nor (BRK7, brk6_latch1_nq, BRK5_RDY);

	// Reset FF

	wire nDORES;
	nor (nDORES, res_latch1_q, res_latch2_q);
	dlatch res_latch1 (.d(RESP), .en(PHI2), .q(res_latch1_q) );
	wire res_latch1_q;
	wire res_latch2_d;
	nor (res_latch2_d, nDORES, BRK6E);
	dlatch res_latch2 (.d(res_latch2_d), .en(PHI1), .q(res_latch2_q) );
	wire res_latch2_q;
	not (DORES, nDORES);

	// NMI Edge Detect

	wire tmp1;
	nor (tmp1, ff2_latch_q, delay_latch2_q);
	wire ff2_latch_d;
	nor (ff2_latch_d, nmip_latch_q, tmp1);
	dlatch brk7_latch (.d(BRK7), .en(PHI2), .nq(brk7_latch_nq) );
	wire brk7_latch_nq;
	wire donmi_latch_d;
	nor (donmi_latch_d, brk7_latch_nq, n_NMIP, ff2_latch_d);
	dlatch donmi_latch (.d(donmi_latch_d), .en(PHI1), .q(donmi_latch_q) );
	wire donmi_latch_q;
	dlatch nmip_latch (.d(n_NMIP), .en(PHI1), .q(nmip_latch_q) );
	wire nmip_latch_q;
	dlatch ff2_latch (.d(ff2_latch_d), .en(PHI2), .q(ff2_latch_q) );
	wire ff2_latch_q;
	dlatch delay_latch1 (.d(n_DONMI), .en(PHI2), .nq(delay_latch1_nq) );
	wire delay_latch1_nq;
	dlatch delay_latch2 (.d(delay_latch1_nq), .en(PHI1), .q(delay_latch2_q) );
	wire delay_latch2_q;
	dlatch ff1_latch (.d(n_DONMI), .en(PHI2), .q(ff1_latch_q) );
	wire ff1_latch_q;
	dlatch brk6e_latch (.d(BRK6E), .en(PHI1), .q(brk6e_latch_q) );
	wire brk6e_latch_q;
	wire nmitmp1;
	nor (nmitmp1, ff1_latch_q, brk6e_latch_q);
	nor (n_DONMI, donmi_latch_q, nmitmp1);

	// Interrupt Check

	wire intr = ~( (BR2|T0) & (~((n_IRQP|~n_IOUT)&n_DONMI)) );

	wire b_latch2_d;
	nor (b_latch2_d, b_latch1_q, BRK6E);
	dlatch b_latch2 (.d(b_latch2_d), .en(PHI1), .q(b_latch2_q) );
	wire b_latch2_q;
	wire b_latch1_d;
	and (b_latch1_d, intr, ~b_latch2_q);
	dlatch b_latch1 (.d(b_latch1_d), .en(PHI2), .q(b_latch1_q) );
	wire b_latch1_q;

	nor (B_OUT, DORES, b_latch2_d);

endmodule // BRKProcessing

module IntVector (
	PHI2, BRK5_RDY, BRK7, DORES, n_DONMI,
	Z_ADL0, Z_ADL1, Z_ADL2);

	input PHI2;
	input BRK5_RDY;
	input BRK7;
	input DORES;
	input n_DONMI;

	output Z_ADL0;
	output Z_ADL1;
	output Z_ADL2;

	dlatch zadl0_latch (.d(~BRK5_RDY), .en(PHI2), .nq(Z_ADL0) );
	wire tmp1;
	nor (tmp1, BRK7, ~DORES);
	dlatch zadl1_latch (.d(~tmp1), .en(PHI2), .nq(Z_ADL1) );
	wire zadl2_latch_d;
	nor (zadl2_latch_d, BRK7, DORES, n_DONMI);
	dlatch zadl2_latch (.d(zadl2_latch_d), .en(PHI2), .nq(zadl2_latch_nq) );
	wire zadl2_latch_nq;
	not (Z_ADL2, zadl2_latch_nq);

endmodule // IntVector

module ExtraCounter (
	PHI1, PHI2, TRES2, n_ready, T1,
	n_T2, n_T3, n_T4, n_T5);

	input PHI1;
	input PHI2;
	input TRES2;
	input n_ready;
	input T1;

	output n_T2;
	output n_T3;
	output n_T4;
	output n_T5;

	wire t1_latch_nq;
	wire [3:0] nq;

	dlatch t1_latch (.d(T1), .en(PHI2), .nq(t1_latch_nq));

	ExtraCounter_SRBit sr [3:0] (
		.PHI1(PHI1),
		.PHI2(PHI2),
		.nd({nq[2:0],t1_latch_nq}),
		.n_EN(n_ready),
		.RES(TRES2),
		.nq(nq),
		.nsout({n_T5,n_T4,n_T3,n_T2}));

endmodule // ExtraCounter

module ExtraCounter_SRBit (PHI1, PHI2, nd, n_EN, RES, nq, nsout);

	input PHI1;
	input PHI2;
	input nd;
	input n_EN;
	input RES;
	output nq;
	output nsout;

	wire latch1_q;
	wire latch2_d;

	nor (latch2_d, latch1_q, RES);
	dlatch latch1 (.d(n_EN ? nq : nd), .en(PHI1), .q(latch1_q));
	dlatch latch2 (.d(latch2_d), .en(PHI2), .nq(nq));
	assign nsout = ~latch2_d;

endmodule // ExtraCounter_SRBit

// TBD: The IR register here is implemented a bit unfairly. 
// The real IR uses dual-rails for the clock, and the Enable (FETCH) input is made as a tristate.
// If you repeat 1-in-1, it will definitely not be synthesized..
// We need to think about it.

module IR (
	PHI1, PHI2,
	n_PD, FETCH,
	IR01, IR_out, n_IR_out);

	input PHI1;
	input PHI2;

	input [7:0] n_PD;
	input FETCH;

	output IR01;
	output [7:0] IR_out;
	output [7:0] n_IR_out;

	wire ena;
	and (ena, FETCH, PHI1);

	dlatch ir [7:0] (.d(n_PD), .en(ena), .q(n_IR_out), .nq(IR_out));
	or (IR01, IR_out[0], IR_out[1]);

endmodule // IR

module PreDecode (
	PHI2,
	Z_IR,
	Data_bus, n_PD,
	n_IMPLIED, n_TWOCYCLE);

	input PHI2;

	input Z_IR;

	inout [7:0] Data_bus;
	output [7:0] n_PD;

	output n_IMPLIED;
	output n_TWOCYCLE;

	// Implementation

	wire [7:0] PD;
	wire [7:0] transp_latch_nq;
	wire [7:0] PD_latch_q;
	wire implied;
	wire tmp1;
	wire tmp2;
	wire tmp3;

	dlatch transp_latch [7:0] (.d(Data_bus), .en(1'b1), .nq(transp_latch_nq));
	dlatch PD_latch [7:0] (.d(transp_latch_nq), .en(PHI2), .q(PD_latch_q));
	pnor pd_nors [7:0] (.a0(PD_latch_q), .a1(Z_IR), .x(PD));

	assign n_PD = ~PD;

	nor (implied, PD[0], PD[2], n_PD[3]);
	nor (tmp1, PD[1], PD[4], PD[7]);
	nor (tmp2, n_PD[0], PD[2], n_PD[3], PD[4]);
	nor (tmp3, PD[0], PD[2], PD[3], PD[4], n_PD[7]);

	assign n_IMPLIED = ~implied;
	assign n_TWOCYCLE = ~((implied&~tmp1)|tmp2|tmp3);

endmodule // PreDecode

module Decoder(
	n_T0, n_T1X,
	n_T2, n_T3, n_T4, n_T5, 
	IR01,
	IR, n_IR,
	X);

	input n_T0;
	input n_T1X;
	input n_T2;
	input n_T3;
	input n_T4;
	input n_T5; 
	input IR01;
	input [7:0] IR;
	input [7:0] n_IR;

	output [129:0] X;

	wire [20:0] d;
	assign d = {n_T1X,n_T0,n_IR[5],IR[5],n_IR[6],IR[6],n_IR[2],IR[2],n_IR[3],IR[3],n_IR[4],IR[4],n_IR[7],IR[7],n_IR[0],IR01,n_IR[1],n_T2,n_T3,n_T4,n_T5};

	assign X[0] = ~|{d[5],d[8],d[14],d[15],d[17]};
	assign X[1] = ~|{d[2],d[6],d[10],d[11],d[13]};
	assign X[2] = ~|{d[3],d[6],d[10],d[12],d[13]};
	assign X[3] = ~|{d[5],d[8],d[9],d[12],d[13],d[17],d[19]};
	assign X[4] = ~|{d[5],d[8],d[10],d[12],d[13],d[15],d[17],d[19]};
	assign X[5] = ~|{d[5],d[8],d[9],d[16],d[17],d[19]};
	assign X[6] = ~|{d[3],d[10],d[14]};
	assign X[7] = ~|{d[4],d[8],d[15]};
	assign X[8] = ~|{d[3],d[6],d[9],d[11],d[13]};
	assign X[9] = ~|{d[4],d[8],d[9],d[12],d[13],d[15],d[17],d[19]};
	assign X[10] = ~|{d[4],d[8],d[9],d[12],d[13],d[16],d[17],d[19]};
	assign X[11] = ~|{d[5],d[8],d[9],d[16],d[18],d[19]};
	assign X[12] = ~|{d[4],d[8],d[15],d[17]};
	assign X[13] = ~|{d[4],d[8],d[10],d[12],d[13],d[15],d[17],d[19]};
	assign X[14] = ~|{d[4],d[8],d[15],d[18],d[19]};
	assign X[15] = ~|{d[4],d[8],d[9],d[12],d[13],d[16],d[17],d[20]};
	assign X[16] = ~|{d[5],d[8],d[9],d[12],d[13],d[16],d[18],d[20]};
	assign X[17] = ~|{d[4],d[8],d[10],d[12],d[13],d[15],d[18],d[19]};
	assign X[18] = ~|{d[5],d[8],d[9],d[12],d[13],d[17],d[20]};
	assign X[19] = ~|{d[5],d[8],d[14],d[15],d[18],d[19]};
	assign X[20] = ~|{d[5],d[8],d[9],d[15],d[18],d[19]};
	assign X[21] = ~|{d[5],d[7],d[9],d[11],d[13],d[15],d[18],d[19]};
	assign X[22] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[15],d[17]};
	assign X[23] = ~|{d[5],d[7],d[9],d[12],d[13],d[17],d[19]};
	assign X[24] = ~|{d[1],d[5],d[7],d[9],d[11],d[13],d[16],d[18]};
	assign X[25] = ~|{d[2],d[5],d[7],d[9],d[12],d[13],d[18]};
	assign X[26] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[16],d[17]};
	assign X[27] = ~|{d[4],d[7],d[16],d[18]};
	assign X[28] = ~|{d[3]};
	assign X[29] = ~|{d[6],d[7],d[16],d[17],d[19]};
	assign X[30] = ~|{d[5],d[7],d[9],d[12],d[14],d[16]};
	assign X[31] = ~|{d[3],d[9],d[12],d[14]};
	assign X[32] = ~|{d[6],d[7],d[15],d[17],d[19]};
	assign X[33] = ~|{d[3],d[11]};
	assign X[34] = ~|{d[19]};
	assign X[35] = ~|{d[3],d[5],d[7],d[9],d[13]};
	assign X[36] = ~|{d[2],d[5],d[7],d[9]};
	assign X[37] = ~|{d[1],d[5],d[7],d[9],d[11],d[13],d[15]};
	assign X[38] = ~|{d[1],d[5],d[7],d[9],d[11],d[13],d[16],d[17]};
	assign X[39] = ~|{d[2],d[6],d[9],d[11],d[13]};
	assign X[40] = ~|{d[1],d[6],d[10],d[11],d[13]};
	assign X[41] = ~|{d[3],d[6],d[10],d[11],d[13]};
	assign X[42] = ~|{d[2],d[10],d[12]};
	assign X[43] = ~|{d[5],d[7],d[9],d[12],d[13],d[18]};
	assign X[44] = ~|{d[4],d[8],d[16],d[18]};
	assign X[45] = ~|{d[1],d[6],d[9],d[11],d[13]};
	assign X[46] = ~|{d[2],d[6],d[10],d[11],d[13]};
	assign X[47] = ~|{d[5],d[7],d[9],d[11],d[13],d[16]};
	assign X[48] = ~|{d[3],d[5],d[7],d[9],d[11],d[13],d[15],d[18]};
	assign X[49] = ~|{d[5],d[8],d[9],d[16],d[19]};
	assign X[50] = ~|{d[6],d[8],d[16],d[17],d[19]};
	assign X[51] = ~|{d[6],d[8],d[16],d[18],d[19]};
	assign X[52] = ~|{d[6],d[16],d[18],d[19]};
	assign X[53] = ~|{d[4],d[7],d[15],d[18]};
	assign X[54] = ~|{d[2],d[5],d[7],d[9],d[12],d[14],d[16]};
	assign X[55] = ~|{d[4],d[7],d[15]};
	assign X[56] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[15],d[18]};
	assign X[57] = ~|{d[3],d[5],d[7],d[9],d[13]};
	assign X[58] = ~|{d[5],d[8],d[10],d[12],d[13],d[15],d[17],d[19]};
	assign X[59] = ~|{d[6],d[7],d[20]};
	assign X[60] = ~|{d[6],d[16],d[18],d[20]};
	assign X[61] = ~|{d[4],d[7],d[9],d[12],d[13],d[20]};
	assign X[62] = ~|{d[4],d[8],d[9],d[12],d[13],d[15],d[17],d[19]};
	assign X[63] = ~|{d[5],d[7],d[9],d[12],d[13],d[16],d[18],d[19]};
	assign X[64] = ~|{d[6],d[8],d[15],d[18],d[19]};
	assign X[65] = ~|{d[6],d[19]};
	assign X[66] = ~|{d[5],d[8],d[9],d[12],d[13],d[15],d[18],d[19]};
	assign X[67] = ~|{d[4],d[7],d[9],d[12],d[13],d[19]};
	assign X[68] = ~|{d[4],d[8],d[9],d[12],d[13],d[15],d[18],d[19]};
	assign X[69] = ~|{d[5],d[7],d[9],d[14],d[15],d[18],d[19]};
	assign X[70] = ~|{d[6],d[7],d[15],d[18],d[19]};
	assign X[71] = ~|{d[1],d[10],d[12]};
	assign X[72] = ~|{d[0],d[6],d[10],d[11],d[13]};
	assign X[73] = ~|{d[5],d[10],d[11],d[13],d[19]};
	assign X[74] = ~|{d[3],d[5],d[7],d[9],d[12],d[13],d[16],d[17]};
	assign X[75] = ~|{d[4],d[7],d[9],d[12],d[13],d[16],d[19]};
	assign X[76] = ~|{d[4],d[7],d[16]};
	assign X[77] = ~|{d[3],d[5],d[7],d[9],d[11],d[13],d[15],d[17]};
	assign X[78] = ~|{d[2],d[5],d[7],d[9],d[11],d[13],d[15],d[18]};
	assign X[79] = ~|{d[6],d[8],d[15],d[17]};
	assign X[80] = ~|{d[3],d[5],d[10],d[11],d[13]};
	assign X[81] = ~|{d[3],d[11],d[14]};
	assign X[82] = ~|{d[3],d[6],d[11],d[13]};
	assign X[83] = ~|{d[3],d[12]};
	assign X[84] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[16],d[18]};
	assign X[85] = ~|{d[1]};
	assign X[86] = ~|{d[2]};
	assign X[87] = ~|{d[5],d[7],d[9],d[11],d[13],d[17],d[19]};
	assign X[88] = ~|{d[5],d[7],d[9],d[12],d[14],d[16],d[19]};
	assign X[89] = ~|{d[0],d[6],d[9],d[11],d[13]};
	assign X[90] = ~|{d[2],d[12]};
	assign X[91] = ~|{d[1],d[6],d[10],d[11],d[13]};
	assign X[92] = ~|{d[2],d[10],d[12]};
	assign X[93] = ~|{d[2],d[5],d[10],d[11],d[13]};
	assign X[94] = ~|{d[5],d[7],d[9],d[11],d[13],d[17]};
	assign X[95] = ~|{d[5],d[7],d[9],d[11],d[13],d[15],d[18]};
	assign X[96] = ~|{d[5],d[7],d[9],d[12],d[14],d[16]};
	assign X[97] = ~|{d[8],d[15],d[17]};
	assign X[98] = ~|{d[1],d[5],d[7],d[9],d[11],d[13],d[15],d[17]};
	assign X[99] = ~|{d[3],d[5],d[7],d[9],d[12],d[13],d[15],d[17]};
	assign X[100] = ~|{d[3],d[5],d[7],d[9],d[12],d[13],d[17]};
	assign X[101] = ~|{d[1],d[5],d[7],d[9],d[12],d[14],d[16]};
	assign X[102] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[16]};
	assign X[103] = ~|{d[0],d[5],d[7],d[9],d[11],d[13],d[15],d[18]};
	assign X[104] = ~|{d[3],d[5],d[7],d[9],d[12],d[14],d[16],d[17]};
	assign X[105] = ~|{d[2],d[5],d[7],d[9],d[12],d[13],d[18]};
	assign X[106] = ~|{d[4],d[16]};
	assign X[107] = ~|{d[4],d[7],d[15]};
	assign X[108] = ~|{d[5],d[7],d[10],d[12],d[13],d[16],d[19]};
	assign X[109] = ~|{d[5],d[7],d[9],d[14],d[15],d[18],d[20]};
	assign X[110] = ~|{d[5],d[7],d[10],d[12],d[13],d[15],d[19]};
	assign X[111] = ~|{d[2],d[10],d[11],d[14]};
	assign X[112] = ~|{d[6],d[16],d[18],d[20]};
	assign X[113] = ~|{d[5],d[7],d[9],d[14],d[15],d[18],d[19]};
	assign X[114] = ~|{d[5],d[7],d[9],d[12],d[13],d[15],d[18],d[19]};
	assign X[115] = ~|{d[1],d[5],d[7],d[9],d[11],d[13],d[16],d[17]};
	assign X[116] = ~|{d[6],d[8],d[16],d[17],d[20]};
	assign X[117] = ~|{d[5],d[8],d[9],d[12],d[14],d[16],d[20]};
	assign X[118] = ~|{d[4],d[7],d[9],d[12],d[13],d[15],d[20]};
	assign X[119] = ~|{d[5],d[8],d[9],d[11],d[16],d[20]};
	assign X[120] = ~|{d[5],d[8],d[10],d[12],d[13],d[16],d[19]};
	assign X[121] = ~|{d[15]};
	assign X[122] = ~|{d[2],d[9],d[12],d[14]};
	assign X[123] = ~|{d[3],d[9],d[11],d[14]};
	assign X[124] = ~|{d[0],d[6],d[11],d[13]};
	assign X[125] = ~|{d[1],d[10],d[12]};
	assign X[126] = ~|{d[7]};
	assign X[127] = ~|{d[5],d[8],d[10],d[12],d[13],d[15],d[18]};
	assign X[128] = ~|{d[12],d[13]};
	assign X[129] = ~|{d[5],d[7],d[9],d[12],d[13]};

endmodule // Decoder

module Dispatch (
	PHI1, PHI2,
	BRK6E, RESP, ACR, DORES, PC_DB, RDY, B_OUT, BRFW, n_BRTAKEN, n_TWOCYCLE, n_IMPLIED, n_ADL_PCL, 
	X, 
	ACRL2, T6, T7, TRES2, STOR, Z_IR, FETCH, n_ready, WR, T1, n_T0, T0, n_T1X, n_IPC);

	input PHI1;
	input PHI2;

	input BRK6E;
	input RESP;
	input ACR;
	input DORES;
	input PC_DB;
	input RDY;
	input B_OUT;
	input BRFW;
	input n_BRTAKEN;
	input n_TWOCYCLE;
	input n_IMPLIED;
	input n_ADL_PCL;

	input [129:0] X;

	output ACRL2;
	output T6;
	output T7;
	output TRES2;
	output STOR;
	output Z_IR;
	output FETCH;
	output n_ready;
	output WR;
	output T1;
	output n_T0;
	output T0;
	output n_T1X;
	output n_IPC;

	// Implementation

	wire n_STORE;
	wire n_SHIFT;
	wire n_MemOP;
	wire STOR;
	wire REST;
	wire BR2;
	wire BR3;
	wire NotReadyPhi1;
	wire ACRL1;
	wire ENDS;
	wire n_TRESX;
	wire BRA;

	assign n_STORE = ~X[97];
	nor (n_SHIFT, X[106], X[107]);
	nor (n_MemOP, X[111], X[122], X[123], X[124], X[125]);
	nor (STOR, n_MemOP, n_STORE);
	nand (REST, n_SHIFT, n_STORE);
	assign BR2 = X[80];
	assign BR3 = X[93];

	ReadyRW ready_rw (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.RDY(RDY), 
		.STOR(STOR), 
		.PC_DB(PC_DB), 
		.D98(X[98]), 
		.D100(X[100]), 
		.T6(T6), 
		.T7(T7), 
		.DORES(DORES), 
		.n_ready(n_ready), 
		.NotReadyPhi1(NotReadyPhi1), 
		.WR(WR) );

	ACRLatch acrl (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.ACR(ACR), 
		.NotReadyPhi1(NotReadyPhi1), 
		.ACRL1(ACRL1), 
		.ACRL2(ACRL2) );

	RMWCycle rmw (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.n_ready(n_ready), 
		.n_SHIFT(n_SHIFT), 
		.n_MemOP(n_MemOP), 
		.T6(T6), 
		.T7(T7) );

	TwoCycle twocyc (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.n_ready(n_ready), 
		.RESP(RESP), 
		.ENDS(ENDS), 
		.n_TWOCYCLE(n_TWOCYCLE), 
		.n_TRESX(n_TRESX),
		.BRA(BRA),
		.T0(T0), 
		.T1(T1), 
		.n_T0(n_T0), 
		.n_T1X(n_T1X) );

	CompletionUnit comp_unit (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.n_ready(n_ready), 
		.ACRL1(ACRL1), 
		.REST(REST), 
		.BRK6E(BRK6E), 
		.RESP(RESP), 
		.n_SHIFT(n_SHIFT), 
		.n_MemOP(n_MemOP), 
		.X(X), 
		.T0(T0), 
		.T1(T1), 
		.T7(T7), 
		.n_BRTAKEN(n_BRTAKEN), 
		.BR2(BR2), 
		.BR3(BR3), 
		.TRES2(TRES2), 
		.n_TRESX(n_TRESX), 
		.ENDS(ENDS) );

	IncrementPC incpc (
		.PHI1(PHI1), 
		.PHI2(PHI2), 
		.B_OUT(B_OUT), 
		.NotReadyPhi1(NotReadyPhi1), 
		.BRFW(BRFW), 
		.ACR(ACR), 
		.n_ready(n_ready), 
		.n_BRTAKEN(n_BRTAKEN), 
		.n_ADL_PCL(n_ADL_PCL), 
		.n_IMPLIED(n_IMPLIED), 
		.BR2(BR2),
		.BR3(BR3),
		.BRA(BRA), 
		.n_IPC(n_IPC) );

	FetchUnit fetch_unit (
		.PHI2(PHI2), 
		.B_OUT(B_OUT), 
		.T1(T1), 
		.n_ready(n_ready), 
		.Z_IR(Z_IR), 
		.FETCH(FETCH) );

endmodule // Dispatch

module ReadyRW (PHI1, PHI2, RDY, STOR, PC_DB, D98, D100, T6, T7, DORES, n_ready, NotReadyPhi1, WR);

	input PHI1;
	input PHI2;
	input RDY;
	input STOR;
	input PC_DB;
	input D98;
	input D100;
	input T6;
	input T7;
	input DORES;
	output n_ready;
	output NotReadyPhi1;
	output WR;

	wire wr_latch_d;
	wire wr_latch_q;
	wire ready_latch1_d;
	wire ready_latch1_nq;
	wire ready_latch2_q;
	wire rdydelay_latch1_nq;

	nor (wr_latch_d, STOR, PC_DB, D98, D100, T6, T7);
	nor (ready_latch1_d, RDY, ready_latch2_q);
	nor (WR, n_ready, wr_latch_q, DORES);

	dlatch wr_latch (.d(wr_latch_d), .en(PHI2), .q(wr_latch_q));
	dlatch ready_latch1 (.d(ready_latch1_d), .en(PHI2), .nq(ready_latch1_nq));
	dlatch ready_latch2 (.d(WR), .en(PHI1), .q(ready_latch2_q));
	dlatch rdydelay_latch1 (.d(n_ready), .en(PHI1), .nq(rdydelay_latch1_nq));
	dlatch rdydelay_latch2 (.d(rdydelay_latch1_nq), .en(PHI2), .nq(NotReadyPhi1));

	assign n_ready = ~ready_latch1_nq;

endmodule // ReadyRW

module ACRLatch (PHI1, PHI2, ACR, NotReadyPhi1, ACRL1, ACRL2);

	input PHI1;
	input PHI2;
	input ACR;
	input NotReadyPhi1;
	output ACRL1;
	output ACRL2;

	wire acr_latch1_nq;
	wire ReadyPhi1;
	wire t1;
	wire t2;

	assign ReadyPhi1 = ~NotReadyPhi1;
	and (t1, ~ACR, ReadyPhi1);
	nor (t2, ReadyPhi1, ACRL2);
	nor (ACRL1, t1, t2);

	dlatch acr_latch1 (.d(ACRL1), .en(PHI1), .nq(acr_latch1_nq));
	dlatch acr_latch2 (.d(acr_latch1_nq), .en(PHI2), .nq(ACRL2));

endmodule // ACRLatch

module TwoCycle (PHI1, PHI2, n_ready, RESP, ENDS, n_TWOCYCLE, n_TRESX, BRA, T0, T1, n_T0, n_T1X);

	input PHI1;
	input PHI2;
	input n_ready;
	input RESP;
	input ENDS;
	input n_TWOCYCLE;
	input n_TRESX;
	input BRA;
	output T0;
	output T1;
	output n_T0;
	output n_T1X;

	wire nready_latch_q;
	wire step_latch1_d;
	wire step_latch1_q;
	wire step_latch2_d;
	wire step_latch2_q;
	wire t2;
	wire t1_latch_d;
	wire TRES1;

	nor (step_latch1_d, RESP, nready_latch_q, step_latch2_q);
	nor (step_latch2_d, step_latch1_q, BRA);
	nor (t2, step_latch2_d, n_ready);
	nor (t1_latch_d, t2, ENDS);
	assign TRES1 = ~t1_latch_d;

	dlatch nready_latch (.d(~n_ready), .en(PHI1), .q(nready_latch_q));
	dlatch step_latch1 (.d(step_latch1_d), .en(PHI2), .q(step_latch1_q));
	dlatch step_latch2 (.d(step_latch2_d), .en(PHI1), .q(step_latch2_q));
	dlatch t1_latch (.d(t1_latch_d), .en(PHI1), .nq(T1));
	
	wire comp_latch1_q;
	wire comp_latch2_q;
	wire comp_latch3_q;
	wire t3;
	wire t4;
	wire t0_latch_q;
	wire t1x_latch_q;
	wire t1x_latch_d;

	nor (t3, comp_latch1_q, comp_latch2_q & comp_latch3_q);
	nor (t4, t0_latch_q, t1x_latch_q);
	nor (n_T0, t3, t4);
	assign T0 = ~n_T0;
	nor (t1x_latch_d, t0_latch_q, n_ready);

	dlatch comp_latch1 (.d(TRES1), .en(PHI1), .q(comp_latch1_q));
	dlatch comp_latch2 (.d(n_TWOCYCLE), .en(PHI1), .q(comp_latch2_q));
	dlatch comp_latch3 (.d(n_TRESX), .en(PHI1), .q(comp_latch3_q));
	dlatch t0_latch (.d(n_T0), .en(PHI2), .q(t0_latch_q));
	dlatch t1x_latch (.d(t1x_latch_d), .en(PHI1), .q(t1x_latch_q), .nq(n_T1X));

endmodule // TwoCycle

module RMWCycle (PHI1, PHI2, n_ready, n_SHIFT, n_MemOP, T6, T7);

	input PHI1;
	input PHI2;
	input n_ready;
	input n_SHIFT;
	input n_MemOP;
	output T6;
	output T7;

	wire t67_latch_d;
	wire t67_latch_q;
	wire t6_latch1_d;
	wire t6_latch2_q;
	wire t7_latch1_d;
	wire t7_latch1_nq;
	wire t7_latch2_nq;

	nor (t67_latch_d, n_SHIFT, n_MemOP, n_ready);
	nor (t6_latch1_d, t67_latch_q, t6_latch2_q & n_ready);
	nand (t7_latch1_d, T6, ~n_ready);

	dlatch t67_latch (.d(t67_latch_d), .en(PHI2), .q(t67_latch_q));
	dlatch t6_latch1 (.d(t6_latch1_d), .en(PHI1), .nq(T6));
	dlatch t6_latch2 (.d(T6), .en(PHI2), .q(t6_latch2_q));
	dlatch t7_latch1 (.d(t7_latch1_d), .en(PHI2), .nq(t7_latch1_nq));
	dlatch t7_latch2 (.d(t7_latch1_nq), .en(PHI1), .nq(t7_latch2_nq));

	assign T7 = ~t7_latch2_nq;

endmodule // RMWCycle

module CompletionUnit (PHI1, PHI2, n_ready, ACRL1, REST, BRK6E, RESP, n_SHIFT, n_MemOP, X, T0, T1, T7, n_BRTAKEN, BR2, BR3, TRES2, n_TRESX, ENDS);

	input PHI1;
	input PHI2;
	input n_ready;
	input ACRL1;
	input REST;
	input BRK6E;
	input RESP;
	input n_SHIFT;
	input n_MemOP;
	input [129:0] X;
	input T0;
	input T1;
	input T7;
	input n_BRTAKEN;
	input BR2;
	input BR3;
	output TRES2;
	output n_TRESX;
	output ENDS;

	wire tresx_latch1_q;
	wire tresx_latch1_d;
	wire tresx_latch2_nq;
	wire tresx_latch2_d;
	wire ends_latch1_q;
	wire ends_latch1_d;
	wire ends_latch2_q;
	wire t1;
	wire t2;
	wire t3;
	wire t4;
	wire ENDX;
	wire t5;

	nor (tresx_latch1_d, X[91], X[92]);
	nor (t1, ACRL1, tresx_latch1_q, n_ready, REST);
	nor (n_TRESX, t1, BRK6E, tresx_latch2_nq);

	nor (t2, X[96], ~n_SHIFT, n_MemOP);
	nor (t3, X[100], X[101], X[102], X[103], X[104], X[105]);
	nor (ENDX, t2, T7, ~t3, BR3);
	nor (t4, n_ready, ENDX);
	nor (tresx_latch2_d, RESP, ENDS, t4);

	nor (t5, T0, n_BRTAKEN & BR2);
	assign ends_latch1_d = n_ready ? ~T1 : t5;

	dlatch tresx_latch1 (.d(tresx_latch1_d), .en(PHI2), .q(tresx_latch1_q));
	dlatch tresx_latch2 (.d(tresx_latch2_d), .en(PHI2), .nq(tresx_latch2_nq));
	dlatch tres2_latch (.d(n_TRESX), .en(PHI1), .nq(TRES2));
	dlatch ends_latch1 (.d(ends_latch1_d), .en(PHI2), .q(ends_latch1_q));
	dlatch ends_latch2 (.d(RESP), .en(PHI2), .q(ends_latch2_q));

	nor (ENDS, ends_latch1_q, ends_latch2_q);

endmodule // CompletionUnit

module IncrementPC (PHI1, PHI2, B_OUT, NotReadyPhi1, BRFW, ACR, n_ready, n_BRTAKEN, n_ADL_PCL, n_IMPLIED, BR2, BR3, BRA, n_IPC);

	input PHI1;
	input PHI2;
	input B_OUT;
	input NotReadyPhi1;
	input BRFW;
	input ACR;
	input n_ready;
	input n_BRTAKEN;
	input n_ADL_PCL;
	input n_IMPLIED;
	input BR2;
	input BR3;
	output BRA;
	output n_IPC;

	wire br_latch2_d;
	wire br_latch2_nq;
	wire br_latch1_q;
	wire br_latch1_d;
	wire ipc_latch1_q;
	wire ipc_latch2_q;
	wire ipc_latch3_q;
	wire ipc_latch3_d;
	wire t1;
	wire t2;

	nor (br_latch2_d, ~BR3, NotReadyPhi1);
	xor (t1, BRFW, ~ACR);
	and (BRA, t1, ~br_latch2_nq);
	nor (t2, n_ADL_PCL, BR2 | BR3);
	nor (br_latch1_d, t2, n_BRTAKEN & BR2);
	nor (ipc_latch3_d, n_ready, br_latch1_q, ~n_IMPLIED);

	dlatch br_latch2 (.d(br_latch2_d), .en(PHI2), .nq(br_latch2_nq));
	dlatch br_latch1 (.d(br_latch1_d), .en(PHI2), .q(br_latch1_q));
	dlatch ipc_latch1 (.d(B_OUT), .en(PHI1), .q(ipc_latch1_q));
	dlatch ipc_latch2 (.d(BRA), .en(PHI1), .q(ipc_latch2_q));
	dlatch ipc_latch3 (.d(ipc_latch3_d), .en(PHI1), .q(ipc_latch3_q));

	nand (n_IPC, ipc_latch1_q, ipc_latch2_q | ipc_latch3_q);

endmodule // IncrementPC

module FetchUnit (PHI2, B_OUT, T1, n_ready, Z_IR, FETCH);

	input PHI2;
	input B_OUT;
	input T1;
	input n_ready;
	output Z_IR;
	output FETCH;

	wire fetch_latch_nq;

	dlatch fetch_latch (.d(T1), .en(PHI2), .nq(fetch_latch_nq));

	nor (FETCH, fetch_latch_nq, n_ready);
	nand (Z_IR, FETCH, B_OUT);

endmodule // FetchUnit

module Regs_Control (
	PHI1, PHI2, 
	STOR, n_ready, 
	X,
	STXY, n_SBXY, STKOP, 
	Y_SB, X_SB, S_SB, SB_X, SB_Y, SB_S, S_S, S_ADL);

	input PHI1;
	input PHI2;

	input STOR;
	input n_ready;

	input [129:0] X;

	output STXY;
	output n_SBXY;
	output STKOP;

	output Y_SB;
	output X_SB;
	output S_SB;
	output SB_X;
	output SB_Y;
	output SB_S;
	output S_S;
	output S_ADL;

	wire nYSB;
	wire nXSB;
	wire nSBX;
	wire nSBY;
	wire nSBS;
	wire nSADL;
	wire tmp1;

	wire nready_latch_q;
	wire nready_latch_nq;
	wire ysb_latch_q;
	wire xsb_latch_q;
	wire sbx_latch_q;
	wire sby_latch_q;
	wire sbs_latch_q;
	wire ss_latch_q;

	assign nYSB = ~(X[1] | X[2] | X[3] | X[4] | X[5] | (X[6]&X[7]) | (X[0]&STOR));
	assign nXSB = ~(X[8] | X[9] | X[10] | X[11] | X[13] | (X[6]&~X[7]) | (X[12]&STOR));
	assign nSBX = ~(X[14] | X[15] | X[16]);
	assign nSBY = ~(X[18] | X[19] | X[20]);
	assign tmp1 = ~(X[21] | X[22] | X[23] | X[24] | X[25] | X[26]);
	assign nSBS = ~(X[13] | ~(~X[48]|n_ready) | STKOP);
	assign nSADL = ~((X[21]&nready_latch_nq) | X[35]);

	assign STXY = ~((X[0]&STOR) | (X[12]&STOR));
	assign n_SBXY = ~(nSBX & nSBY);
	assign STKOP = ~(tmp1|nready_latch_q);

	dlatch nready_latch (.d(n_ready), .en(PHI1), .q(nready_latch_q), .nq(nready_latch_nq));
	dlatch ysb_latch (.d(nYSB), .en(PHI2), .q(ysb_latch_q));
	dlatch xsb_latch (.d(nXSB), .en(PHI2), .q(xsb_latch_q));
	dlatch ssb_latch (.d(~X[17]), .en(PHI2), .nq(S_SB));
	dlatch sbx_latch (.d(nSBX), .en(PHI2), .q(sbx_latch_q));
	dlatch sby_latch (.d(nSBY), .en(PHI2), .q(sby_latch_q));
	dlatch sbs_latch (.d(nSBS), .en(PHI2), .q(sbs_latch_q));
	dlatch ss_latch (.d(~nSBS), .en(PHI2), .q(ss_latch_q));
	dlatch sadl_latch (.d(nSADL), .en(PHI2), .nq(S_ADL));

	assign Y_SB = ~(ysb_latch_q|PHI2);
	assign X_SB = ~(xsb_latch_q|PHI2);
	assign SB_X = ~(sbx_latch_q|PHI2);
	assign SB_Y = ~(sby_latch_q|PHI2);
	assign SB_S = ~(sbs_latch_q|PHI2);
	assign S_S = ~(ss_latch_q|PHI2);

endmodule  // Regs_Control

module ALU_Control (
	PHI1, PHI2,
	BRFW, n_ready, BRK6E, STKOP, PGX,
	X,
	T0, T1, T6, T7,
	n_DOUT, n_COUT,
	INC_SB, SR, AND,
	NDB_ADD, DB_ADD, Z_ADD, SB_ADD, ADL_ADD, ADD_SB06, ADD_SB7, ADD_ADL, ANDS, EORS, ORS, SRS, SUMS, n_ACIN, n_DAA, n_DSA);

	input PHI1;
	input PHI2;

	input BRFW;
	input n_ready;
	input BRK6E;
	input STKOP;
	input PGX;
	
	input [129:0] X;
	
	input T0;
	input T1;
	input T6;
	input T7;
	
	input n_DOUT;
	input n_COUT;

	output INC_SB;
	output SR;
	output AND;

	output NDB_ADD;
	output DB_ADD;
	output Z_ADD;
	output SB_ADD;
	output ADL_ADD;
	output ADD_SB06;
	output ADD_SB7;
	output ADD_ADL;
	output ANDS;
	output EORS;
	output ORS;
	output SRS;
	output SUMS;
	output n_ACIN;
	output n_DAA;
	output n_DSA;

	// Implementation

	wire SBC0;
	wire BRX;
	wire CSET;
	wire OR;
	wire NOADL;	
	wire sb_add; 		// internal #SB/ADD
	wire n_ndb_add; 	// internal #NDB/ADD
	wire n_adl_add; 	// internal #ADL/ADD
	wire EOR;
	wire D_OUT;
	wire nADDSB06;
	wire nADDSB7;

	assign SBC0 = X[51];
	or (BRX, X[49], X[50], ~(~X[93]|BRFW));
	assign CSET = ~((~((~(n_COUT|(~(T0|T6))))&(X[52]|X[53])))&~X[54]);
	or (OR, X[32], n_ready);
	or (AND, X[69], X[70]);
	or (SR, X[75], (X[76]&T6));
	nor (NOADL, X[84], X[85], X[86], X[87], X[88], X[89], X[26]);
	or (INC_SB, X[39], X[40], X[41], X[42], X[43], (X[44]&T6));
	nor (sb_add, X[30], X[31], X[45], X[48], INC_SB, X[47], BRK6E, n_ready);
	nand (n_ndb_add, (BRX|X[56]|SBC0), ~n_ready);
	nor (n_adl_add, (X[33]&~X[34]), X[35], X[36], X[37], X[38], X[39], n_ready);
	assign EOR = X[29];
	assign D_OUT = ~n_DOUT;
	nor (nADDSB06, STKOP, X[56], PGX, T1, T7);

	// Carry in

	wire acin_latch1_q;
	wire acin_latch2_q;
	wire acin_latch3_q;
	wire acin_latch4_q;
	wire acin_latch5_nq;

	dlatch acin_latch1 (.d(~(n_adl_add|~X[47])), .en(PHI2), .q(acin_latch1_q));
	dlatch acin_latch2 (.d(INC_SB), .en(PHI2), .q(acin_latch2_q));
	dlatch acin_latch3 (.d(BRX), .en(PHI2), .q(acin_latch3_q));
	dlatch acin_latch4 (.d(CSET), .en(PHI2), .q(acin_latch4_q));
	dlatch acin_latch5 (.d(~(acin_latch1_q|acin_latch2_q|acin_latch3_q|acin_latch4_q)), .en(PHI1), .nq(acin_latch5_nq));

	assign n_ACIN = ~acin_latch5_nq;

	// ->ADD

	wire ndbadd_latch_q;
	wire dbadd_latch_q;
	wire zadd_latch_q;
	wire sbadd_latch_q;
	wire adladd_latch_q;

	dlatch ndbadd_latch (.d(n_ndb_add), .en(PHI2), .q(ndbadd_latch_q));
	dlatch dbadd_latch (.d(~(n_ndb_add&n_adl_add)), .en(PHI2), .q(dbadd_latch_q));
	dlatch zadd_latch (.d(sb_add), .en(PHI2), .q(zadd_latch_q));
	dlatch sbadd_latch (.d(~sb_add), .en(PHI2), .q(sbadd_latch_q));
	dlatch adladd_latch (.d(n_adl_add), .en(PHI2), .q(adladd_latch_q));

	nor (NDB_ADD, ndbadd_latch_q, PHI2);
	nor (DB_ADD, dbadd_latch_q, PHI2);
	nor (Z_ADD, zadd_latch_q, PHI2);
	nor (SB_ADD, sbadd_latch_q, PHI2);
	nor (ADL_ADD, adladd_latch_q, PHI2);

	// ALU ops

	wire ands_latch1_nq;
	wire eors_latch1_nq;
	wire ors_latch1_nq;
	wire srs_latch1_nq;
	wire sums_latch1_nq;

	dlatch ands_latch1 (.d(AND), .en(PHI2), .nq(ands_latch1_nq));
	dlatch ands_latch2 (.d(ands_latch1_nq), .en(PHI1), .nq(ANDS));
	dlatch eors_latch1 (.d(EOR), .en(PHI2), .nq(eors_latch1_nq));
	dlatch eors_latch2 (.d(eors_latch1_nq), .en(PHI1), .nq(EORS));
	dlatch ors_latch1 (.d(OR), .en(PHI2), .nq(ors_latch1_nq));
	dlatch ors_latch2 (.d(ors_latch1_nq), .en(PHI1), .nq(ORS));
	dlatch srs_latch1 (.d(SR), .en(PHI2), .nq(srs_latch1_nq));
	dlatch srs_latch2 (.d(srs_latch1_nq), .en(PHI1), .nq(SRS));
	dlatch sums_latch1 (.d(~(AND|EOR|OR|SR)), .en(PHI2), .nq(sums_latch1_nq));
	dlatch sums_latch2 (.d(sums_latch1_nq), .en(PHI1), .nq(SUMS));

	// BCD

	wire DAATemp;
	wire DSATemp;
	wire daa_latch1_nq;
	wire dsa_latch1_nq;

	assign DAATemp = ~(~(~(X[52]&D_OUT)|SBC0));
	nand (DSATemp, D_OUT, SBC0);

	dlatch daa_latch1 (.d(DAATemp), .en(PHI2), .nq(daa_latch1_nq));
	dlatch daa_latch2 (.d(daa_latch1_nq), .en(PHI1), .nq(n_DAA));
	dlatch dsa_latch1 (.d(DSATemp), .en(PHI2), .nq(dsa_latch1_nq));
	dlatch dsa_latch2 (.d(dsa_latch1_nq), .en(PHI1), .nq(n_DSA));

	// ADD->

	dlatch addsb7_latch (.d(~(nADDSB06|nADDSB7)), .en(PHI2), .q(ADD_SB7)); 		// care!
	dlatch addsb06_latch (.d(nADDSB06), .en(PHI2), .nq(ADD_SB06));
	dlatch addadl_latch (.d(~(~(NOADL|PGX))), .en(PHI2), .nq(ADD_ADL));

	// https://www.youtube.com/watch?v=Uk_QC1eU0Fg

	ROR_Unit ror (.PHI1(PHI1), .PHI2(PHI2), .n_COUT(n_COUT), .n_ready(n_ready), .SR(SR), .n_ROR(~X[27]), .nADDSB7(nADDSB7) );

endmodule // ALU_Control

module ROR_Unit (PHI1, PHI2, n_COUT, n_ready, SR, n_ROR, nADDSB7);

	input PHI1;
	input PHI2;
	input n_COUT;
	input n_ready;
	input SR;
	input n_ROR;
	output nADDSB7;

	wire cout_latch_nq;
	wire nready_latch_q;
	wire mux_latch1_q;
	wire ff_latch1_nq;
	wire ff_latch2_q;
	wire sr_latch1_nq;
	wire sr_latch2_q;

	wire mux_latch_in;
	nor (mux_latch_in, nready_latch_q, ~SR);

	wire ff1_d;
	assign ff1_d = ~(mux_latch1_q ? cout_latch_nq : ff_latch2_q);

	dlatch cout_latch (.d(~n_COUT), .en(PHI2), .nq(cout_latch_nq));
	dlatch nready_latch (.d(n_ready), .en(PHI1), .q(nready_latch_q));
	dlatch mux_latch1 (.d(mux_latch_in), .en(PHI2), .q(mux_latch1_q));
	dlatch ff_latch1 (.d(ff1_d), .en(PHI1), .nq(ff_latch1_nq));
	dlatch ff_latch2 (.d(ff_latch1_nq), .en(PHI2), .q(ff_latch2_q));
	dlatch sr_latch1 (.d(SR), .en(PHI2), .nq(sr_latch1_nq));
	dlatch sr_latch2 (.d(sr_latch1_nq), .en(PHI1), .q(sr_latch2_q));

	nor (nADDSB7, ff_latch1_nq, sr_latch2_q, n_ROR);

endmodule // ROR_Unit

module Bus_Control (
	PHI1, PHI2,
	n_SBXY, AND, STOR, Z_ADL0, ACRL2, DL_PCH, n_ready, INC_SB, BRK6E, STXY, n_PCH_PCH,
	T0, T1, T6, T7, BR0, 
	X,
	ZTST, PGX, 
	Z_ADH0, Z_ADH17, SB_AC, ADL_ABL, AC_SB, SB_DB, AC_DB, SB_ADH, DL_ADH, DL_ADL, ADH_ABH, DL_DB);

	input PHI1;
	input PHI2;

	input n_SBXY;
	input AND;
	input STOR;
	input Z_ADL0;
	input ACRL2;
	input DL_PCH;
	input n_ready;
	input INC_SB;
	input BRK6E;
	input STXY;
	input n_PCH_PCH;

	input T0;
	input T1;
	input T6;
	input T7;
	input BR0;

	input [129:0] X;

	output ZTST;
	output PGX;

	output Z_ADH0;
	output Z_ADH17;
	output SB_AC;
	output ADL_ABL;
	output AC_SB;
	output SB_DB;
	output AC_DB;
	output SB_ADH;
	output DL_ADH;
	output DL_ADL;
	output ADH_ABH;
	output DL_DB;

	wire nready_latch_nq;
	wire sb_ac_latch_q;
	wire ac_sb_latch_q;
	wire ac_db_latch_q;

	wire nDLADL;
	nor (nDLADL, X[81], X[82]);
	wire nSBAC;
	nor (nSBAC, X[58], X[59], X[60], X[61], X[62], X[63], X[64]);
	wire temp1;
	nand (temp1, T6, X[55]);
	wire temp2;
	nor (temp2, nZTST, AND);
	wire nSBDB;
	nor (nSBDB, ~temp1, temp2, X[67], T1, BR2, JSXY);
	wire JSXY;
	wire JSR2;
	assign JSR2 = X[48];
	nand (JSXY, ~JSR2, STXY);
	wire JMP4;
	assign JMP4 = X[101];
	wire JSR5;
	assign JSR5 = X[56];
	wire nZADH17;
	nor (nZADH17, X[57], ~nDLADL);
	wire nIND;
	wire RTS5;
	assign RTS5 = X[84];
	wire pp;
	assign pp = X[129];
	nor (nIND, X[89], (X[90] & ~pp), X[91], RTS5);
	wire ABS2;
	assign ABS2 = X[83] & ~pp;
	wire nABS2_T0;
	nor (nABS2_T0, ABS2, T0);
	wire temp11;
	wire IMPLIED;
	assign IMPLIED = X[128] & ~pp;
	nor (temp11, nABS2_T0, IMPLIED);
	wire nDLDB;
	nor (nDLDB, BR2, temp11, ~temp5, JMP4, T6);
	wire temp5;
	nor (temp5, INC_SB, X[45], BRK6E, X[46], X[47], JSR2);
	wire nSBADH;
	nor (nSBADH, PGX, BR3);
	wire nr;
	nand (nr, ACRL2, nready_latch_nq);
	wire SBA;
	nor (SBA, nSBADH, nr);
	wire temp3;
	nor (temp3, IND, T2, n_PCH_PCH, JSR5);
	wire temp4;
	nor (temp4, n_ready, temp3);
	wire temp6;
	or (temp6, SBA, temp5);
	wire temp7;
	assign temp7 = temp6 & ~BR3;
	wire nADHABH;
	nor (nADHABH, Z_ADL0, temp7);
	wire nDLADH;
	nor (nDLADH, DL_PCH, IND);
	wire nACDB;
	wire STA;
	assign STA = X[79];
	nor (nACDB, X[74], STA & STOR);
	wire nACSB;
	nor (nACSB, X[65] & ~X[64], X[66], X[67], X[68], AND);
	wire temp8;
	nor (temp8, X[71], X[72]);
	nand (PGX, temp8, ~BR0);
	wire temp9;
	nor (temp9, ~temp8, n_ready);
	wire nRMW;
	nor (nRMW, T6, T7);
	wire nADLABL;
	nand (nADLABL, nRMW, temp9);
	nor (nZTST, n_SBXY, ~nSBAC, T7, AND);

	dlatch nready_latch (.d(n_ready), .en(PHI1), .nq(nready_latch_nq) );

	dlatch z_adh0_latch (.d(nDLADL), .en(PHI2), .nq(Z_ADH0) );
	dlatch z_adh17_latch (.d(nZADH17), .en(PHI2), .nq(Z_ADH17) );
	dlatch sb_ac_latch (.d(nSBAC), .en(PHI2), .q(sb_ac_latch_q) );
	dlatch adl_abl_latch (.d(nADLABL), .en(PHI2), .nq(ADL_ABL) );
	dlatch ac_sb_latch (.d(nACSB), .en(PHI2), .q(ac_sb_latch_q) );
	dlatch sb_db_latch (.d(nSBDB), .en(PHI2), .nq(SB_DB) );
	dlatch ac_db_latch (.d(nACDB), .en(PHI2), .q(ac_db_latch_q) );
	dlatch sb_adh_latch (.d(nSBADH), .en(PHI2), .nq(SB_ADH) );
	dlatch dl_adh_latch (.d(nDLADH), .en(PHI2), .nq(DL_ADH) );
	dlatch dl_adl_latch (.d(nDLADL), .en(PHI2), .nq(DL_ADL) );
	dlatch adh_abh_latch (.d(nADHABH), .en(PHI2), .nq(ADH_ABH) );
	dlatch dl_db_latch (.d(nDLDB), .en(PHI2), .nq(DL_DB) );

	nor (SB_AC, sb_ac_latch_q, PHI2);
	nor (AC_SB, ac_sb_latch_q, PHI2);
	nor (AC_DB, ac_db_latch_q, PHI2);
	assign ZTST = ~nZTST;

endmodule // Bus_Control

module PC_Control (
	PHI1, PHI2,
	n_ready, T0, T1, BR0,
	X,
	PCL_DB, PCH_DB, PC_DB, PCL_ADL, PCH_ADH, PCL_PCL, ADL_PCL, n_ADL_PCL, DL_PCH, ADH_PCH, PCH_PCH, n_PCH_PCH);

	input PHI1;
	input PHI2;

	input n_ready;
	input T0;
	input T1;
	input BR0;

	input [129:0] X;

	output PCL_DB;
	output PCH_DB;
	output PC_DB;
	output PCL_ADL;
	output PCH_ADH;
	output PCL_PCL;
	output ADL_PCL;
	output n_ADL_PCL;
	output DL_PCH;
	output ADH_PCH;
	output PCH_PCH;
	output n_PCH_PCH;

	wire BR2;
	wire BR3;
	wire n_PCH_DB;
	wire n_PCL_DB;
	wire ABS_2;
	wire JB;
	wire n_PCL_ADL;
	wire n_ADL_PCL;
	wire n_ADH_PCH;
	wire n_T0;
	wire t1;
	wire t2;
	wire t3;
	wire nready_latch_q;
	wire pch_db_latch1_q;
	wire pcl_db_latch1_nq;
	wire pcl_pcl_latch_q;
	wire adl_pcl_latch_q;
	wire adh_pch_latch_q;
	wire pch_pch_latch_q;
	wire pcl_db_latch1_d;
	wire pch_adh_latch_d;

	assign BR2 = X[80];
	assign BR3 = X[93];
	not (n_T0, T0);
	nor (t1, JB, nready_latch_q);
	nor (t2, t1, n_T0);
	nor (n_PCH_DB, X[77], X[78]);
	nor (JB, X[94], X[95], X[96]);
	assign ABS_2 = X[83] & ~X[129];
	nor (n_PCL_ADL, T1, X[56], ABS_2, t2, BR2);
	nor (n_ADL_PCL, ~n_PCL_ADL, X[84], T0, BR3 & ~nready_latch_q);
	nor (n_ADH_PCH, X[84], ABS_2, T0, T1, BR2, BR3 );
	nor (DL_PCH, n_T0, JB);
	nor (pcl_db_latch1_d, pch_db_latch1_q, n_ready);
	nor (t3, n_PCL_ADL, DL_PCH, BR0);
	nor (pch_adh_latch_d, t3, BR3);
	nand (PC_DB, n_PCL_DB, n_PCH_DB);

	dlatch nready_latch (.d(n_ready), .en(PHI1), .q(nready_latch_q) );
	
	dlatch pcl_db_latch1 (.d(pcl_db_latch1_d), .en(PHI1), .nq(n_PCL_DB) );
	dlatch pch_db_latch1 (.d(n_PCH_DB), .en(PHI2), .q(pch_db_latch1_q) );
	dlatch pcl_db_latch2 (.d(n_PCL_DB), .en(PHI2), .nq(PCL_DB) );
	dlatch pch_db_latch2 (.d(n_PCH_DB), .en(PHI2), .nq(PCH_DB) );

	dlatch pcl_adl_latch (.d(n_PCL_ADL), .en(PHI2), .nq(PCL_ADL) );
	dlatch pch_adh_latch (.d(pch_adh_latch_d), .en(PHI2), .nq(PCH_ADH) );
	dlatch pcl_pcl_latch (.d(~n_ADL_PCL), .en(PHI2), .q(pcl_pcl_latch_q) );
	dlatch adl_pcl_latch (.d(n_ADL_PCL), .en(PHI2), .q(adl_pcl_latch_q) );
	dlatch adh_pch_latch (.d(n_ADH_PCH), .en(PHI2), .q(adh_pch_latch_q) );
	dlatch pch_pch_latch (.d(n_PCH_PCH), .en(PHI2), .q(pch_pch_latch_q) );

	nor (PCL_PCL, pcl_pcl_latch_q, PHI2);
	nor (ADL_PCL, adl_pcl_latch_q, PHI2);
	nor (ADH_PCH, adh_pch_latch_q, PHI2);
	nor (PCH_PCH, pch_pch_latch_q, PHI2);
	not (n_PCH_PCH, n_ADH_PCH);

endmodule // PC_Control

module Flags_Control (
	PHI2, X,
	T7, ZTST, n_ready, SR,
	P_DB, IR5_I, IR5_C, IR5_D, Z_V, ACR_C, DBZ_Z, DB_N, DB_P, DB_C, DB_V);

	input PHI2;

	input [129:0] X;

	input T7;
	input ZTST;
	input n_ready;
	input SR;

	output P_DB;
	output IR5_I;
	output IR5_C;
	output IR5_D;
	output Z_V;
	output ACR_C;
	output DBZ_Z;
	output DB_N;
	output DB_P;
	output DB_C;
	output DB_V;

	wire dbz_latch_q;
	wire dbn_latch_q;
	wire pin_latch_q;
	wire bit_latch_q;

	wire nARITH;
	assign nARITH = ~((X[107] & T7) | X[112] | X[116] | X[117] | X[118] | X[119]);

	dlatch pdb_latch (.d(~(X[98]|X[99])), .en(PHI2), .nq(P_DB));
	dlatch iri_latch (.d(~X[108]), .en(PHI2), .nq(IR5_I));
	dlatch irc_latch (.d(~X[110]), .en(PHI2), .nq(IR5_C));
	dlatch ird_latch (.d(~X[120]), .en(PHI2), .nq(IR5_D));
	dlatch zv_latch (.d(~X[127]), .en(PHI2), .nq(Z_V));
	dlatch acrc_latch (.d(nARITH), .en(PHI2), .nq(ACR_C));
	dlatch dbz_latch (.d(~(ACR_C|ZTST|X[109])), .en(PHI2), .q(dbz_latch_q), .nq(DBZ_Z));
	dlatch dbn_latch (.d(X[109]), .en(PHI2), .q(dbn_latch_q));
	dlatch dbc_latch (.d(~(SR|DB_P)), .en(PHI2), .nq(DB_C));
	dlatch pin_latch (.d(~(X[114]|X[115])), .en(PHI2), .q(pin_latch_q));
	dlatch bit_latch (.d(~X[113]), .en(PHI2), .q(bit_latch_q));

	assign DB_N = ~((dbz_latch_q&pin_latch_q) | dbn_latch_q);
	assign DB_P = ~(pin_latch_q | n_ready);
	assign DB_V = ~(pin_latch_q & bit_latch_q);

endmodule // Flags_Control

module Flags (
	PHI1, PHI2,
	P_DB, DB_P, DBZ_Z, DB_N, IR5_C, DB_C, ACR_C, IR5_D, IR5_I, DB_V, Z_V,
	ACR, AVR, B_OUT, n_IR5, BRK6E, Dec112, SO_frompad, 
	DB,
	n_ZOUT, n_NOUT, n_COUT, n_DOUT, n_IOUT, n_VOUT);

	input PHI1;
	input PHI2;

	input P_DB;
	input DB_P;
	input DBZ_Z;
	input DB_N;
	input IR5_C;
	input DB_C;
	input ACR_C;
	input IR5_D;
	input IR5_I;
	input DB_V;
	input Z_V;

	input ACR;
	input AVR;
	input B_OUT; 				// From the BRK sequencer
	input n_IR5;
	input BRK6E;
	input Dec112; 				// AVR/V
	input SO_frompad; 		// Directly from the pad

	inout [7:0] DB;

	output n_ZOUT;
	output n_NOUT;
	output n_COUT;
	output n_DOUT;
	output n_IOUT;
	output n_VOUT;

	wire DBZ;
	nor (DBZ, DB[0], DB[1], DB[2], DB[3], DB[4], DB[5], DB[6], DB[7]);

	// Z Flag

	wire z_latch1_d;
	assign z_latch1_d = ~( (~DB[1] & DB_P) | (~DBZ & DBZ_Z) | (~(DB_P|DBZ_Z) & z_latch2_q) );  	// 222-aoi
	dlatch z_latch1 (.d(z_latch1_d), .en(PHI1), .nq(n_ZOUT) );
	dlatch z_latch2 (.d(n_ZOUT), .en(PHI2), .q(z_latch2_q) );
	wire z_latch2_q;

	// N Flag

	wire n_latch1_d;
	assign n_latch1_d = ~( (~DB[7] & DB_N) | (~DB_N & n_latch2_q) ); 		// 22-aoi
	dlatch n_latch1 (.d(n_latch1_d), .en(PHI1), .nq(n_NOUT) );
	dlatch n_latch2 (.d(n_NOUT), .en(PHI2), .q(n_latch2_q) );
	wire n_latch2_q;

	// C Flag

	wire c_latch1_d;
	assign c_latch1_d = ~( (n_IR5 & IR5_C) | (~ACR & ACR_C) | (~DB[0] & DB_C) | (~(DB_C|IR5_C|ACR_C) & c_latch2_q) ); 		// 2222-aoi
	dlatch c_latch1 (.d(c_latch1_d), .en(PHI1), .nq(n_COUT) );
	dlatch c_latch2 (.d(n_COUT), .en(PHI2), .q(c_latch2_q) );
	wire c_latch2_q;

	// D Flag

	wire d_latch1_d;
	assign d_latch1_d = ~( (IR5_D & n_IR5) | (~DB[3] & DB_P) | (~(IR5_D|DB_P) & d_latch2_q) ); 		// 222-aoi
	dlatch d_latch1 (.d(d_latch1_d), .en(PHI1), .nq(n_DOUT) );
	dlatch d_latch2 (.d(n_DOUT), .en(PHI2), .q(d_latch2_q) );
	wire d_latch2_q;

	// I Flag

	wire i_latch1_nq;
	wire i_latch1_d;
	assign i_latch1_d = ~( (n_IR5 & IR5_I) | (~DB[2] & DB_P) | (~(DB_P|IR5_I) & i_latch2_q) ); 		// 222-aoi
	dlatch i_latch1 (.d(i_latch1_d), .en(PHI1), .nq(i_latch1_nq));
	assign n_IOUT = i_latch1_nq & ~BRK6E;
	dlatch i_latch2 (.d(n_IOUT), .en(PHI2), .q(i_latch2_q) );
	wire i_latch2_q;

	// V Flag

	wire AVR_V;
	assign AVR_V = Dec112;
	dlatch avr_latch (.d(AVR_V), .en(PHI2), .q(avr_latch_q) );
	wire avr_latch_q;
	wire v_latch1_d;
	assign v_latch1_d = ~( (~AVR & avr_latch_q) | (~DB[6] & DB_V) | ( ~(DB_V|avr_latch_q|One_V) & v_latch2_q) | Z_V ); 	// 2221-aoi
	dlatch v_latch1 (.d(v_latch1_d), .en(PHI1), .nq(n_VOUT) );
	dlatch v_latch2 (.d(n_VOUT), .en(PHI2), .q(v_latch2_q) );
	wire v_latch2_q;

	// 1/V
	// SO Pad falling edge detector is integrated right there

	wire One_V;
	dlatch so_latch1 (.d(~SO_frompad), .en(PHI1), .nq(so_latch1_nq) );
	wire so_latch1_nq;
	dlatch so_latch2 (.d(so_latch1_nq), .en(PHI2), .nq(so_latch2_nq) );
	wire so_latch2_nq;
	dlatch so_latch3 (.d(so_latch2_nq), .en(PHI1), .q(so_latch3_q) );
	wire so_latch3_q;
	wire vset_latch_d;
	nor (vset_latch_d, so_latch3_q, so_latch1_nq);
	dlatch vset_latch (.d(vset_latch_d), .en(PHI2), .q(One_V) );

	// decomplements and debug at the same time

	wire COUT, ZOUT, IOUT, DOUT, VOUT, NOUT;
	not (COUT, n_COUT);
	not (ZOUT, n_ZOUT);
	not (IOUT, n_IOUT);
	not (DOUT, n_DOUT);
	not (VOUT, n_VOUT);
	not (NOUT, n_NOUT);

	// Flags Out

	assign DB[0] = P_DB ? COUT : 1'bz;
	assign DB[1] = P_DB ? ZOUT : 1'bz;
	assign DB[2] = P_DB ? IOUT : 1'bz;
	assign DB[3] = P_DB ? DOUT : 1'bz;
	assign DB[4] = P_DB ? B_OUT : 1'bz; 		// From the BRK sequencer
	assign DB[5] = 1'bz;
	assign DB[6] = P_DB ? VOUT : 1'bz;
	assign DB[7] = P_DB ? NOUT : 1'bz;

endmodule // Flags

module BranchLogic (
	PHI1, PHI2,
	n_IR5, X, n_COUT, n_VOUT, n_NOUT, n_ZOUT, DB, BR2,
	n_BRTAKEN, BRFW);

	input PHI1;
	input PHI2;

	input n_IR5;
	input [129:0] X;
	input n_COUT;
	input n_VOUT;
	input n_NOUT;
	input n_ZOUT;
	inout [7:0] DB;
	input BR2;

	output n_BRTAKEN;
	output BRFW;

	// Branch forward

	wire br2_latch_q;
	wire br2_latch_nq;
	wire brfw_latch1_nq;
	wire brfw_latch2_q;
	wire brfw_latch1_d;

	dlatch br2_latch (.d(BR2), .en(PHI2), .q(br2_latch_q), .nq(br2_latch_nq));
	nor (brfw_latch1_d, br2_latch_q & ~DB[7], br2_latch_nq & brfw_latch2_q);
	dlatch brfw_latch1 (.d(brfw_latch1_d), .en(PHI1), .nq(brfw_latch1_nq));
	dlatch brfw_latch2 (.d(brfw_latch1_nq), .en(PHI2), .q(brfw_latch2_q));
	not (BRFW, brfw_latch1_nq);

	// Branch taken

	wire n_IR6;
	wire IR6;
	wire n_IR7;
	wire IR7;
	assign n_IR6 = X[121];
	assign n_IR7 = X[126];
	not (IR6, n_IR6);
	not (IR7, n_IR7);

	// The flag test logic is a 2-4 multiplexer

	wire ctest;
	wire vtest;
	wire ntest;
	wire ztest;

	nor (ctest, IR6, n_IR7, n_COUT);
	nor (vtest, n_IR6, IR7, n_VOUT);
	nor (ntest, IR6, IR7, n_NOUT);
	nor (ztest, n_IR6, n_IR7, n_ZOUT);

	wire mux_out;
	nor (mux_out, ctest, vtest, ntest, ztest);

	xor (n_BRTAKEN, mux_out, n_IR5);

endmodule // BranchLogic

// Contains the implementation of the address bus output terminals and the ABH/ABL registers where the actual address value is stored.
// Memo: The 6502 processor sets the address for the next operation during the PHI1 phase (together with R/W mode).

module AddrBusBit (
	PHI1, PHI2,
	ADX, ADX_ABX,
	ABus_out);

	input PHI1;
	input PHI2;
	input ADX;
	input ADX_ABX;
	output ABus_out;

	wire n_adx = ~(ADX);
	wire abff_out;

	AddrBusFF abff (
		.phi_load(PHI1),
		.phi_keep(PHI2),
		.en(ADX_ABX),
		.val(n_adx),
		.q(abff_out));

	assign ABus_out = ~abff_out;

endmodule // AddrBusBit

// Complementary FF with additional Enable input and inverted IO. Uses both half clocks (PHI1/PHI2).
// TODO: Remake it into a simpler version, without the explicit tristates
module AddrBusFF (phi_load, phi_keep, en, val, q, nq);

	input phi_load;		// PHI phase during which the FF value can be modified
	input phi_keep;		// PHI phase during which the current value is "holding".
	input en;			// 1: Writing a value is enabled
	input val;			// New value
	output q;			// Current value
	output nq;			// Current value (complement)

	(* keep = "true" *) wire inp;
	not (inp, val);

	(* keep = "true" *) wire not1out;
	not(not1out, floater);

	(* keep = "true" *) wire not2out;
	not(not2out, not1out);

	(* keep = "true" *) wire floater;
	bufif1(floater, not2out, phi_keep);
	(* keep = "true" *) wire mid;
	bufif1(mid, inp, phi_load);
	bufif1(floater, mid, en);

	assign q = ~not2out;
	assign nq = not2out;

endmodule // AddrBusFF

module DataBusBit (
	PHI1, PHI2,
	ADL, ADH, DB, DB_Ext,
	DL_ADL, DL_ADH, DL_DB,
	RD);

	input PHI1;
	input PHI2;

	inout ADL;
	inout ADH;
	inout DB;
	inout DB_Ext;

	input DL_ADL;
	input DL_ADH;
	input DL_DB;
	input RD;

	dlatch transp_latch (.d(DB_Ext), .en(1'b1), .nq(transp_latch_nq) );
	wire transp_latch_nq;
	dlatch dir_latch (.d(transp_latch_nq), .en(PHI2), .nq(dir_latch_nq) );
	wire dir_latch_nq;

	wire dir_val;
	assign dir_val = PHI1 ? dir_latch_nq : 1'bz;
	assign ADL = DL_ADL ? dir_val : 1'bz;
	assign ADH = DL_ADH ? dir_val : 1'bz;
	assign DB = DL_DB ? dir_val : 1'bz;

	dlatch int_db_latch (.d(DB), .en(1'b1), .nq(int_db_latch_nq) );
	wire int_db_latch_nq;
	dlatch dor_latch (.d(int_db_latch_nq), .en(PHI1), .nq(dor_latch_nq) );
	wire dor_latch_nq;
	bufif0 (DB_Ext, dor_latch_nq, RD);

endmodule // DataBusBit

module WRLatch (PHI1, PHI2, WR, RD);

	input PHI1;
	input PHI2;
	input WR;
	output RD;

	dlatch wr_latch (.d(WR), .en(PHI1), .nq(wr_latch_nq) );
	wire wr_latch_nq;
	wire tmp1;
	nor (tmp1, ~PHI2, wr_latch_nq);
	not (RD, tmp1);

endmodule // WRLatch

module Regs (
	PHI2,
	Y_SB, SB_Y, X_SB, SB_X, S_SB, S_ADL, S_S, SB_S, 
	SB, ADL);

	input PHI2;

	input Y_SB;
	input SB_Y;
	input X_SB;
	input SB_X;
	input S_SB;
	input S_ADL;
	input S_S;  		// Stack reg -> Shadow Stack reg
	input SB_S;

	inout [7:0] SB;
	inout [7:0] ADL;

	XYRegBit yreg[7:0] (.PHI2(PHI2), .Reg_SB(Y_SB), .SB_Reg(SB_Y), .SB_bit(SB), .dbg(y) );
	XYRegBit xreg[7:0] (.PHI2(PHI2), .Reg_SB(X_SB), .SB_Reg(SB_X), .SB_bit(SB), .dbg(x) );
	SRegBit sreg[7:0] (.PHI2(PHI2), .S_SB(S_SB), .S_ADL(S_ADL), .SB_S(SB_S), .S_S(S_S), .SB_bit(SB), .ADL_bit(ADL), .S_dbg(s), .SS_dbg(ss) );

	// Debug. Not on a real chip

	wire [7:0] x, y, ss, s;

endmodule // Regs

module XYRegBit (PHI2, Reg_SB, SB_Reg, SB_bit, dbg);

	input PHI2;
	input Reg_SB;
	input SB_Reg;
	inout SB_bit;
	output dbg; 			// Not on a real chip

	wire d;
	assign d = SB_Reg ? SB_bit : (PHI2 ? not_nq : 1'bz);

	wire hold_latch_nq;
	wire not_nq;
	dlatch hold_latch (.d(d), .en(1'b1), .q(dbg), .nq(hold_latch_nq));
	not (not_nq, hold_latch_nq);

	assign SB_bit = Reg_SB ? not_nq : 1'bz;

endmodule // XYRegBit

module SRegBit (PHI2, S_SB, S_ADL, SB_S, S_S, SB_bit, ADL_bit, S_dbg, SS_dbg);

	input PHI2;
	input S_SB;
	input S_ADL;
	input SB_S;
	input S_S;
	inout SB_bit;
	inout ADL_bit;
	output S_dbg; 		// Not on a real chip
	output SS_dbg; 		// Not on a real chip

	wire d;
	assign d = SB_S ? SB_bit : (S_S ? out_latch_nq : 1'bz);

	wire in_latch_nq;
	wire out_latch_nq;
	dlatch in_latch (.d(d), .en(1'b1), .q(SS_dbg), .nq(in_latch_nq)); 		// Shadow Stack reg
	dlatch out_latch (.d(in_latch_nq), .en(PHI2), .nq(out_latch_nq)); 		// Stack reg
	assign S_dbg = out_latch_nq;

	assign SB_bit = S_SB ? out_latch_nq : 1'bz;
	assign ADL_bit = S_ADL ? out_latch_nq : 1'bz;

endmodule // SRegBit

module ALU (
	PHI2,
	NDB_ADD, DB_ADD, Z_ADD, SB_ADD, ADL_ADD, ADD_SB06, ADD_SB7, ADD_ADL,
	ANDS, EORS, ORS, SRS, SUMS, 
	SB_AC, AC_SB, AC_DB, 
	n_ACIN, n_DAA, n_DSA,
	SB, DB, ADL, ADH,
	ACR, AVR);

	input PHI2;
	
	input NDB_ADD;
	input DB_ADD;
	input Z_ADD;
	input SB_ADD;
	input ADL_ADD;
	input ADD_SB06;
	input ADD_SB7;
	input ADD_ADL;

	input ANDS;
	input EORS;
	input ORS;
	input SRS;
	input SUMS;

	input SB_AC;
	input AC_SB;
	input AC_DB;

	input n_ACIN;
	input n_DAA;
	input n_DSA;

	inout [7:0] SB;
	inout [7:0] DB;
	inout [7:0] ADL;
	inout [7:0] ADH;

	output ACR;
	output AVR;

	// To debug: ai(AI), bi(BI), add_out(ADD), ACIN(CarryIn), ACR(CarryOut), AVR(OverflowOut), AC_q(A)

	// ALU Ops intermediate results

	wire [7:0] nands;
	wire [7:0] ands; 		// odd bits only
	wire [7:0] nors;
	wire [7:0] ors; 		// even bits only
	wire [7:0] xors; 		// odd bits only
	wire [7:0] xnors; 		// even bits only
	wire [7:0] nsums;
	wire [7:0] nres;

	wire [7:0] cout; 		// inverted carry chain (even bits out: regular polarity, odd bits out: inverted polarity)

	// AI/BI Latches

	wire [7:0] ai_d;
	assign ai_d = Z_ADD ? 8'b00000000 : (SB_ADD ? SB : 8'bzzzzzzzz);
	wire [7:0] bi_d;
	assign bi_d = ADL_ADD ? ADL : (DB_ADD ? DB : ( NDB_ADD ? ~DB : 8'bzzzzzzzz) );
	dlatch ai_latch [7:0] (.d(ai_d), .en(8'b11111111), .q(ai) );
	wire [7:0] ai;
	dlatch bi_latch [7:0] (.d(bi_d), .en(8'b11111111), .q(bi) );
	wire [7:0] bi;

	// ALU Ops

	nand na [7:0] (nands, ai, bi);
	nor no [7:0] (nors, ai, bi);

	not (ands[1], nands[1]);
	not (ands[3], nands[3]);
	not (ands[5], nands[5]);
	not (ands[7], nands[7]);

	nor (ors[0], nors[0]);
	nor (ors[2], nors[2]);
	nor (ors[4], nors[4]);
	nor (ors[6], nors[6]);

	nand (xnors[0], ors[0], nands[0]);
	nand (xnors[2], ors[2], nands[2]);
	nand (xnors[4], ors[4], nands[4]);
	nand (xnors[6], ors[6], nands[6]);

	nor (xors[1], nors[1], ands[1]);
	nor (xors[3], nors[3], ands[3]);
	nor (xors[5], nors[5], ands[5]);
	nor (xors[7], nors[7], ands[7]);

	wire ACIN;
	not (ACIN, n_ACIN);
	assign nsums[0] = ~((xnors[0]&ACIN) | ~(xnors[0]|ACIN));
	assign nsums[1] = ~(( xors[1]&~cout[0]) | ~( xors[1]|~cout[0]));
	assign nsums[2] = ~((xnors[2]&~cout[1]) | ~(xnors[2]|~cout[1]));
	assign nsums[3] = ~(( xors[3]&~cout[2]) | ~( xors[3]|~cout[2]));
	assign nsums[4] = ~((xnors[4]&~cout[3]) | ~(xnors[4]|~cout[3]));
	assign nsums[5] = ~(( xors[5]&~cout[4]) | ~( xors[5]|~cout[4]));
	assign nsums[6] = ~((xnors[6]&~cout[5]) | ~(xnors[6]|~cout[5]));
	assign nsums[7] = ~(( xors[7]&~cout[6]) | ~( xors[7]|~cout[6]));

	assign nres = SRS ? ({1'b1,nands[7:1]}) : (
		ANDS ? nands : (
		ORS ? nors : (
		EORS ? xnors : (
		SUMS ? nsums : 8'bzzzzzzzz ))));

	// Carry Chain

	aoi cc0 (.a0(n_ACIN),  .a1(nands[0]), .b(nors[0]), .x(cout[0]) );
	aoi cc1 (.a0(cout[0]), .a1(ors[1]),   .b(ands[1]), .x(cout[1]) );
	aoi cc2 (.a0(cout[1]), .a1(nands[2]), .b(nors[2]), .x(cout[2]) );
	aoi211 cc3 (.a0(cout[2]), .a1(ors[3]), .b(ands[3]), .c(DC3), .x(cout[3]) );
	aoi cc4 (.a0(cout[3]), .a1(nands[4]), .b(nors[4]), .x(cout[4]) );
	aoi cc5 (.a0(cout[4]), .a1(ors[5]),   .b(ands[5]), .x(cout[5]) );
	aoi cc6 (.a0(cout[5]), .a1(nands[6]), .b(nors[6]), .x(cout[6]) );
	aoi cc7 (.a0(cout[6]), .a1(ors[7]),   .b(ands[7]), .x(cout[7]) );

	// Fast BCD Carry  (https://patents.google.com/patent/US3991307A)

	wire nncarry4 = ~(~cout[4]);

	wire a0, b0, c0;
	wire temp1;
	assign temp1 = ~((n_ACIN&nands[0]) | nors[0]);
	assign a0 = ~(nors[2] | ~(ands[1] & temp1));
	wire nnands2;
	assign nnands2 = ~nands[2];
	assign b0 = ~(nnands2 | xors[3]);
	assign c0 = ~(temp1 | ~(nnands2|nors[2]) | ands[1] | xors[1]);
	assign DC3 = (a0 | ~(b0|c0)) & ~n_DAA;

	wire a1, b1, c1;
	assign a1 = ~(xnors[6] | ~(ands[5]&nncarry4));
	assign b1 = ~(xors[7] | ~nands[6]);
	assign c1 = ~(nncarry4 | ands[5] | xors[5] | ~xnors[6]);
	assign DC7 = (a1 | ~(b1|c1)) & ~n_DAA;

	// ACR, AVR

	dlatch DCLatch (.d(DC7), .en(PHI2), .q(DCLatch_q) );
	wire DCLatch_q;
	wire AC7;
	not (AC7, cout[7]);
	dlatch ACLatch (.d(AC7), .en(PHI2), .q(ACLatch_q) );
	wire ACLatch_q;
	wire AVRLatch_d;
	assign AVRLatch_d = ~(~(cout[6]|nands[7]) | (cout[6]&nors[7]));
	dlatch AVRLatch (.d(AVRLatch_d), .en(PHI2), .nq(AVR) );

	wire nACR;
	nor (nACR, DCLatch_q, ACLatch_q);
	not (ACR, nACR);

	// Adder Hold

	wire nADD1, nADD2, nADD5, nADD6;

	wire [7:0] add_out;
	dlatch add [7:0] (.d(nres), .en(PHI2), .nq(add_out) );
	assign ADL = ADD_ADL ? add_out : 8'bzzzzzzzz;
	assign SB[6:0] = ADD_SB06 ? add_out[6:0] : 7'bzzzzzzz;
	assign SB[7] = ADD_SB7 ? add_out[7] : 1'bz;

	not (nADD1, add_out[1]);
	not (nADD2, add_out[2]);
	not (nADD5, add_out[5]);
	not (nADD6, add_out[6]);

	// BCD Correction

	wire DAAL, DAAH, DSAL, DSAH;

	wire daal_latch_d;
	nand (daal_latch_d, ~n_DAA, ~cout[3]);
	dlatch daal_latch (.d(daal_latch_d), .en(PHI2), .nq(DAAL) );
	dlatch daah_latch (.d(~n_DAA), .en(PHI2), .nq(daah_latch_nq) );
	wire daah_latch_nq;
	nor (DAAH, nACR, daah_latch_nq);
	wire dsal_latch_d;
	nor (dsal_latch_d, ~cout[3], n_DSA);
	dlatch dsal_latch (.d(dsal_latch_d), .en(PHI2), .q(DSAL) );
	dlatch dsah_latch (.d(~n_DSA), .en(PHI2), .nq(dsah_latch_nq) );
	wire dsah_latch_nq;
	nor (DSAH, ACR, dsah_latch_nq);

	bcd_nibble bcd_lo (.daa(DAAL), .dsa(DSAL), .sb(SB[3:0]), .bcd(acin[3:0]), .b1(nADD1), .b2(nADD2) );
	bcd_nibble bcd_hi (.daa(DAAH), .dsa(DSAH), .sb(SB[7:4]), .bcd(acin[7:4]), .b1(nADD5), .b2(nADD6) );

	// Accumulator + Bus Mpx

	wire [7:0] acin;

	wire [7:0] ac_d;
	assign ac_d = PHI2 ? AC_q : (SB_AC ? acin : 8'bzzzzzzzz);
	dlatch AC [7:0] (.d(ac_d), .en(8'b11111111), .nq(AC_nq) );
	wire [7:0] AC_nq;
	wire [7:0] AC_q;
	assign AC_q = ~AC_nq;

	assign SB = AC_SB ? AC_q : 8'bzzzzzzzz;
	assign DB = AC_DB ? AC_q : 8'bzzzzzzzz;

endmodule // ALU

// The BCD correction circuitry is symmetrical for each 4-bit nibble
module bcd_nibble (daa, dsa, sb, bcd, b1, b2);

	input daa;
	input dsa;
	input [3:0] sb;
	output [3:0] bcd;
	input b1;
	input b2;

	assign bcd[0] = sb[0];
	xor (bcd[1], ~(daa|dsa), ~sb[1]);
	xor (bcd[2], ((~(b1&daa)) & (~(~b1&dsa))), ~sb[2]);
	wire t1, t2;
	nand (t1, b1, b2);
	nor (t2, b1, b2);
	xor (bcd[3], ((~(t1&daa)) & (~(~t2&dsa))), ~sb[3]);

endmodule // bcd_nibble

module PC (
	PHI2,
	n_IPC,
	ADL_PCL, PCL_PCL, PCL_ADL, PCL_DB, ADH_PCH, PCH_PCH, PCH_ADH, PCH_DB,
	ADL, ADH, DB);

	input PHI2;

	input n_IPC;

	input ADL_PCL;
	input PCL_PCL;
	input PCL_ADL;
	input PCL_DB;
	input ADH_PCH;
	input PCH_PCH;
	input PCH_ADH;
	input PCH_DB;

	inout [7:0] ADL;
	inout [7:0] ADH;
	inout [7:0] DB;

	wire [7:0] pcl_nout;
	wire [3:0] pch_nout;
	wire [7:1] pclc;
	wire [7:1] pchc;

	wire PCLC;
	nor (PCLC, n_IPC, pcl_nout[0], pcl_nout[1], pcl_nout[2], pcl_nout[3], pcl_nout[4], pcl_nout[5], pcl_nout[6], pcl_nout[7] );
	wire PCHC;
	nor (PCHC, ~PCLC, pch_nout[0], pch_nout[1], pch_nout[2], pch_nout[3] );

	// PCL

	pc_notcarry pcl0 (.pc(pc[0]), .pcs(pcs[0]), .PHI2(PHI2), .n_carry(n_IPC), .AD(ADL[0]), .DB(DB[0]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[0]), .cout(pclc[1]) );
	pc_carry    pcl1 (.pc(pc[1]), .pcs(pcs[1]), .PHI2(PHI2), .carry(pclc[1]), .AD(ADL[1]), .DB(DB[1]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[1]), .n_cout(pclc[2]) );
	pc_notcarry pcl2 (.pc(pc[2]), .pcs(pcs[2]), .PHI2(PHI2), .n_carry(pclc[2]), .AD(ADL[2]), .DB(DB[2]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[2]), .cout(pclc[3]) );
	pc_carry    pcl3 (.pc(pc[3]), .pcs(pcs[3]), .PHI2(PHI2), .carry(pclc[3]), .AD(ADL[3]), .DB(DB[3]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[3]), .n_cout(pclc[4]) );
	pc_notcarry pcl4 (.pc(pc[4]), .pcs(pcs[4]), .PHI2(PHI2), .n_carry(pclc[4]), .AD(ADL[4]), .DB(DB[4]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[4]), .cout(pclc[5]) );
	pc_carry    pcl5 (.pc(pc[5]), .pcs(pcs[5]), .PHI2(PHI2), .carry(pclc[5]), .AD(ADL[5]), .DB(DB[5]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[5]), .n_cout(pclc[6]) );
	pc_notcarry pcl6 (.pc(pc[6]), .pcs(pcs[6]), .PHI2(PHI2), .n_carry(pclc[6]), .AD(ADL[6]), .DB(DB[6]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[6]), .cout(pclc[7]) );
	pc_carry    pcl7 (.pc(pc[7]), .pcs(pcs[7]), .PHI2(PHI2), .carry(pclc[7]), .AD(ADL[7]), .DB(DB[7]), .PC_AD(PCL_ADL), .PC_DB(PCL_DB), .AD_PC(ADL_PCL), .PC_PC(PCL_PCL), .n_val(pcl_nout[7])  ); 	// discard output carry, PCLC used instead

	// PCH

	pc_carry    pch0 (.pc(pc[8]), .pcs(pcs[8]), .PHI2(PHI2), .carry(PCLC), .AD(ADH[0]), .DB(DB[0]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_val(pch_nout[0]), .n_cout(pchc[1]) );
	pc_notcarry pch1 (.pc(pc[9]), .pcs(pcs[9]), .PHI2(PHI2), .n_carry(pchc[1]), .AD(ADH[1]), .DB(DB[1]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_val(pch_nout[1]), .cout(pchc[2]) );
	pc_carry    pch2 (.pc(pc[10]), .pcs(pcs[10]), .PHI2(PHI2), .carry(pchc[2]), .AD(ADH[2]), .DB(DB[2]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_val(pch_nout[2]), .n_cout(pchc[3]) );
	pc_notcarry pch3 (.pc(pc[11]), .pcs(pcs[11]), .PHI2(PHI2), .n_carry(pchc[3]), .AD(ADH[3]), .DB(DB[3]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_val(pch_nout[3])  ); 	// discard output carry, PCHC used instead

	pc_carry    pch4 (.pc(pc[12]), .pcs(pcs[12]), .PHI2(PHI2), .carry(PCHC), .AD(ADH[4]), .DB(DB[4]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_cout(pchc[5]) );
	pc_notcarry pch5 (.pc(pc[13]), .pcs(pcs[13]), .PHI2(PHI2), .n_carry(pchc[5]), .AD(ADH[5]), .DB(DB[5]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .cout(pchc[6]) );
	pc_carry    pch6 (.pc(pc[14]), .pcs(pcs[14]), .PHI2(PHI2), .carry(pchc[6]), .AD(ADH[6]), .DB(DB[6]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH), .n_cout(pchc[7]) );
	pc_notcarry pch7 (.pc(pc[15]), .pcs(pcs[15]), .PHI2(PHI2), .n_carry(pchc[7]), .AD(ADH[7]), .DB(DB[7]), .PC_AD(PCH_ADH), .PC_DB(PCH_DB), .AD_PC(ADH_PCH), .PC_PC(PCH_PCH) ); 		// discard output carry, no need

	// Debug
	wire IPC; 				// 1: Incerement PC
	not (IPC, n_IPC);
	wire [15:0] pc; 		// PC
	wire [15:0] pcs; 		// PC Shadow aka Select

endmodule // PC

// PC bit, input carry in inverted polarity and output carry in regular polarity
module pc_notcarry (PHI2, n_carry, AD, DB, PC_AD, PC_DB, AD_PC, PC_PC, n_val, cout, pc, pcs);

	input PHI2;
	input n_carry;
	inout AD;
	inout DB;
	input PC_AD;
	input PC_DB;
	input AD_PC;
	input PC_PC;
	output n_val;
	output cout;
	output pc; 		// Not on a real chip
	output pcs;		// Not on a real chip

	wire in_latch_d;
	assign #2 in_latch_d = AD_PC ? AD : (PC_PC ? q : 1'bz);

	wire out_latch_d;
	aoi g1 (.a0(n_val), .a1(n_carry), .b(cout), .x(out_latch_d) );

	dlatch in_latch (.d(in_latch_d), .en(1'b1), .nq(n_val) ); 				// PCLS/PCHS bits
	dlatch out_latch (.d(out_latch_d), .en(PHI2), .nq(out_latch_nq) ); 		// PCL/PCH bits
	wire out_latch_nq;
	wire q;
	not (q, out_latch_nq);

	nor (cout, n_val, n_carry);

	assign DB = PC_DB ? q : 1'bz;
	assign AD = PC_AD ? q : 1'bz;
	assign pcs = ~n_val;
	assign pc = q;

endmodule // pc_notcarry

// PC bit, input carry in regular polarity and output carry in inverted polarity
module pc_carry (PHI2, carry, AD, DB, PC_AD, PC_DB, AD_PC, PC_PC, n_val, n_cout, pc, pcs);

	input PHI2;
	input carry;
	inout AD;
	inout DB;
	input PC_AD;
	input PC_DB;
	input AD_PC;
	input PC_PC;
	output n_val;
	output n_cout;
	output pc; 		// Not on a real chip
	output pcs;		// Not on a real chip	

	wire in_latch_d;
	assign #2 in_latch_d = AD_PC ? AD : (PC_PC ? q : 1'bz);

	wire out_latch_d;
	oai g1 (.a0(val), .a1(carry), .b(n_cout), .x(out_latch_d) );

	dlatch in_latch (.d(in_latch_d), .en(1'b1), .nq(n_val) ); 			// PCLS/PCHS bits
	wire val;
	not (val, n_val);
	dlatch out_latch (.d(out_latch_d), .en(PHI2), .nq(q) ); 		// PCL/PCH bits
	wire q;

	nand (n_cout, val, carry);

	assign DB = PC_DB ? q : 1'bz;
	assign AD = PC_AD ? q : 1'bz;
	assign pcs = val;
	assign pc = q;

endmodule // pc_carry

module BusMux (PHI2, SB, DB, ADL, ADH, Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17, SB_DB, SB_ADH );

	input PHI2;
	inout [7:0] SB;
	inout [7:0] DB;
	inout [7:0] ADL;
	inout [7:0] ADH;

	input Z_ADL0;
	input Z_ADL1;
	input Z_ADL2;
	input Z_ADH0;
	input Z_ADH17;
	input SB_DB;
	input SB_ADH;

	BusPrecharge precharge (
		.PHI2(PHI2),
		.SB(SB),
		.DB(DB),
		.ADL(ADL),
		.ADH(ADH) );

	ConstGen constgen (
		.ADL(ADL),
		.ADH(ADH),
		.Z_ADL0(Z_ADL0),
		.Z_ADL1(Z_ADL1),
		.Z_ADL2(Z_ADL2),
		.Z_ADH0(Z_ADH0),
		.Z_ADH17(Z_ADH17) );

	BusVsBus busbus (
		.SB(SB),
		.DB(DB),
		.ADH(ADH),
		.SB_DB(SB_DB),
		.SB_ADH(SB_ADH) );

endmodule // BusMux

module BusPrecharge (PHI2, SB, DB, ADL, ADH );

	input PHI2;
	inout [7:0] SB;
	inout [7:0] DB;
	inout [7:0] ADL;
	inout [7:0] ADH;

	assign SB = PHI2 ? 8'b11111111 : 8'bzzzzzzzz;
	assign DB = PHI2 ? 8'b11111111 : 8'bzzzzzzzz;
	assign ADL = PHI2 ? 8'b11111111 : 8'bzzzzzzzz;
	assign ADH = PHI2 ? 8'b11111111 : 8'bzzzzzzzz;

endmodule // BusPrecharge

module ConstGen (ADL, ADH, Z_ADL0, Z_ADL1, Z_ADL2, Z_ADH0, Z_ADH17);

	inout [7:0] ADL;
	inout [7:0] ADH;
	input Z_ADL0;
	input Z_ADL1;
	input Z_ADL2;
	input Z_ADH0;
	input Z_ADH17;

	assign ADL[0] = Z_ADL0 ? 1'b0 : 1'bz;
	assign ADL[1] = Z_ADL1 ? 1'b0 : 1'bz;
	assign ADL[2] = Z_ADL2 ? 1'b0 : 1'bz;

	assign ADH[0] = Z_ADH0 ? 1'b0 : 1'bz;
	assign ADH[7:1] = Z_ADH17 ? 7'b0000000 : 7'bzzzzzzz;

endmodule // ConstGen

module BusVsBus (SB, DB, ADH, SB_DB, SB_ADH);

	inout [7:0] SB;
	inout [7:0] DB;
	inout [7:0] ADH;
	input SB_DB;
	input SB_ADH;

	tranif1 sb_db [7:0] (SB, DB, {8{SB_DB}});
	tranif1 sb_adh [7:0] (SB, ADH, {8{SB_ADH}});

endmodule // BusVsBus

// Ordinary 2-and to or inverted (AOI-21)
module aoi (a0, a1, b, x);

	input a0;
	input a1;
	input b;
	output x;

	nor (x, a0 & a1, b);

endmodule // aoi

// 2-and to 3-or inverted (AOI-211)
module aoi211 (a0, a1, b, c, x);

	input a0;
	input a1;
	input b;
	input c;
	output x;

	nor (x, a0 & a1, b, c);

endmodule // aoi

// Asynchronous dynamic (d=dynamic) latch used in old NMOS chips. Totally unprotected against jitter and other timing circuit problems.
// Use carefully and wisely.

// This element can be moved to DFF using CLK as Enable input.

module dlatch (d, en, q, nq);

	input d;		// Input value
	input en;		// 1: Allow write
	output q;		// Current value
	output nq; 		// Current value (complement)

`ifdef ICARUS

	reg dout; 
	always @(d or en) begin
		if (en == 1'b1 && (d == 1'b0 || d == 1'b1))
			dout <= d;   // Use non-blocking
	end

	assign q = dout;
	assign nq = ~dout;

	initial dout <= 1'b0;

`elsif QUARTUS

	LATCH MyLatch (.d(d), .ena(en), .q(q), .nq(nq));

`else

	(* keep = "true" *) wire floater;
	bufif1(floater, d, en);

	buf (q, floater);
	not (nq, floater);

`endif

endmodule // dlatch

// Ordinary 2-or to and inverted (OAI-21)

module oai (a0, a1, b, x);

	input a0;
	input a1;
	input b;
	output x;

	nand (x, a0 | a1, b);

endmodule // oai

// Parallel nor.

module pnor (a0, a1, x);
	input a0;
	input a1;
	output x;

	nor (x, a0, a1);
endmodule // pnor

```
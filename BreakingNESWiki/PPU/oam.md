# OAM

![ppu_locator_oam](/BreakingNESWiki/imgstore/ppu/ppu_locator_oam.jpg)

Спрайтовая память (OAM, Object Attribute Memory) занимает почти четверть поверхности PPU, в те времена память была роскошью. Размер OAM составляет 2112 разрядов, из них 1856 используются для хранения 64 спрайтов (29 разрядов на спрайт), а остальные 256 бит используются специальным образом, для создания выборки 8 текущих спрайтов, которые будут показаны на текущей строке. Эта область OAM обычно называется "temporary OAM" или OAM2.

Комбинированное изображение топологии ячейки памяти:

![ppu_oam_closeup](/BreakingNESWiki/imgstore/ppu/ppu_oam_closeup.jpg)

Компоненты OAM:
- Массив ячеек памяти (2112 ячеек)
- Декодер колонки
- Декодер ряда
- Схема контроля OAM Buffer
- OAM Buffer (OB)

![OAM_All](/BreakingNESWiki/imgstore/ppu/OAM_All.png)

Таблица сигналов:

|Сигнал/группа сигналов|Описание|
|---|---|
|**OAM Address**||
|/OAM0-7|Адрес основной OAM (в инверсной логике)|
|OAM8|1: Использовать Temp OAM|
|**FSM**||
|BLNK|Активен когда рендеринг PPU отключен (сигналом `BLACK`) или во время VBlank|
|I/OAM2|"Init OAM2". Инициализировать дополнительную OAM|
|/VIS|"Not Visible". Невидимая часть сигнала (использует спрайтовая логика)|
|**Из схемы сравнения спрайтов**||
|SPR_OV|Sprite Overflow|
|OAMCTR2|Управление OAM Buffer|
|**CPU I/F**||
|/R4|0: Чтение регистра $2004|
|/W4|0: Запись в регистр $2004|
|/DBE|0: "Data Bus Enable", включение CPU интерфейса|
|**Внутренние сигналы**||
|COL0-7|Определяет колонку для доступа к основной OAM|
|COLZ|Определяет колонку для доступа к Temp OAM|
|ROW0-31|Определяет номер ряда. Во время PCLK все выходы ROW равны 0.|
|OB/OAM|1: Записать текущее значение OB в выходную защёлку|
|/WE|0: записать в выбранную ячейку OAM значение с выходной защёлки OB|
|**Выходные сигналы**||
|OFETCH|"OAM Fetch"|
|OB0-7|Текущее значение OAM Buffer (из OB_FF)|

## Организация OAM

По соглашению группы ячеек, которые адресуются младшими разрядами адреса будем считать "колонками" (bit lines), а группы ячеек, адресуемые старшими разрядами будем считать "рядами" (word lines).

- /OAM0-2: Определяют колонку (с небольшой особенностью, см. далее)
- /OAM3-7: Определяют ряд

Дополнительно можно посмотреть карту распределения ячеек OAM тут: https://github.com/ogamespec/OAMMap

## Ячейка памяти

|![oam_cell_topo](/BreakingNESWiki/imgstore/ppu/oam_cell_topo.png)|![oam_cell_tran2](/BreakingNESWiki/imgstore/ppu/oam_cell_tran2.png)|![oam_cell](/BreakingNESWiki/imgstore/ppu/oam_cell.jpg)|
|---|---|---|

Ячейка OAM представляет собой типовую 4T-DRAM ячейку, значение хранится как паразитная ёмкость на затворах двух закольцованных транзисторов, поэтому значение на ячейке постоянно деградирует. Это значение входит и выходит в виде комплемента (BL + BLBar) когда выбирается соответствующий Word Line.

Эффект деградации памяти OAM называется "OAM Decay" и он широко известен. Для борьбы с этим эффектом программы для NES
содержат кэш OAM в обычной памяти процессора (обычно по адресу $200) и каждый VBlank копируют этот кэш в OAM с помощью спрайтовой DMA APU.

Обновление OAM производится в 2 захода, в процессе Precharge:
- PCLK=1: в OAM закачивается заряд, при этом все ячейки "закрыты"
- PCLK=0: заряд используется для выбранного Word Line ячеек, обновляя их значение.
Если никакой Word Line не выбран в течении длительного времени, то процесс Precharge не приведёт к корректному обновлению ячеек слова и ячейки начнут деградировать (эффект "OAM Decay").

TBD: Рассчитать или измерить тайминги деградации ячеек.

![OAM](/BreakingNESWiki/imgstore/ppu/OAM.png)

![OAM_Lane](/BreakingNESWiki/imgstore/ppu/OAM_Lane.png)

## Декодер колони

![oam_col_decoder](/BreakingNESWiki/imgstore/ppu/oam_col_decoder.jpg)

Схема представляет собой одноединичный декодер (1-из-n).

|Выходы COL для разрядов OAM Buffer 0, 1, 5-7|Выходы COL для разрядов OAM Buffer 2-4|
|---|---|
|![oam_col_outputs1](/BreakingNESWiki/imgstore/ppu/oam_col_outputs1.jpg)|![oam_col_outputs2](/BreakingNESWiki/imgstore/ppu/oam_col_outputs2.jpg)|

Пропуск битовых линий (колонок) у разрядов 2-4 сделан для экономии памяти. Если вывести соответствие адреса OAM и значений COL, которое получается из младших разрядов, то получится такое:

```
OamAddr: 0, col: 0
OamAddr: 1, col: 1
OamAddr: 2, col: 2 ATTR  UNUSED for OB[2-4]
OamAddr: 3, col: 3
OamAddr: 4, col: 4
OamAddr: 5, col: 5
OamAddr: 6, col: 6 ATTR  UNUSED for OB[2-4]
OamAddr: 7, col: 7
OamAddr: 8, col: 0
OamAddr: 9, col: 1
OamAddr: 10, col: 2 ATTR  UNUSED for OB[2-4]
OamAddr: 11, col: 3
OamAddr: 12, col: 4
OamAddr: 13, col: 5
OamAddr: 14, col: 6 ATTR  UNUSED for OB[2-4]
OamAddr: 15, col: 7
...
```

Как видно COL2 и COL6 попадают как раз на байт атрибутов спрайта, в котором не используются биты 2-4.

Для Temp OAM пропуск разрядов не производится, чтобы не усложнять итак замороченную схему.

## Декодер ряда

![oam_row_decoder](/BreakingNESWiki/imgstore/ppu/oam_row_decoder.jpg)

Схема представляет собой одноединичный декодер (1-из-n).

Декодер устроен таким образом, что нумерация рядов производится справа-налево (0-31). Но из-за того, что в NTSC PPU адрес OAM выдается в инвертированном виде (/OAM0-7) - логическая нумерация рядов перепутывается. В результате получается такое:

|Номер ряда (топологический)|Номер ряда NTSC PPU (логический)|
|---|---|
|31|111 11|
|30|011 11|
|29|101 11|
|28|001 11|
|27|110 11|
|26|010 11|
|25|100 11|
|24|000 11|
|23-16|XXX 01|
|15-8|XXX 10|
|7-0|XXX 00|

Или если в очередности справа-налево, сгруппировав по 4 группы:
```
0 16 8 24 4 20 12 28
1 17 9 25 5 21 13 29
2 18 10 26 6 22 14 30
3 19 11 27 7 23 15 31
```

В PAL PPU нумерация соответствует задуманной декодером очередности 0-31, справа-налево, по причине того, что адрес OAM подаётся в прямой логике (`OAM0-7`).

Во время PCLK = 1 все выходы ROW равны 0, то есть доступ ко всем ячейкам OAM закрыт.

## Схема адресного декодера

Общая схема декодера колонки/ряда:

![OAM_AddressDecoder](/BreakingNESWiki/imgstore/ppu/OAM_AddressDecoder.png)

## Схема управления OAM Buffer

Схема используется для задания режимов работы OB и управлением передачи значений между ним и OAM.

![oam_buffer_control](/BreakingNESWiki/imgstore/ppu/oam_buffer_control.jpg)

![OAM_Control](/BreakingNESWiki/imgstore/ppu/OAM_Control.png)

## OAM Buffer (OB)

OAM Buffer используется как перевалочный пункт для хранения байта который нужно записать в OAM или байта, который был прочитан из OAM для потребителей.

Схема состоит из 8 идентичных схем для каждого разряда:

![oam_buffer_bit](/BreakingNESWiki/imgstore/ppu/oam_buffer_bit.jpg)

(На картинке представлена схема для хранения разряда OB0).

![OAM_Buffer](/BreakingNESWiki/imgstore/ppu/OAM_Buffer.png)

![OAM_BufferBit](/BreakingNESWiki/imgstore/ppu/OAM_BufferBit.png)

Схема разряда OB весьма сложная в понимании даже для бывалых схемотехников, по причине того что она сильно запутана, кроме того имеет дело с Tri-State логикой (в терминах Verilog - `inout`), которая связана с доступом к OAM Cells.

Вот отличительные особенности OB:
- Схема содержит 2 FF и 2 защёлки
- `Input_FF` используется для загрузки значения с OAM Cell и нужен для того, чтобы "обезопасить" остальную схему от значений `z`, которые могут находится на ячейке. Во время PCLK = 1 этот FF очищается (одновременно с OAM Precharge)
- `OB_FF` хранит последнее текущее значение OAM Buffer. С этих FF наружу выдаются значения сигналов OB0-7. Отрывается FF во время PCLK = 0.
- `Защёлка R4` используется для CPU I/F. В ней хранится значение для чтения регистра $2004. Открывается защёлка во время PCLK = 1.
- Выходная защёлка (`out_latch`) используется для записи нового значения в OAM Cell. Новое значение может прийти с OB_FF (`OB/OAM` = 1) или с шины данных (`BLNK` = 1). Сигналы `OB/OAM` и `BLNK` никогда не принимают одновременно значение `1`, но могут принимать одновременно значение `0` (то есть когда выходная защёлка закрыта).
- Значение с выходной защёлки сохраняется в выбранную OAM Cell только когда это разрешено сигналом `/WE` = 0.
